<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="utf-8">
	<meta name="keywords" content="javascript,js,front-end,book,tutorial,shenlvmeng">
	<meta name="description" content="前端技术学习笔记">
	<meta name="author" content="shenlvmeng">
	<title>Front-end tools book(1)</title>
	<link rel="stylesheet" type="text/css" href="./css/book.css">
	<link rel="stylesheet" href="./css/atom-one-dark.css">
	<script src="./highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
	<aside>
		<a href="#" class="title">前端技术学习笔记</a>
		<ul>
			<li><a href="#introduction">前言</a></li>
			<li><a href="#tail">尾注</a></li>
		</ul>
		<hr>
		<a href="#nodejs">nodeJS</a>
		<ul>
			<li><a href="#node_what_why">What and Why</a></li>
			<li><a href="#node_install">安装</a></li>
			<li><a href="#node_modules">模块</a></li>
			<li><a href="#node_require">代码组织</a></li>
			<li><a href="#node_file">文件操作</a></li>
			<li><a href="#node_network">网络操作</a></li>
			<li><a href="#node_thread">进程管理</a></li>
			<li><a href="#node_features">特点</a></li>
			<li><a href="#node_examples">使用示例</a></li>
			<li><a href="#node_more">更多</a></li>
		</ul>
		<a href="#npm">npm</a>
		<ul>
			<li><a href="#npm_introduction">简介</a></li>
			<li><a href="#npm_install">安装</a></li>
			<li><a href="#npm_commands">常用命令</a></li>
			<li><a href="#npm_download">下载第三方包</a></li>
			<li><a href="#npm_install_cmd">安装命令行程序</a></li>
			<li><a href="#npm_release">发布自己的包</a></li>
			<li><a href="#npm_version">版本号控制</a></li>
			<li><a href="#npm_sum_up">小结</a></li>
			<li><a href="#npm_more">更多</a></li>
		</ul>
		<a href="#bower">Bower</a>
		<ul>
			<li><a href="#bower_introduction">简介</a></li>
			<li><a href="#bower_usage">使用</a></li>
			<li><a href="#bower_question">Bower or npm?</a></li>
		</ul>
		<a href="#browserify">Browserify</a>
		<ul>
			<li><a href="#brow_intro_usage">简介与使用</a></li>
			<li><a href="#brow_manage_generate">管理与生成</a></li>
		</ul>
		<a href="#webpack">Webpack</a>
		<ul>
			<li><a href="#webpack_why">Why</a></li>
			<li><a href="#webpack_usage">安装使用</a></li>
			<li><a href="#webpack_config">配置文件</a></li>
			<li><a href="#webpack_more">更多</a></li>
		</ul>
		<a href="#grunt">Grunt</a>
		<ul>
			<li><a href="#grunt_tutorial">入门</a></li>
			<li><a href="#gruntfile">Gruntfile</a></li>
			<li><a href="#grunt_config">任务配置</a></li>
			<li><a href="#grunt_example">配置实例</a></li>
			<li><a href="#grunt_task">任务与插件</a></li>
			<li><a href="#grunt_more">更多</a></li>
		</ul>
		<a href="#gulp">Gulp</a>
		<ul>
			<li><a href="#gulp_tutorial">入门</a></li>
			<li><a href="#gulp_api">常用API</a></li>
			<li><a href="#gulp_cli">CLI使用</a></li>
			<li><a href="#gulp_more">更多</a></li>
		</ul>
		<a href="#commonjs">CommonJS</a>
		<ul>
			<li><a href="#common_brief">简介</a></li>
			<li><a href="#common_feature">特点</a></li>
			<li><a href="#common_module">Module</a></li>
			<li><a href="#require">Require</a></li>
			<li><a href="#amd">AMD and more?</li>
			<li><a href="#common_more">更多</a></li>
		</ul>
		<a href="#backbone">Backbone.js</a>
		<ul>
			<li><a href="#backbone_brief">概述</a></li>
			<li><a href="#backbone_structure">项目组成</a></li>
			<li>
				<a href="#backbone_api">API介绍(v1.3.3)</a>
				<ul>
					<li><a href="#backbone_view">View</a></li>
					<li><a href="#backbone_event">Events</a></li>
					<li><a href="#backbone_router">Router</a></li>
					<li><a href="#backbone_model">Model</a></li>
					<li><a href="#backbone_collection">Collection</a></li>
				</ul>
			</li>
			<li><a href="#backbone_demo">Demos</a></li>
			<li><a href="#backbone_more">更多</a></li>
		</ul>
		<a href="#express">Express JS</a>
		<ul>
			<li><a href="#express_brief">概述</a></li>
			<li><a href="#express_basic">基本原理</a></li>
			<li><a href="#express_methods">常用方法</a></li>
			<li><a href="#express_template">网页模板</a></li>
			<li><a href="#express_router">路由</a></li>
			<li><a href="#express_modules">常用模块</a></li>
			<ul>
				<li><a href="#body-parser">body-parser</a></li>
				<li><a href="#cookie-parser">cookie-parser</a></li>
				<li><a href="#express-session">Express-session</a></li>
				<li><a href="#connect-mongo">Connect-mongo</a></li>
				<li><a href="#ejs">Ejs</a></li>
				<li><a href="#express-mongo">Mongodb</a></li>
				<li><a href="#express-flash">Connect-flash</a></li>
			</ul>
			<a href="#express_more">更多</a>
		</ul>
		<a href="#react">React JS</a>
		<ul>
			<li><a href="#react_what_why">What and Why</a></li>
			<li><a href="#thinking_in_react_way">Thinking in React Way</a></li>
			<li><a href="#react_data">数据呈现</a></li>
			<ul>
				<li><a href="#jsx">JSX</a></li>
				<li><a href="#jsx_html">JSX属性扩散与HTML</a></li>
			</ul>
			<li><a href="#react_interact">添加交互</a></li>
			<li><a href="#react_component">组合组件</a></li>
			<li><a href="#react_form">表单组件</a></li>
			<li><a href="#react_component_life">组件说明与生命周期</a></li>
			<li><a href="#refs">Refs</a></li>
			<li><a href="#react_api">API</a></li>
			<ul>
				<li><a href="#react_reactapi">React</a></li>
				<li><a href="#reactdomapi">ReactDOM</a></li>
				<li><a href="#reactdomserverapi">ReactDOMServer</a></li>
				<li><a href="#reactcomponentapi">Component</a></li>
			</ul>
			<li><a href="#react_others">标签/属性/事件</a></li>
			<li><a href="#flux">Flux/Redux</a></li>
			<li><a href="#react_more">更多</a></li>
		</ul>
		<a href="#angular">Angular JS</a>
		<ul>
			<li><a href="#angular_brief">简介与安装</a></li>
			<li><a href="#angular_usage">使用</a></li>
			<ul>
				<li><a href="#angular_app">应用/控制器</a></li>
				<li><a href="#angular_expression">表达式</a></li>
				<li><a href="#angular_model">数据模型</a></li>
				<li><a href="#angular_filter">过滤器</a></li>
				<li><a href="#angular_service">服务</a></li>
				<li><a href="#angular_sql">Sql</a></li>
				<li><a href="#angular_dom">DOM/事件</a></li>
				<li><a href="#angular_form">表单验证</a></li>
				<li><a href="#angular_router">路由</a></li>
				<li><a href="#angular_api">通用API函数</a></li>
			</ul>
			<li><a href="#dependency_injection">依赖注入</a></li>
			<li><a href="#angular_extend_command">基础拓展指令</a></li>
			<li><a href="#angular_services">常用服务</a></li>
			<li><a href="#angular2">Angular 2</a></li>
			<ul>
				<li><a href="#componency">组件化</a></li>
				<li><a href="#angular2_extend_commonds">拓展命令</a></li>
			</ul>
			<li><a href="#angular_more">更多</a></li>
		</ul>
		<a href="#mangodb">Mangodb</a>
		<ul>
			<li><a href="#mango_brief">简介</a></li>
			<li><a href="#mango_unit">基本单位</a></li>
			<li><a href="#mango_database">连接/创建/删除数据库</a></li>
			<li><a href="#mango_crud">CRUD操作</a></li>
			<li><a href="#mango_index">索引与聚合</a></li>
			<li><a href="#mango_others">其他</a></li>
		</ul>
		<a href="#socketio">Socket.io</a>
		<a href="#jade">Jade</a>
		<ul>
			<li><a href="#jade_brief">简介</a></li>
			<li><a href="#jade_lang">语法</a></li>
		</ul>
		<a href="#d3">D3.js</a>
		<ul>
			<li><a href="#d3_brief">简介</a></li>
			<li><a href="#svg">SVG介绍</a></li>
			<ul>
				<li><a href="#svg_axis">坐标</a></li>
				<li><a href="#svg_shape_path">形状与路径</a></li>
				<li><a href="#svg_fill_stroke">填充与边框</a></li>
				<li><a href="#svg_pattern_text">模式与文字</a></li>
				<li><a href="#svg_transform_distord">渐变与变形</a></li>
				<li><a href="#svg_cut">剪切与遮罩</a></li>
				<li><a href="#svg_filter">滤镜</a></li>
				<li><a href="#svg_others">其他</a></li>
			</ul>
			<li><a href="#d3_dom">DOM操作API</a></li>
			<li><a href="#d3_scale">比例尺API</a></li>
			<li><a href="#d3_axis">坐标轴API</a></li>
			<li><a href="#d3_transition">渐变API</a></li>
			<li><a href="#d3_layout">布局API & 形状API</a></li>
			<ul>
				<li><a href="#d3_pie">饼状图</a></li>
				<li><a href="#d3_force">力导向图</a></li>
				<li><a href="#d3_chord">弦图</a></li>
				<li><a href="#d3_cluster">集群图/树状图/矩阵树图</a></li>
				<li><a href="#d3_bundle">捆图</a></li>
				<li><a href="#d3_pack">打包图</a></li>
				<li><a href="#d3_partition">分区图</a></li>
				<li><a href="#d3_geo">地理图</a></li>
				<li><a href="#d3_histogram">直方图</a></li>
				<li><a href="#d3_stack">堆栈图</a></li>
			</ul>
			<li><a href="#d3_xhr">请求API</a></li>
			<li><a href="#d3_random">随机数API</a></li>
			<li><a href="#d3_behavior">行为API</a></li>
			<li><a href="#d3_color">颜色API</a></li>
			<li><a href="#d3_more">更多</a></li>
		</ul>
		<a href="#es2015">ES6新特性</a>
		<a href="#groccery">杂项</a>
		<ul>
			<li><a href="#markdown">Markdown</a></li>
			<li><a href="#jsonp">JSONP & CORS</a></li>
			<li><a href="#dependency_infection_intro">依赖注入</a></li>
			<li><a href="#candy">语法糖</a></li>
			<li><a href="#function_language">函数式编程</a></li>
			<li><a href="#iife">IIFE</a></li>
			<li><a href="#stream">Nodejs中的Stream</a></li>
			<li><a href="#crypto">Crypto</a></li>
		</ul>
		<p>&copy; shenlvmeng</p>
	</aside>
	<div class="container">
		<h3 id="introduction">前言</h3>
		<p>此文源于6月初的一个知乎问题“<a href="http://www.zhihu.com/question/29875948" target="_blank">为什么市场上优秀的前端这么少，国外也是这样吗?</a>”，简单阅览了答案后才发现，有那么多的web技术自己还闻所未闻。于是开始从javascript(js)开始，广度优先地学习起一些新技术（当然有些列举的已经不算新了）。在学习的过程中，也发现了作为一名前端工程师的不易：</p>
		<ul>
			<li>科技树太广，需要广泛的知识面</li>
			<li>随着js的发展，前端技术已渗透到各个方面，做前端≈做全栈</li>
			<li>新技术出现太快，需要保持open mind</li>
		</ul>
		<p>这里整理了对一些技术的学习笔记，几乎都是与js相关的技术，按照分类列举在下面（有些未做学习）:</p>
		<ul>
			<li><strong>框架</strong>：AngularJS, EmbedJS, ReactJS, ExpressJS, Backbone.JS</li>
			<li><strong>环境</strong>：NodeJS</li>
			<li><strong>包管理</strong>：Bower, npm</li>
			<li><strong>包构建</strong>：Browserify, Webpack</li>
			<li><strong>任务自动化</strong>：Grunt, Gulp</li>
			<li><strong>模块化规范</strong>：RequireJS, CommonJS, AMD, CMD</li>
			<li><strong>DOM操作</strong>：jQuery, Zepto</li>
			<li><strong>数据库</strong>：MongoDB</li>
			<li><strong>可视化</strong>：D3</li>
			<li><strong>测试工具</strong>：Protractor, Selenium, PhantomJS, mocha</li>
			<li><strong>其他</strong>：Jade, Markdown, Socket.io等</li>
		</ul>
		<p>关于本文，还有一些想说的。首先，前端技术发展很快，文中提到的用法等内容是有一定时效性的，请谨慎；其次，写本文的时候是奔着信息充分，便于日后检索去的，所以当作工具书更为适合；最后，水平有限，纰漏还望指正。</p>
		<hr>
		<h1 id="nodejs">NodeJS</h2>
		<h3 id="node_what_why">What and Why</h3>
		<p>NodeJS是以下介绍的许多技术的出发点和基础。它让JS从前端技术走到后台开发。对于独立运行的JS来说，NodeJS就是一个解析器，就像PHP。但是和PHP不同的是，NodeJS在实现应用的同时，还实现了整个HTTP服务器，不像PHP需要Apache等的帮助。</p>
		<p>NodeJS具有很好的事件机制和异步IO模型。类似于浏览器，NodeJS提供了内置对象给用户操作。</p>
		<h3 id="node_install">安装</h3>
		<p>Windows下和Mac OS X系统下，分别去<a href="http://nodejs.org" target="_blank">nodejs.org</a>下载.msi和.pkg后缀的安装文件。Linux下需要下载.tar.gz包编译安装。</p>
		<p>Windows环境下安装后可以在命令行中使用<code>node –v</code>, <code>npm –v</code>查看是否成功。另外终端下直接输入node命令可进入命令交互模式.</p>
		<h3 id="node_modules">模块</h3>
		<p>运行简单的web应用程序时，可以直接通过命令或是<code>node example.js</code>的形式启动。在程序稍大时，通常会将代码模块化。文件即模块，通过<code>require</code>、<code>exports</code>、<code>module</code>命令导入、导出、声明模块。范例：</p>
		<pre><code>var foo = require("./foo");
exports.hello = function(){
    console.log("Hello World!");
}
module.exports = function(){
    console.log("Hello World!");
}		</code></pre>
		<p><code>require</code>函数用于在当前模块中加载和使用别的模块，返回一个模块导出对象。模块名可以以相对或是绝对路径。模块后缀名可省略。<code>exports</code>对象用于导出模块共有方法和属性，导出的内容由别的模块使用<code>require</code>获取。<code>module</code>对象可以访问当前模块的一些相关信息，包括导出对象。</p>
		<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。通过命令行传递给NodeJS启动的模块称为主模块。</p>
		<p>最后，NodeJS支持使用C/C++编写二进制模块，使用方法和JS模块相同，它可以使用操作系统提供的所有功能，潜能很大，但是难以跨平台。这里从略。</p>
		<h3 id="node_require">代码组织</h3>
		<p><code>require</code>函数支持绝对、相对路径，可以通过<span class="i">node_modules</span>目录，<span class="i">NODE_PATH</span>定制。</p>
		<p>当模块较复杂时，可以使用包结构将多个子模块。将这些子模块放在同一目录下，使用<code>index.js</code>作为入口模块。这样路径只需写到文件夹即可。范例：</p>
		<pre><code>var head = require('./head');
var body = require('./body');

exports.create = function (name) {
    return {
        name: name,
        head: head.create(),
        body: body.create()
    };
};		</code></pre>
		<p>另外，使用<code>package.json</code>可以自定义入口模块的文件名和存放位置。使用name,main即可</p>
		<p>标准的工程目录应该包括<span class="i">bin/</span>, <span class="i">doc/</span>, <span class="i">lib/</span>, <span class="i">node_modules/</span>, <span class="i">tests/</span>, <span class="i">package.json</span>, <span class="i">README.md</span>等部分，分别存放命令相关代码、文档、API相关代码、第三方包、测试用例、元数据文件、说明文件。nodeJS有许多内置的模块可供使用，下面分几个部分分别介绍之。</p>
		<h3 id="node_file">文件操作</h3>
		<p>NodeJS作为后台解析环境，可以完成很多文件操作。使用NodeJS内置的<code>fs</code>模块的API可以完成如拷贝等功能。拷贝小文件时，使用<code>writeFileSync</code>, <code>readFileSync</code>即可完成，大文件拷贝时，使用<code>createReadStream</code>, <code>pipe</code>, <code>createWriteStream</code>可以完成。</p>
		<p>同时NodeJS还提供了<code>Buffer</code>，<code>Stream</code>，<code>Path</code>用于完成更完善的文件操作功能。</p>
		<p><a href="https://nodejs.org/api/buffer.html" target="_blank"><code>Buffer</code></a>对象是与<code>String</code>对等的二进制数据类型，可以用<code>to_string</code>和<code>string</code>相互转换。不同的是，<code>buffer</code>对象是可写的，这点和C很像。因此，<code>buffer</code>更像是指针操作的C语言数组，如使用<code>slice</code>命令更像是将指针赋予了新值，对新值做的修改对原值有直接影响。因此，拷贝<code>buffer</code>时，需要先创建一个新的<code>buffer</code>才能复制新数据。</p>
		<p><a href="https://nodejs.org/api/stream.html" target="_blank"><code>Stream</code></a>对象在内存无法一次装下大文件的数据时，或需要一边读取一边处理时提供对数据流的操作，例如可用<code>createReadStream</code>创建一个只读数据流<code>rs</code>，<code>rs</code>有<span class="i">on, pause, resume, end</span>等功能。<code>Stream</code>对象都是事件驱动的，上文提到的rs即可监听<span class="i">data, end, drain</span>等事件。<code>pipe</code>方法提供了防爆仓控制，用于大文件拷贝。</p>
		<p><a href="https://nodejs.org/api/fs.html" target="_blank"><code>fs</code></a>模块提供了许多有用的API，包括文件属性读写，文件内容读写，底层文件操作。这些API大多为异步，不过都有同步版本，并在函数名后添加Sync。</p>
		<p><a href="http://nodejs.org/api/path.html" target="_blank"><code>Path</code></a>模块用于文件路径的操作。<code>Normalize</code>方法将传入的路径转换为标准路径，<code>join</code>方法将传入的多个路径拼接成标准路径。</p>
		<p>下面是一个遍历目录的同步例子，用到了以上介绍的内容：</p>
		<pre><code>function travel(dir, callback) {
    fs.readdirSync(dir).forEach(function (file) {
        var pathname = path.join(dir, file);

        if (fs.statSync(pathname).isDirectory()) {
            travel(pathname, callback);
        } else {
            callback(pathname);
        }
    });
}		</code></pre>
		<p>除了以上介绍的文件操作外，一些其他需求也经常出现，如去文件BOM头，GBK转换UTF-8编码，单字节编码。</p>
		<p>NodeJS提供的这些文件操作功能对于变现前端工具是很有帮助的。</p>
		<h3 id="node_network">网络操作</h3>
		<p>由于NodeJS的用途是实现高性能的Web服务器，给独立运行的JS提供解释环境，它所提供的网络操作可以完成相对底层的网络操作，如Socket和HTTP协议相关。NodeJS提供了<code>http, https, url, querystring, zlib, net</code>等库帮助开发者实现网络编程。</p>
		<p><a href="https://nodejs.org/api/http.html" target="_blank"><code>http</code></a>模块提供了两种使用方式: 作为服务端使用和作为客户端使用。如测试第1例中所写，<code>createServer</code>方法创建一个服务器（这也是最常用的一种用法），然后抵用listen方法监听端口。客户端每请求一次，创建时输入的回调函数就调用一次。函数中的<code>request</code>和<code>response</code>实际上也是数据流的格式，所以可以用文件操作函数来读取，如<code>request.on</code>, <code>request.write</code>等方法.</p>
		<p>在作为客户端使用时，有<code>get</code>, <code>post</code>等方法，同样地，可以使用<code>response</code>对象访问响应头数据，还能把<code>response</code>对象当作一个只读数据流访问响应体数据。用法范例如下：</p>
		<pre><code>http.get('http://www.example.com/', function (response) {
    var body = [];

    console.log(response.statusCode);
    console.log(response.headers);

    response.on('data', function (chunk) {
        body.push(chunk);
    });

    response.on('end', function () {
        body = Buffer.concat(body);
        console.log(body.toString());
    });
});		</code></pre>
		<p><a href="https://nodejs.org/api/https.html" target="_blank"><code>https</code></a>模块和<code>http</code>模块很类似，区别在于<code>https</code>模块需要额外的SSL证书处理，在<code>createServer</code>时，将公钥和私钥放在<code>option</code>里作为输入参数。同时<code>https</code>的<code>addContext</code>方法还可以使用多个域名提供服务。在客户端模式下，<code>https</code>模块默认拒绝连接未从颁发机构购买SSL证书的服务器。在<code>options</code>中添加<code>rejectUnauthorized: false</code>即可在开发条件下允许自制证书。</p>
		<p><a href="https://nodejs.org/api/url.html" target="_blank"><code>url</code></a>模块允许生成、解析、拼接url。url分为<span class="i">protocol, auth, hostname, port, pathname, search(query) hash/host, path, href</span>等部分。<code>parse</code>方法可以将url解析成以上部分，且不要求url完整。<code>parse</code>的第二和第三个参数分别可以将query部分转换成对象和解析不带协议头的URL。相反地，<code>format</code>方法允许将URL对象转换为URL字符串。<code>resolve</code>方法支持URL的拼接。</p>
		<p><a href="https://nodejs.org/api/querystring.html" target="_blank"><code>querystring</code></a>实现了query字符串和参数对象之间的转换，类似于PHP的<code>$_GET，$_POST</code>。同样适用<code>parse</code>方法和<code>stringify</code>方法完成两个方向的转换。</p>
		<p><a href="https://nodejs.org/api/zlib.html" target="_blank"><code>zlib</code></a>函数支持压缩和解压到功能，在对HTTP响应体数据压缩时，可能需要用到这个模块。下面的范例是官网文档使用的判断用户端是否支持gzip，并在支持时返回gzip之后的响应体数据：</p>
		<pre><code>http.createServer(function (request, response) {
    var i = 1024,
        data = '';

    while (i--) {
        data += '.';
    }

    if ((request.headers['accept-encoding'] || '').indexOf('gzip') !== -1) {
        zlib.gzip(data, function (err, data) {
            response.writeHead(200, {
                'Content-Type': 'text/plain',
                'Content-Encoding': 'gzip'
            });
            response.end(data);
        });
    } else {
        response.writeHead(200, {
            'Content-Type': 'text/plain'
        });
        response.end(data);
    }
}).listen(80);</code></pre>
		<p>同理，<code>zlib</code>可以使用<code>gunzip</code>解压缩文件。</p>
		<p><a href="https://nodejs.org/api/net.html" target="_blank"><code>net</code></a>模块可以创建底层的socket服务器或是客户端，但是在前端领域使用范围并不广。它可以在socket层面实现HTTP请求和响应。需要有网络编程的底层认识和HTTP协议的熟悉。</p>
		<p>最后还需要注意的几点是，<code>http</code>模块创建的服务器返回响应时默认使用<code>chunked</code>传输模式，因为<code>writeHead</code>方法后的响应体数据长度未知，设置<code>header</code>中的<code>Content-Length</code>字段后，NodeJS就不会自动添加<code>Transfer-Encoding</code>字段。<code>http</code>模块提供一个全局客户端<code>http.globalAgent</code>，允许直接使用<code>request</code>方法和<code>get</code>方法，但是最多只允许5个并发连接，通过<code>http.globalAgent.maxSockets</code>可以修改这个值。</p>
		<h3 id="node_thread">进程管理</h3>
		<p>NodeJS可以可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。与之相关的API有<code>process, child_process, cluster</code>等等。</p>
		<p>其中<code>process</code>对象可以感知和控制NodeJS自身进程的方方面面，它是一个全局对象，可以在任何地方使用。通过<code>process</code>可以感知nodeJS进程的各种状态，如<code>process.argv</code>获取命令行参数。它也继承<code>eventEmitter</code>。有<code>exit</code>等事件可以监听，同时有<code>exit, stdin, stdout, env</code>等对程序的精细控制。</p>
		<p><a href="https://nodejs.org/api/child_process.html" target="_blank"><code>child_process</code></a>可以创建和控制子进程，利用<code>spawn, fork</code>方法创建新的进程，使用<code>exec, execFile</code>方法执行命令、文件。<code>Spawn</code>方法还被其他API做进一步的封装，以适应不同场景。<code>cluster</code>模块是对<code>child_process</code>的进一步封装，用于解决单进程NodeJS Web服务器不能充分利用多核CPU的问题。</p>
		<p>这里以进程降权和子进程间通过信号通讯为例，熟悉简单API的一些使用：</p>
		<pre><code>http.createServer(callback).listen(80, function () {
    var env = process.env,
        uid = parseInt(env['SUDO_UID'] || process.getuid(), 10),
        gid = parseInt(env['SUDO_GID'] || process.getgid(), 10);

    process.setgid(gid);
    process.setuid(uid);
});
/* parent.js */
var child = child_process.spawn('node', [ 'child.js' ]);

child.kill('SIGTERM');

/* child.js */
process.on('SIGTERM', function () {
    cleanUp();
    process.exit(0);
});		</code></pre>
		<p>实际上父子进程都为NodeJS进程时，可以通过IPC通讯双向传递数据，双方通过<code>on</code>和<code>send</code>方法在IPC上双向传递数据。具体范例见官网对<code>child.send()</code>的范例。这种情况下，子进程通常使用<code>process.fork</code>方法创建。</p>
		<h3 id="node_features">特点</h3>
		<p>正如<a href="#node_what_why">What and Why</a>中所说，NodeJS最大的特点就是事件机制和异步调用。JS是单线程运行的，但是setTimeout，setInterval这样的函数可以通过创建平行进程的形式实现异步的效果。因此实际运行时，JS主进程会顺序向下执行除回调函数以外的代码，这也意味着，回调函数的执行在JS主线程后。例子见<a href="https://nqdeng.github.io/7-days-nodejs/#4.2.2" target="_blank">参考</a>。</p>
		<p>因此，虽然NodeJS提供了很多异步函数的同步版本，但是为了利用它的优势，熟悉回调和异步的编码思路还是很必要的。如，在同步中以返回值的形式嵌套调用，异步里采用回调函数套回调函数。在遍历等步骤时要更为复杂。</p>
		<p>异常处理也是如此，由于异步调用的形式会打断错误冒泡的路径，使之不会被try语句catch住，因此NodeJS提供的try catch语句只能在同步形式下使用。异步API通常采用向回调函数中传入<code>err</code>参数实现。从以上可以看到，NodeJS最大的特点会增大代码的复杂度，尤其在有异常处理的情况下。对此，NodeJS提供了一些解决方法。</p>
		<p><a href="https://nodejs.org/api/domain.html" target="_blank"><code>domain</code></a>模块可以简化异步代码的异常处理。对于全局异常，可以直接通过<code>process</code>的<code>uncaughtException</code>事件捕获。对于普通异常，我们为每个请求创建一个子域，子域内运行的代码可以随意抛出异常，这些异常可以通过子域对象统一捕获，会使得代码简介很多。范例如下：</p>
		<pre><code>function async(request, callback) {
    // Do something.
    asyncA(request, function (data) {
        // Do something
        asyncB(request, function (data) {
            // Do something
            asyncC(request, function (data) {
                // Do something
                callback(data);
            });
        });
    });
}

http.createServer(function (request, response) {
    var d = domain.create();

    d.on('error', function () {
        response.writeHead(500);
        response.end();
    });

    d.run(function () {
        async(request, function (data) {
            response.writeHead(200);
            response.end(data);
        });
    });
});		</code></pre>
		<p>根据NodeJS官方文档的说法，无论怎么捕获到异常，都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。这是由于NodeJS的部分API内部是用C/C++实现的，代码在执行过程中穿梭在JS引擎内部和外部，因此JS的异常抛出机制可能会打断正常的代码执行，导致C/C++部分代码表现异常。而使用JS语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上述问题。</p>
		<h3 id="node_examples">使用示例</h3>
		<p>这一部分主要展示了一个完整的应用实例。</p>
		<p>1. 为了展示NodeJS的最基本的使用和简单的调试方式。我们创建一个用于启动应用的主文件，起名为<code>server.js</code>，写入如下代码。</p>
		<pre><code>var http = require("http");

http.createServer(function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello, World!");
    response.end();
}).listen(8888);</code></pre>
		<p>将文件放在NodeJS目录下（其他目录亦可），接着用NodeJS执行这段脚本。打开浏览器访问<a href="http://localhost:8888" target="_blank">http://localhost:8888</a>，可看到此网页。对比PHP还是看出很大不同的。</p>
		<p>回调函数很好地反映了使用JS做服务器的特点：事件驱动、异步。在请求到达后交给<code>onRequest()</code>函数处理，函数接受两个参数<code>request</code>和<code>response</code>。</p>
		<p>2. 上文的<code>server.js</code>是启动服务器基本代码，需要交给主文件<code>index.js</code>使用。因此，采用模块一节介绍的方法，使用<code>exports</code>对象。新建<code>index.js</code>，使用<code>require</code>导入。</p>
		<pre><code>var http = require("http");

function start(){
    http.createServer(function(request, response){
        console.log("Request Received");
        response.writeHead(200, {"Content-Type": "text/plain"});
        response.write("Hello, World!");
        response.end();
    }).listen(8888);
    console.log("Server has started.");
}

exports.start = start;

var server = require("./server");
server.start();</code></pre>
		<p>这次同样使用<code>node index.js</code>启动脚本，可以实现同样的效果。</p>
		<p>3. 路由也是一个Web应用开发的关键一块。利用<code>url</code>模块可以完成这一功能。同时在<code>server.js</code>中，将<code>route</code>作为参数传入<code>start</code>函数中。在<code>index.js</code>中，导入<code>router</code>模块。<code>router.js</code>代码如下。</p>
		<pre><code>function route(handler, pathname){
    console.log("Handle a request to " + pathname);
    if(typeof(handler[pathname]) === "function")
        handler[pathname]();
    else
        console.log("Handler for "+ pathname+ " not found.");
}

exports.route = route;</code></pre>
		<p>4. 在start路径下允许用户输入数据，并在upload目录下获得POST数据，需要用到<code>stream</code>和<code>querystring</code>的内容。<span class="i">Server.js</span>和<span class="i">requestHandler.js</span>关键部分定义如下：</p>
		<pre><code>function start(router, handler){
    http.createServer(function(request, response){
	var pathname = url.parse(request.url).pathname;
	var postData = "";
	console.log("Request for "+pathname+" received");

	request.setEncoding("utf-8");
	request.on("data", function(chunk){
		postData += chunk;
		console.log("Receive POST data chunk "+chunk+".");
	});

	request.on("end", function(){
		router(handler,pathname,response,postData);
	});
		
    }).listen(8888);
    console.log("Server has started.");
}
var querystring = require("querystring")

/* requestHandler.js */
function start(response, data){
    console.log('Handler \'start\' was called.');
    var body = '&lt;html>'+
        '&lt;head>'+
        '&lt;meta http-equiv="Content-Type" content="text/html; '+
        'charset=UTF-8" />'+
        '&lt;/head>'+
        '&lt;body>'+
        '&lt;form action="/upload" method="post">'+
        '&lt;textarea name="text" rows="20" cols="60">'+
        '&lt;textarea>'+
        '&lt;input type="submit" value="Submit text" />'+
        '&lt;/form>'+
        '&lt;/body>'+
        '&lt;/html>';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, data){
    console.log('Handler \'upload\' was called.');
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("You have sent "+ querystring.parse(data).text);
    response.end();
}
</code></pre>
		<p>5. 利用NodeJS的异步特点和子进程模块，可以将<code>start</code>和<code>upload</code>函数中的耗时操作设为异步进行，将异步运行的结果交给回调函数处理。在<span class="i">requestHandler.js</span>中添加<code>exec</code>语句即可。同时，允许用户上传文件，并将图片在浏览器中显示出来。可以用第三方插件完成大部分功能。这里从略。可以见更多中的Node入门。</p>
		<h3 id="node_more">更多</h3>
		<p><a href="https://nqdeng.github.io/7-days-nodejs/" target="_blank">七天学会NodeJS</a>，<a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank">Node入门</a></p>
		<hr>
		<h1 id="npm">npm</h1>
		<h3 id="npm_introduction">简介</h3>
		<p>npm是NodeJS随同安装的包管理工具。由于NodeJS使用模块组织工程的特点，npm能解决NodeJS部署上的很多问题。它允许用户从npm服务器下载别人编写的三方包到本地使用、允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用、允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</p>
		<p>同时，NPM还是NodeJS的开放式模块登记和管理系统。它构建了一个NodeJS模块平台，发挥了类似github的功能。</p>
		<h3 id="npm_install">安装</h3>
		<p>npm一般随NodeJS一起安装。安装后，可以通过<code>npm intall npm@latest –g</code>进行更新。<code>npm help</code>和<code>npm –l</code>可以查看npm的帮助信息。</p>
		<h3 id="npm_commands">常用命令</h3>
		<p><code><strong>npm init</strong></code>: 在项目文件根目录下，需要有<span class="i">package.json</span>来完成模块的开发说明。该命令可以初始化新的<span class="i">package.json</span>文件，通过询问的方式完成。使用参数<code>-f</code>和<code>-y</code>可以跳过询问。</p>
		<p><code><strong>npm set</strong></code>: 用来设置npm的环境变量，类似于<code>git config –global</code>。有<code>init-author-name</code> <code>init-author-email</code> <code>init-author-urllicense</code>等选项可供选择。针对某个项目有特殊设置时，可以另行<code>npm config</code>。</p>
		<p><code><strong>npm info</strong></code>: 查看模块具体信息。类似于查看<span class="i">package.json</span>。还可以查看字段信息。如，<code>npm info {{module_name}} description</code>。</p>
		<p><code><strong>npm search</strong></code>: 按照模块名搜索具体模块。npm的包名必须唯一。</p>
		<p><code><strong>npm list</strong></code>: 树形结构列出当前项目安装的模块和其依赖模块。可以跟<code>-global</code></p>
		<p><code><strong>npm install</strong></code>: 最常用的一个命令。安装可以选择本地（当前文件夹的<span class="i">node_modules</span>下）或全局。全局安装只适用于工具模块。该命令甚至支持通过github代码库地址安装。参数<code>-f</code>可以强制重新安装一个模块。删除<span class="i">node_modules</span>目录，执行该命令可以强制安装所有模块。</p>
		<p>在模块后，可以用<code>@</code>后接版本号安装特定版本，<code>latest</code>表示最新版，<code>beta</code>表示测试版。后接<code>--save</code>会添加<code>dependencies</code>到<span class="i">package.json</span>中。<code>--save-exact</code>可以添加确切版本。<code>--save-dev</code>添加到<code>devDependencies</code>中。可以简化为<code>-S</code>或<code>-D</code>。<code>--production</code>会安装<code>dependencies</code>中的依赖而不考虑<code>devDependencies。</code></p>
		<p><code><strong>npm update</strong></code>: 升级已安装的本地或者全局模块。<code>--depth</code>可以指定迭代的深度，升级依赖的依赖。</p>
		<p><code><strong>npm uninstall</strong></code>: 卸载已安装模块。</p>
		<p><code><strong>bpm run</strong></code>: 执行<span class="i">package.json</span>中的<code>scripts</code>字段对应的脚本。其中<code>npm run test</code>和<code>npm run start</code>可以简写成<code>npm test</code>和<code>npm start</code>。可以将脚本存成文件，在<code>scripts</code>字段中写上文件路径。同时，<code>npm run</code>执行的命令可以跟命令行参数。（实际上，<a href="http://gruntjs.com/" target="_blank">grunt</a>和<a href="http://gulpjs.com/" target="_blank">gulp</a>这样的工具就是完成此类工作）</p>
		<p><code>npm run</code>的每个命令都有两个钩子pre和post。在执行命令command之前，npm会检查是否有precommand，执行之后会检查是否有postcommand。同时<code>npm run</code>可以使用一些内部变量，如<span class="i">package.json</span>中的<code>name</code>字段可以用<code>$npm_package_name</code>代表。<code>config</code>字段里可以设置内部字段。</p>
		<p><code><strong>npm link</strong></code>: 将开发中的模块链接中本地的<span class="i">node_modules</span>中，方便边开发边使用。<code>npm unlink</code>可以删除符号链接。</p>
		<p><code><strong>npm bin</strong></code>: 执行本地<span class="i">node_modules/.bin</span>目录下的命令。</p>
		<p><code><strong>npm adduser</strong></code>: 在npmjs.com中添加一个用户。</p>
		<p><code><strong>npm publish</strong></code>: 发布模块，在拥有npm账户后。使用<code>npm login</code>登录，接着在本地目录下输入命令即可发布模块。<code>--tag</code>可以为发布模块添加标记</p>
		<p><code><strong>npm deprecate</strong></code>:  废弃某个版本或某个版本范围的模块，后面可以跟警告文本。如<code>npm deprecate mymodule@"&lt;0.2" "fix critical bugs"</code></p>
		<p><code><strong>npm owner</strong></code>: 管理模块的维护者。有<code>ls, add, rm</code>命令可以选择。</p>
		<p>其他的命令还有<code>npm install . –g</code>可用于发布包前的本地测试；<code>npm update cache clear</code>可以清空缓存；<code>npm unpublish {{package}}@{{version}}</code>可以撤销自己发布过的某个版本代码等。更多详细介绍见<a href="https://docs.npmjs.com/cli/" target="_blank">官网文档</a></p>
		<h3 id="npm_download">下载第三方包</h3>
		<p>使用命令<code>npm install {{module_name}}</code>，将包下载到node_modules后，直接使用<code>require({{module_name}})</code>即可加载第三方模块。同时，修改<span class="i">package.json</span>，添加<code>dependencies</code>项，即可批量加载第三方包，这样做的好处在他人加载你的模块时是非常明显的。用户只需关心自己直接使用的第三方包，而不需要自己解决依赖问题。</p>
		<h3 id="npm_install_cmd">安装命令行程序</h3>
		<p>方法和上面类似，如<code>npm install pug –g</code>(<code>-g</code>表示全局安装)，全局安装时，pug默认会安装到<span class="i"><strong>/usr/local(for Linux)</strong></span>或 <span class="i"><strong>%APPDATA%\npm(for Windows)</strong></span>下。npm会自动创建Linux下的软链和Windows下的<code>.cmd</code>文件。</p>
		<h3 id="npm_release">发布自己的包</h3>
		<p>需要在npm注册自己的账号，之后运行<code>npm adduser</code>。账号配置完成后，编辑<span class="i">package.json</span>文件，包括<span class="i">name, version, dependencies, main, bin, man</span>等内容，之后就可以在<span class="i">package.json</span>目录下运行<code>npm publish</code>发布代码了。<span class="i">package.json</span>下字段的更多解释参见<a href="https://docs.npmjs.com/files/package.json" target="_blank">官网文档。下面是一个<span class="i">package.json</span>的样例</a></p>
		<pre><code>{
    "name": "my_package",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "keywords": [],
    "author": "ag_dubs",
    "license": "ISC",
    "repository": {
        "type": "git",
        "url": "https://github.com/ashleygwilliams/my_package.git"
    },
    "bugs": {
        "url": "https://github.com/ashleygwilliams/my_package/issues"
    },
    "homepage": "https://github.com/ashleygwilliams/my_package"
}</code></pre>
		<h3 id="npm_version">版本号控制</h3>
		<p>npm使用语义版本号进行版本号控制。分<code>X.Y.Z</code>三位，分别代表主版本号，副版本号，补丁版本号。其中主版本号对下不兼容，有大变动，次版本号只是新增功能向下兼容，补丁版本号只是修复bug。</p>
		<p>在这个保证下，<code>dependencies</code>可以指定一定范围的版本码。包括>, >=, <, <=, ~, 0.0.x, *, -等等。</p>
		<h3 id="npm_sum_up">小结</h3>
		<p>npm是NodeJS自带的包管理工具。在复杂的工程背景下，通常需要使用许多的第三方包，在第三方框架下搭出可靠好用的应用。尤其在新技术层出不穷的web应用中，包管理成了很重要的一个环节。对于使用模块构建工程的NodeJS，NPM这样的包管理工具将更有利于它的发展和开发者的使用。</p>
		<h3 id="npm_more">更多</h3>
		<p><a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank">npm模块管理器</a></p>
		<hr>
		<h1 id="bower">Bower</h1>
		<h3 id="bower_introduction">简介</h3>
		<p><a href="https://bower.io/" target="_blank">Bower</a>由<a href="https://twitter.com/" target="_blank">twitter</a>推出，是一个和<a href="https://www.npmjs.com/" target="_blank">npm</a>功能十分类似的包依赖管理软件。不同的是，npm管理整个工程项目的包依赖，而Bower专注于前端各网络资源的管理。它可以帮助快速搭建起前端以来环境，并管理各组件的版本状态。</p>
		<p>和npm类似，Bower使用<span class="i">bower.json</span>作为项目配置文件中。使用<code>bower install</code>命令时，后面可以跟包名、github路径、git仓库路径、url或者干脆不要参数。Bower本身的配置文件为项目根目录下的<span class="i">.bowerrc</span>，通过<code>directory, json, endpoint, searchpoint, shorthand_resolver</code>指定了存放库文件的目录、描述库的json文件名，搜索库文件的路径，备选路径，库名称简写形式。下面是一个<span class="i">bower.json</span>的样例: </p>
		<pre><code>{
    "name": "app-name",
    "version": "0.0.1",
    "dependencies": {
        "sass-bootstrap": "~3.0.0",
        "modernizr": "~2.6.2",
        "jquery": "~1.10.2"
    },
    "private": true
}		</code></pre>
		<h3 id="bower_usage">使用</h3>
		<p>通过<code>npm intall bower –g</code>全局安装bower，以便可以使用bower命令。通过<code>bower help</code>可以查看所有的bower命令。bower命令和npm命令是很类似的。有<code>init, install, cache, search, list, info, uninstall</code>等命令。Bower在下载依赖包时，会保存一份到缓存中，通过<code>bower cache list</code>查看。</p>
		<h3 id="bower_question">Bower or npm?</h3>
		<p>由于前后端资源特点的不同，npm基于CommonJS的规范开发，是利于后端模块的依赖管理的，通过<span class="i">package.json</span>管理树形的依赖结构，模块间用require、export沟通。而这在带宽紧张的前端是不完全适合的，前端更需要扁平和松散的依赖关系，减少文件的传输次数。因此，使用简单的Bower在推出后，收到了很大欢迎。但是Bower的缺陷也很明显，bower管理松散、缺乏统一的构建机制。包的格式并没有限制，只通过<span class="i">bower.json</span>沟通。同时，bower缺少npm那样的registry，而直接取用github。</p>
		<p>在Browserify, Webpack这样的工具出现后，使用npm管理前端时，不会出现CommonJS的规范下加上其他规范模块的不伦不类感。未来前后端包依赖统一管理的趋势是必然的，在node良好的生态环境下，使用npm统一管理似乎是更受欢迎的。</p>
		<p>更多的讨论间<a href="https://www.zhihu.com/question/24414899" target="_blank">知乎话题</a>。</p>
		<hr>
		<h1 id="browserify">Browserify</h1>
		<h3 id="brow_intro_usage">简介与使用</h3>
		<p>如在Bower中提到的，浏览器端的文件并没有CommonJS这样的构建规范。因此，在使用npm管理时显得不伦不类。Browserify是node的一个插件，允许使用<code>require</code>的句法书写浏览器端的文件。通过<code>browserify</code>命令将入口文件打包输出，即可建立一个统一的依赖环境，且可以在html中只使用一条script或link等引入。</p>
		<p>假设我们项目需要<a href="http://backbonejs.org/" target="_blank">backbone.js</a>和<a href="https://jquery.com/" target="_blank">jQuery</a>两个模块。首先，通过<code>npm install –g browserify</code>全局安装它。之后新建<span class="i">main.js</span>文件，将服务器端backbone模块转为客户端（即浏览器端）模块。先安装backbone和jquery模块，在main.js中写下如下内容：</p>
		<pre><code>// main.js
var Backbone = require('backbone');
var $ = Backbone.$ = require('jquery/dist/jquery')(window);

var AppView = Backbone.View.extend({
  render: function(){
    $('main').append('&lt;h1>Browserify is a great tool.&lt;/h1>');
  }
});
var appView = new AppView();
appView.render();
</code></pre>
		<p>之后使用browserify将main.js转为app.js:<code>browserify main.js –o app.js</code>。就可以通过<pre><code>&lt;script src=app.js>&lt;/script></code></pre>完成插入。</p>
		<h3 id="brow_manage_generate">管理与生成</h3>
		<p>使用browserify可以将CommonJS转为浏览器可以调用的格式(如上文)，同时，它也可以对纯粹的前端模块打包，然后再html中通过一行命令完成调用。使用<code>browserify-shim</code>支持jQuery等的CDN加载。使用<code>parcelify</code>模块可以对插件自带的css文件进行打包。</p>
		<p>Browserify指定<code>-r</code>参数，还可以在打包模块的同时，为浏览器提供require方法。Browserify还支持实时生成脚本文件，通过browserify的bundle方法写在js文件里。</p>
		<p>更多内容请参考<a href="http://javascript.ruanyifeng.com/tool/browserify.html" target="_blank">阮一峰的Javascript参考教程。</a></p>
		<hr>
		<h1 id="webpack">Webpack</h1>
		<p>类似于Browserify，Webpack也是前端资源管理和打包工具，不过适用范围更广。它可以将松散的有依赖关系的前端资源打包成单一文件，根据loader的不同，它可以将CommonJS, AMD, ES6, CSS, 图片, JSON等视作模块。</p>
		<h3 id="webpack_why">Why</h3>
		<p>现有的模块管理和打包工具(包括commonJS，CMD等)不能很好地对模块进行无缝整合生成适合浏览器端请求的的静态资源。在以下方面发挥不良：<ul>
			<li>拆分依赖树为按需加载的模块</li>
			<li>减少初始化加载时间</li>
			<li>将各种静态资源视为模块</li>
			<li>自定义打包逻辑</li>
		</ul>
		从而，webpack有着以下特点：<ul>
			<li>webpack支持同步和异步两种组织模块依赖的方法</li>
			<li>webpack只能处理原生js模块，但是loader转换器可以将其他资源转换成js模块</li>
			<li>webpack几乎可以处理所有第三方库，甚至运行使用动态表达式加载依赖</li>
			<li>webpack有丰富的插件和高速的运行效率</li>
		</ul>
		</p>
		<h3 id="webpack_usage">安装使用</h3>
		<p>通过npm全局安装<code>npm install webpack –g</code>或安装到项目依赖<code>npm install webpack –save-dev</code>。在全局安装下，我们可以通过webpack命令打包文件。根据官方样例，若有<span class="i">module.js</span>和<span class="i">entry.js</span>如下：</p>
		<pre><code>// module.js
module.exports = 'It works from module.js.'
// entry.js
document.write('It works.')
document.write(require('./module.js')) // add module
</code></pre>
		<p>通过<code>webpack entry.js bundle.js</code>命令将文件打包，并在html文件中引入。在页面启动后，会先启动<span class="i">entry.js</span>中的代码，其他的模块会在运行到require时再执行。</p>
		<p>借助<span class="i">loader</span>，webpack可以处理非javascript资源，从而通过require命令引入其他类型的模块或文件。<span class="i">loader</span>本身是一个函数，它以管道的方式调用，将资源转换格式再传递给下一个<span class="i">loader</span>，但是最后一个<span class="i">loader</span>必须返回js。<span class="i">loader</span>可以接受参数，且作为模块运行在nodejs环境中。因此我们可以通过npm来管理<span class="i">loader</span>或在项目中自己写<span class="i">loader</span>模块。</p>
		<p>如导入css文件时，指定<code>css-loader</code>来读取它，再用<code>style-loader</code>将它插入到页面中，通过命令<code>require("!style!css!./style.css")</code>即可，或在webpack命令后使用参数<code>--module-bind css=style!css</code>。</p>
		<h3 id="webpack_config">配置文件</h3>
		<p>Webpack在执行时，除了命令行参数，默认会搜索当前目录下的<span class="i">webpack.config.js</span>文件。这个问价有着类似于<span class="i">package.json</span>的功能。也可以通过<code>—config</code>手动指定配置文件位置。例如，我们可以创建以下配置文件，替代上文的做法：</p>
		<pre><code>var webpack = require('webpack')

module.exports = {
    entry: './entry.js',
    output: {
        path: __dirname,
        filename: 'bundle.js'
    },
    module: {
        loaders: [
            {test: /\.css$/, loader: 'style!css'}
        ]
    }
}		</code></pre>
		<p>此外，借助插件可以完成更多<span class="i">loader</span>之外的功能，在配置文件中指定<code>plugins</code>属性即可。实际上除了上面介绍的，配置选项还有很多（上面介绍的更常用），如<code>watch, debug</code>等等，参见<a href="http://webpack.github.io/docs/configuration.html" target="_blank">官方文档</a>对配置文件的讲解。</p>
		<h3 id="webpack_more">更多</h3>
		<p>在开发环境下，还有<code>webpack-dev-server</code>辅助浏览项目中的页面和资源输出，并可以在浏览器中的<a href="http://localhost:8080/webpack-dev-server/" target="_blank">localhost:8080/webpack-dev-server/</a>位置下查看进度。详情可以查看<a href="https://webpack.github.io/" target="_blank">官网</a>。</p>
		<p>本节内容大多参考官网和<a href="http://zhaoda.net/webpack-handbook/index.html" target="_blank">Webpack中文指南</a>。个人认为这种工具型的技术实操学习起来更快。</p>
		<hr>
		<h1 id="grunt">Grunt</h1>
		<h3 id="grunt_tutorial">入门</h3>
		<p>在JS开发的过程中，经常会遇到一些重复性工作，如压缩代码，检查语法错误，将Sass文件转成CSS文件等。Grunt就是便于我们自动管理和运行任务的自动任务运行器。它会按照预定顺序执行它们，简化重复性工作的负担。</p>
		<p>使用grunt前，需要使用npm命令将<code>grunt-cli</code>全局安装。需要注意的是，<code>grunt-cli</code>是通过组织安排其他grunt组件起到组建作用的。使用grunt时，需要在工程目录下添加<span class="i">package.json</span>和<span class="i">Gruntfile</span>两份文件，它们分别用来便于将项目发布为npm模块和配置和定义任务并加载Grunt插件。通常，最好在<span class="i">package.json</span>中间添加grunt插件的依赖。</p>
		<h3 id="gruntfile">Gruntfile</h3>
		<p><span class="i">Gruntfile</span>由<code>wrapper</code>函数、项目于任务配置、加载grunt插件和任务、自定义任务及部分构成。下面就是一个<span class="i">Gruntfile</span>的文件案例，加载<code>grunt-contrib-uglify</code>压缩资源文件。</p>
		<pre><code>module.exports = function(grunt) {

    // Project configuration.
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        uglify: {
            options: {
                banner: '/*! <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> */\n'
            },
            build: {
                src: 'src/<%= pkg.name %>.js',
                dest: 'build/<%= pkg.name %>.min.js'
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-uglify');

    grunt.registerTask('default', ['uglify']);

};		</code></pre>
		<p><ul>
			<li><code>Wrapper</code>函数：上文中的<code>module.export = function(grunt){}</code>部分。每一个<span class="i">Gruntfile</span>都遵循此格式，所写的grunt代码必须放在此函数的代码块内。</li>
			<li>项目和任务配置：通过<code>grunt.initConfig()</code>将grunt任务所需要的配置对象写在输入参数里面。理论上，这个对象可以存储任意的数据。在上面的案例里，通过<code>grunt.file.readJSON</code>将<span class="i">package.json</span>中的元数据引入到<code>grunt config</code>。并通过制定<span class="i">uglify</span>的属性，配置<span class="i">uglify</span>任务。</li>
			<li>加载grunt插件与任务：通过<code>grunt.loadNpmTasks({{plugin_name}})</code>使用已用npm安装的grunt插件。<code>grunt –help</code>将列出所有可用的任务。</li>
			<li>自定义任务：即上文中的<code>grunt.registerTask()</code>，指定grunt的默认任务，在grunt命令后没有任务时，默认执行<span class="i">uglify</span>任务。实际上，还可以通过<code>grunt.loadTasks</code>加载定义好的外部任务。</li>
		</ul></p>
		<h3 id="grunt_config">任务配置</h3>
		<p>当运行一个任务时，grunt会自动查找配置对象中的同名属性。在同名属性下甚至可以定义不同的target针对不同任务环境，通过grunt {{task_name}}:target的形式访问。在普通环境下grunt会默认执行所有target。同时，在任务配置中，任务的<code>options</code>属性可以覆盖默认值，在不需要的时候可以忽略。</p>
		<p>在文件操作中，grunt通过src-dest的形式定义文件映射，并提供了不同程度的描述和控制。在简洁格式下，通过为target至此那个src和dest属性完成src-dest映射。这种格式支持个每个映射指定额外属性。文件对象格式下，则是用目标文件名做属性名，源文件列表做它的值，这种方式可以指定多个映射，但是不能给每个映射指定附加属性。文件数组格式支持对应多个映射，且允许每个映射拥有额外属性。下面是它们的一些样例。</p>
		<pre><code>grunt.initConfig({
    jshint: {
        foo: {
            src: ['src/aa.js', 'src/aaa.js']
        },
    },
    concat: {
        foo: {
            files: {
                'dest/a.js': ['src/aa.js', 'src/aaa.js'],
                'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'],
            },
        },
        bar: {
            files: [
                {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true},
                {src: ['tmp/**/*'], dest: 'dest/tmp/', filter: 'isFile'},
            ],
        }
    }
});		</code></pre>
		<p>上面concat的<code>bar</code>目标中，使用了<code>filter</code>过滤函数找到<span class="i">tmp</span>目录下的所有文件还可以创建自己的过滤函数。Grunt支持在<code>src</code>中通过通配符指定源文件路径，关于通配符模式的语法，可以参见grunt中文文档。当源文件数目很多，难以一一列出时，可以通过<code>dynamic_mappings</code>动态指定文件映射关系。</p>
		<p>使用<code><% %></code>分隔符指定的模板会从配置文件中读取响应数据来填充。因此，在其中写入grunt命令甚至也是可行的。之前案例里，也是通过<code>grunt.file.readJSON</code>读入外部文件导入配置的。</p>
		<h3 id="grunt_example">配置实例</h3>
		<p>假设我们的某个项目需要<a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank">grunt-contrib-uglify</a>, <a href="https://github.com/gruntjs/grunt-contrib-qunit" target="_blank">grunt-contrib-qunit</a>, <a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank">grunt-contrib-concat</a>, <a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank">grunt-contrib-jshint</a>, <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank">grunt-contrib-watch</a>这5个插件。首先，我们写好<code>wrapper</code>函数和初始化<code>configuration</code>对象。并通过<pre><code>pkg: grunt.file.readJSON(package.json)</code></pre>将<span class="i">package.json</span>中的项目配置信息读进来。接着，我们需要逐一配置上面各插件。</p>
		<p>Concat插件功能是将依赖的所有资源文件打包，通过指定o<code>ptions</code>中的<code>separator</code>属性可以更改默认的合并输出文件间的分隔符，指定<code>dist</code>属性，确定将要合并的文件和合并后文件的存放位置。例如我们可以如下配置，将所有文件合并为与项目名同名的输出文件。</p>
		<pre><code>concat: {
    dist: {
        src: ['src/**/*.js'],
        dest: 'dist/<%= pkg.name %>.js'
    }
}		</code></pre>
		<p>Uglify插件用来压缩JS文件。我们可以指定<code>options</code>中的<code>banner</code>给出压缩文件的注释。可以简单地用文件对象的格式确定输入输出。这里我们将concat插件链接的这些文件压缩成一个<code>.min.js</code>文件。示例如下：</p>
		<pre><code>uglify: {
    options: {
        banner: '/*! <%= pkg.name %> <%= grunt.template.today("dd-mm-yyyy") %> */\n'
    },
    dist: {
        files: {
            'dist/<%= pkg.name %>.min.js': ['<%= concat.dist.dest %>']
        }
    }
}		</code></pre>
		<p>QUnit插件用来进行单元测试，只需为它指定用于测试的文件位置即可。示例如下：</p>
		<pre><code>qunit: {
    file: [‘test/**/*.html’]
}		</code></pre>
		<p>JSHint插件可以检查代码中的潜在错误(即<code>lint</code>)。<code>Files</code>属性里是<code>lint</code>的对象。实例如下：</p>
		<pre><code>jshint: {
    // define the files to lint
    files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
    // configure JSHint (documented at http://www.jshint.com/docs/)
    options: {
            // more options here if you want to override JSHint defaults
        globals: {
            jQuery: true,
            console: true,
            module: true
        }
    }
}		</code></pre>
		<p>Watch插件用于检测指定文件的变化，在它们变化时执行指定的任务。只需指定<code>files</code>属性和<code>tasks</code>属性即可。</p>
		<p>最后的最后，通过<code>grunt.loadNpmTasks()</code>将插件导入，并<code>registerTask</code>注册所需的任务，尤其是<code>default</code>任务（当然也可以注册其他可选任务）。</p>
		<h3 id="grunt_task">任务与插件</h3>
		<p>启动grunt时，默认附带要执行的任务，当不跟参数时，执行<code>default</code>任务。通过<code>registerTask</code>确定任务名和任务列表。如上面的一些例子。</p>
		<p>使用<code>grunt.registerMultiTask()</code>还可以创建多任务，它通过输入的属性名和目标名执行任务，并在未指定目标时执行所有目标。在自定义任务时，可以通过<code>grunt.task.run</code>执行其他任务，还可以访问自身的参数如名称、输入参数做相应处理。通过<code>grunt.task.require()</code>检查依赖任务执行成功与否或配置属性是否存在。</p>
		<p>在grunt 0.4的版本下，<code>grunt-init</code>被拆分成独立的模块，可以通过npm安装。通过grunt插件模板可以创建自己的grunt插件，用类似于npm的形式部署和发布。在发布时，注意命名空间。</p>
		<p><strong>Grunt cli</strong>是grunt的命令行工具。全局安装后，通过<code>grunt –h</code>即可查看grunt的所有命令。</p>
		<h3 id="grunt_more">更多</h3>
		<p><a href="http://www.gruntjs.net/getting-started" target="_blank">Grunt的中文文档</a>介绍得很好，可用作入门。</p>
		<hr>
		<h1 id="gulp">Gulp</h1>
		<h3 id="gulp_tutorial">入门</h3>
		<p>Gulp是个grunt功能类似的自动化构建工具。它利用Node.js的流概念，在管道中传输数据流，从而完成项目构建。同样使用<code>npm install –global</code> glup全局安装gulp组件，或作为项目开发依赖使用<code>--save-dev glup</code>安装。接着在项目的根目录下新建<span class="i">gulpfile.js</span>的文件，写入<code>glup.task(default, function(){})</code>来定义任务，并通过glup命令执行。还可以通过<code>glup &lt;task1> &lt;task2></code>执行系列任务</p>
		<h3 id="gulp_api">常用API</h3>
		<p>为了简化用户的使用难度，gulp的API用法很简洁，数目也很少。</p>
		<p><code><strong>gulp.src(globs[, options])</strong></code>。输出符合glob匹配模式或匹配模式数组的文件，并返回一个stream可以被pipe方法传递到别的插件中。Glob的写法和Grunt类似。Options中可以选择<code>buffer, read, base</code>等属性，更改读取格式等。以下是样例。</p>
		<pre><code>gulp.src('client/templates/*.jade')
    .pipe(jade())
    .pipe(minify())
    .pipe(gulp.dest('build/minified_templates'));
</code></pre>
		<p><code><strong>gulp.dest(path[, options])</strong></code>。可以被<i>pipe</i>进来，将会写入文件，且重新输出所有数据。因此可以继续将它<i>pipe</i>到多个文件。若文件夹不存在将会自动创建。样例如下：</p>
		<pre><code>gulp.src('./client/templates/*.jade')
    .pipe(jade())
    .pipe(gulp.dest('./build/templates'))
    .pipe(minify())
    .pipe(gulp.dest('./build/minified_templates'));
</code></pre>
		<p><code><strong>gulp.task(name[, deps], fn)</strong></code>用来定义一个使用<i>orchestrator</i>实现的任务。<code>name</code>指定任务名，<code>deps</code>指定任务列表数组，这些任务会在当前任务之前完成。<code>fn</code>表示任务要执行的一些操作。在<code>fn</code>接受一个<code>callback</code>，返回一个<code>stream</code>或返回一个<code>promise</code>时，允许任务异步执行。默认下，gulp会一次性运行所有<code>task</code>且不做等待。因此，若想创建一个序列化<code>task</code>队列，需要1）给出提示告知<code>task</code>依赖另一个<code>task</code>完成。样例如下:</p>
		<pre><code>var gulp = require('gulp');

gulp.task('one', function(cb) {
	//do something
    cb(err);
});

gulp.task('two', ['one'], function() {
    // 'one' finshed
});

gulp.task('default', ['one', 'two']);
</code></pre>
		<p><code><strong>gulp.watch(glob[, opts], tasks)</strong></code>或<code><strong>gulp.watch(glob[, opts, cb])</strong></code>。监视文件，并在文件改动时做一些事情。它会返回一个<code>EventEmitter</code>释放<code>change</code>事件。其中<code>tasks</code>为在文件变动后执行的一个或多个<code>gulp.task()</code>名字。用法如：</p>
		<pre><code>var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);
watcher.on('change', function(event) {
    console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});		</code></pre>
		<p>后者的用法则是，在<code>cb</code>中指定每次变动需要执行的<code>callback</code>。这个<code>callback</code>会被传入一个<code>event</code>对象描述监控到的变动。有如<code>path, type</code>这样的属性。其中<code>type</code>表示变动类型，有<code>added, changed, deleted</code>等。</p>
		<p><code>gulp.run</code>可以最大并行化执行系列的任务列表。</p>
		<h3 id="gulp_cli">CLI使用</h3>
		<p>常用的gulp参数很有限。<code>-v</code>显示gulp版本，<code>--require &lt;path></code>在执行前require一个模块，可以多次使用，<code>--gulpfile &lt;path></code>手动指定<span class="i">gulpfile</span>路径，<code>--cwd</code>指定<span class="i">gulpfile</span>开始查找的位置，<code>--tasks</code>显示task依赖树。<code>--color</code>强制显示颜色，<code>--no-color</code>强制不显示颜色，<code>--silent</code>禁止所有日志输出。</p>
		<p>task通过<code>gulp &lt;task name></code>来执行。只执行gulp，则会执行注册名为<code>default</code>的task.</p>
		<h3 id="gulp_more">更多</h3>
		<p>Gulp是基于流的自动构建系统。相对grunt结构简单，学习成本低。文件里存放代码而非配置。<a href="http://slides.com/contra/gulp" target="_blank">作者的幻灯片</a>里做了简明扼要地解释。想要更深入的学习，可以参加中文版的<a href="https://github.com/jabez128/stream-handbook" target="_blank">stream-book</a>对nodeJS流的介绍。在杂项里的<a href="stream">"Nodejs中的Stream"</a>也有做的笔记。</p>
		<hr>
		<h1 id="commonjs">CommonJS</h1>
		<h3 id="common_brief">简介</h3>
		<p>CommonJS的目标是在浏览器环境外构建JS生态系统，出现于2009年。官方的JS标准API是为了构建基于浏览器的应用程序，这限制了JS的更广泛应用。CommonJS定义了更多普通应用的API，它的终极目标是进行JS模块化，把JS提升到类似于Python、Ruby、Java的地位。只要环境兼容，使用CommonJS API编写的应用程序就可以通用。</p>
		<p>而实际上，NodeJS就是CommonJS模块化规范的一种实现。规范还在不断的发展中。以下展示部分内容</p>
		<h3 id="common_feature">特点</h3>
		<p><ul>
			<li>一个文件就是一个独立的作用域，只能通过global共享（不推荐）</li>
			<li>通过<code>exports</code>定义对外接口，通过<code>require</code>加载此接口</li>
			<li>模块可以多次加载，但只在第一次加载时运行并缓存。</li>
			<li>模块加载的顺序和代码中出现顺序一致。</li>
		</ul></p>
		<h3 id="common_module">Module</h3>
		<p>每个模块内部都有一个<code>module</code>对象，对象有<code>id, filename, loaded, parent, children, exports</code>等属性。这些在nodeJS中都有实现。</p>
		<p><code>module.export</code>用于向外导出模块信息。Node中为每个模块提供了一个<code>exports</code>变量预绑定到<code>module.export</code>上，通过<code>exports.xxx</code>的形式导出。破坏这个绑定关系的操作都将使<code>exports</code>变量无效。</p>
		<h3 id="require">Require</h3>
		<p><code>require</code>用于加载模块文件，它会读入并执行一个Javascript文件，然后返回<code>exports</code>对象，如果未发现指定模块会报错。同时，加载的模块的输入时被输出值的拷贝。</p>
		<p><code>require</code>加载模块时，默认为js文件。若路径以<code>/</code>开头表示绝对路径，以<code>./</code>开头表示相对路径，否则node会去<span class="i">node_modules</span>目录下查找。使用<code>require.resolve</code>可以看到确切结果。在找到目录后，会将<span class="i">package.json</span>中的<code>main</code>对应的值作为入口文件。</p>
		<p><code>require</code>进来的模块会放在缓存中，不会多次加载。若想多次执行同一模块，可以用<code>module.exports</code>导出函数，或<code>delete require.cache[moduleName]</code></p>
		<p>模块循环加载时，会先加载不完整的版本，在都<code>require</code>进来后，通过缓存读取<code>exports</code>避免不全的问题。</p>
		<h3 id="amd">AMD and more?</h3>
		<p>CommonJS主要是为JS在后端表现定制的，而浏览器和服务器端的特点是不一样的。<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)" target="_blank">AMD</a>的规范主要为前端JS表现定制。前者加载模块是同步的，后者是异步的。</p>
		<p>AMD规范使用<code>define</code>方法闭包定义模块，格式类似于<pre><code>define(id?: String, dependencies?: String[], factory: Function|Object);</code></pre></p>
		<p><code>id</code>是模块名，可选。<code>dependencies</code>是依赖模块列表。<code>function</code>是模块的具体实现，它的返回值就是模块的输出接口或值。范例如下：</p>
		<pre><code>define('myModule', ['jquery'], function($) {
    return $('body').text('hello world');
});
define(['myModule'], function(myModule) {});
</code></pre>
		<p>其中<code>function</code>的输入参数即为依赖模块的输出。通常将没有id的匿名模块作为应用的启动函数。</p>
		<p>AMD规范允许输出模块兼容CommonJS规范。</p>
		<p><a href="http://requirejs.org/" target="_blank">RequireJS</a>就是采用了AMD规范的用于模块以来的工具，使用方式同上面的范例。正如AMD名字中提到的那样，它异步引入所有的依赖模块，减少的导入的时间。同时也会因此出现隐式的难以发现的错误。与之并列的还有基于CMD规范的<a href="http://seajs.org/docs/" target="_blank">SeaJS</a>，主旨所限，从略。</p>
		<h3 id="common_more">更多</h3>
		<p>CommonJS实际上是JS模块化的一种体现。这也是JS发展的趋势。关于JS模块化编程的介绍见<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">模块的写法</a>，<a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank">AMD规范</a>，<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html?bsh_bid=230697246">require.js用法</a>。这三篇博客系统地讲解了模块化的思路和应用。另外还有<a href="http://www.cnblogs.com/skylar/p/4065455.html" target="_blank">CommonJS,AMD,CMD对比</a>，<a href="http://zhaoda.net/webpack-handbook/amd.html" target="_blank" 
		>AMD使用样例</a>，<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank">Node中CommonJS的部分实现</a>可以参考。</p>
		<hr>
		<h1 id="backbone">Backbone.js</h1>
		<h3 id="backbone_brief">概述</h3>
		<p>MVC框架是代码组织的经典模式，便于团队协作进行开发。M、V、C分别代表Model，View和Controller。同样在Javascript的社区中，也有着许多MVC和MVC变体框架MV*（下面介绍的AngularJS等）。框架的优点在于便于分工和和代码维护，缺点在于限制了代码的写法，且学习成本一般较高。</p>
		<p><a href="http://backbonejs.org/" target="_blank">Backbone.js</a>提出于2010年，它严格来说并不算是MV*框架，而是借助一些功能模块的帮助快速构建一个单页面Web应用。因此它给用户了很大的自由在<code>Model</code>和<code>View</code>的连接上。从它的API结构就能看出，<code>Model</code>和<code>View</code>部分是较重的，<code>Controller</code>部分则只由<code>router</code>和<code>router</code>对应的<code>controller</code>处理函数构成。相对来说，backbone.js的体积很小，且学习成本较低。</p>
		<p>根据官网介绍，<a href="http://underscorejs.org/" target="_blank">underscores.js</a>（一个功能型js函数库）是backbone.js的强依赖，jquery和<a href="https://www.npmjs.com/package/json2js" target="_blank">json2.js</a>是backbone用于Backbone.View的依赖，但是有类似<a href="http://zeptojs.com/" target="_blank">Zepto</a>等替代方案。因此在使用backbone.js时，通常要引入这四个文件。</p>
		<h3 id="backbone_structure">项目组成</h3>
		<p>一般来说，一个backbone.js的应用，由<code>models, views, collections, controllers</code>四部分组成。其中<code>models</code>用来描述数据的一个基本单位。如下：</p>
		<pre><code>App.Models.Person = Backbone.Model.extend({
    defaults: {
        "name": "foo",
        "value": "bar"
    }
});		</code></pre>
		<p><code>Colletions</code>是同一种<code>model</code>的集合，可以方便地表示列表等展示方式，如下：</p>
		<pre><code>App.Collections.Grade = Backbone.collection.extend({
    model: App.Models.Person
});		</code></pre>
		<p>上面的代码表示，<code>Grade</code>这个集合由<code>Person</code>单元组成。View部分用来在页面上呈现数据，呈现中涉及到绑定DOM的工作大多由jquery完成，View部分必须有<code>el</code>属性，指定绑定的DOM节点，<code>events</code>指定监听事件和对应方法，<code>initialize</code>和<code>render</code>方法分别完成初始化和渲染两个步骤。</p>
		<pre><code>App.Views.Medals = Backbone.View.extend({
    el: "#list",

    initialize: function() {
        this.listenTo(Person, 'change', this.render);
        this.listenTo(Person, 'destroy', this.remove);
        this.render();
    },

    render: function() {
        var template = _.template($('item-template').html());
        this.$el.html(template(Person.Medals.toJSON()));
    },

    events: {
        "click .toggle"     : "toggle",
        "dbclick .view"     : "edit",
        "click a.destroy"   : "clear",
        "blur .edit"        : "close"
    }
})		</code></pre>
		<p>控制器一般用来相应路由的结果，定义比较自由，例如下面的形式：</p>
		<pre><code>App.Controllers.show = function(id) {
    var p = new App.Models.Person({id: id});
    p.updateTime(Date.now());
    p.fetch(function(model,response,options){
        var view = new App.Views.Medals({medal: p});
    });
};		</code></pre>
		<p>最后路由方面。通过继承backbone的<code>router</code>模块实现：</p>
		<pre><code>var paths = Backbone.Router.extend({
    routes: {
        ""                  : "wholeApp",
        "users/:id"         : "usershow",
        "users/:id/p:order" : "ordersIndex"
    },

    wholeApp    : App.Controller.default,
    usershow    : App.Controller.show,
    ordersIndex : App.Controller.orderBy
});
new paths();
Backbone.history.start({pushState: true});
</code></pre>
		<p>在定义好路由部分后，通过backbone的<code>history</code>模块的<code>start</code>方法启动路由即可。一个基于Backbone.js构造的项目结构大抵如此，它们可以位于同一个文件下（一般案例完全可以这么做）甚至位于html的script标签内。诚然这便于中小型项目，尤其是单页面逻辑内容丰富的Web应用开发使用，不也和当前流行的组件化、模块化的js开发风格有所不同。目前backbone.js仍然在1.x版本，可能会在2.0版本后采用ES6的原生模块化方案等新js特性吧。</p>
		<h3 id="backbone_api">API介绍（v1.3.3）</h3>
		<p>Backbone官网对它的API有着详细的介绍，且页面风格与Zepto、underscore一致，非常便于阅读和检索。</p>
		<h4 id="backbone_view">View</h4>
		<p><code>Backbone.View</code>的方法用来定义视图类，其中最根本的方法extend拓展定义一个视图类，类的内部通常由<code>render</code>方法渲染界面，渲染时使用类jquery的语法，插入一些html比群标签或计算后的内容。定义好视图类后，通过新建视图实例的形式运行，得到结果，新建时，<strong>有时需要指定<code>Model</code></strong>。</p>
		<p>在需要用到<strong>模板</strong>时，可以先通过underscore(简写符为'<code>_</code>')的<code>template</code>方法导入模板为函数。模板通常建议用<code>&lt;script></code>并指定<code>type=text/template</code>的定义在html文档中，并用jquery的语句获取。导入模板后，可以把数据的json格式输入到函数中。</p>
		<p><ul>
			<li><code><strong>extend(properties[, class properties])</strong></code>：用来创建视图类，有时不在配置中指定<code>el</code>，而通过<code>tagName</code>或是<code>className</code>指定列表中的各元素</li>
			<li><code><strong>initialize([options])</strong></code>：在实例化视图类的时候调用，可以写入<code>el</code>的属性。</li>
			<li><code><strong>el</strong></code>属性：指定视图所绑定的网页元素（通常用在<strong>单例视图类</strong>中），<code>$el</code>则表示<code>el</code>所对应的jquery对象。</li>
			<li><code><strong>tagName, className</strong></code>属性：见上面介绍</li>
			<li><code><strong>template</strong></code>方法：通过_.template(xxx)指定网页模板生成模板函数，在<code>render</code>中渲染。</li>
			<li><code><strong>events</strong></code>属性：指定视图中的事件及其对应的处理函数</li>
		</ul></p>
		<p>另外，还有<code>setElement</code>更改<code>el</code>，<code>remove</code>移除<code>el</code>和jquery自带的一些方法可以使用。</p>
		<h4 id="backbone_event">Events</h4>
		<p><code>Backbone.Events</code>是一个事件对象，任何继承这个对象的对象，都具有<code>Backbone.Events</code>接口，可以使用<code>on</code>和<code>trigger</code>等方法，发布和订阅消息。</p>
		<pre><code>// use extends
var EventListener = _.extend({}, Backbone.Events);
//use clone
var Dispatch = _.extend(Backbone.Events);
</code></pre>
		<ul>
			<li><code><strong>on(event, callback, [context])</strong></code>方法。可以将回调函数绑定在对象的一些事件上，并可以通过<code>off</code>方法取消绑定。<code>once</code>方法绑定的事件只触发一次回调函数。</li>
			<li><code><strong>trigger(event, [*args])</strong>可以触发特定事件。</code></li>
			<li><code><strong>listenTo(other, event, callback)</strong></code>可以把对象绑定在其他对象的事件上，经常用在View视图类中。如<code>view.listenTo(model, 'change', view.render);</code></li>
		</ul>
		<p>Backbone提供了许多内建的事件，如<code>add, remove, update, change, reset, change:[attr], destroy</code>等，更多的参加<a href="http://backbonejs.org/#Events-catalog" target="_blank">官方文档</a>。</p>
		<h4 id="backbone_router">Router</h4>
		<p><code>Router</code>是backbone提供的路由对象，用于将用户请求的url和后台函数一一对应。同样，它也通过<code>extend</code>方法定义。</p>
		<ul>
			<li><code><strong>routes</strong></code>属性：通过键值对形式指定路径和函数名。空字符串代表根路径，<code>*</code>代表任意路径，同时也可以通过":"设置路径参数，这些参数会被捕获并传入处理函数。同样可以用<code>route</code>函数一条条定义路由。</li>
			<li><code><strong>navigate(fragment, [options])</strong></code>：调转到新页面，这是<code>trigger</code>和<code>replace</code>属性可以保留url和浏览器记录。</li>
			<li><code><strong>execute(callback, args, name)</strong></code>：在每次路由时都会调用，通过<code>callback</code>的返回值是否为真，判断是否调用处理函数，如下：</li>
		</ul>
		<pre><code>var Router = Backbone.Router.extend({
    execute: function(callback, args, name) {
        if (!loggedIn) {
            goToLogin();
            return false;
        }
        args.push(parseQueryString(args.pop()));
        if (callback) callback.apply(this, args);
    }
});		</code></pre>
		<p>路由类设置好后，实例化之，并通过<code>Backbone.history.start()</code>启动。通常需要指定<code>pushState</code>为<code>true</code>。如果应用程序不在根目录，还需要设置<code>root</code>值。</p>
		<h4 id="backbone_model">Model</h4>
		<p><code>Model</code>代表单一的对象。和<code>Collection</code>一起组成Model层。Backbone.js并不要求Model的数据位于本地，在使用<code>fetch()</code>等操作时，backbone的sync方法默认会用jquery的<code>get</code>方法等去获取。所以，很多本地存储数据的应用会重写<code>Backbone.sync</code>函数。</p>
		<p>Model依旧使用<code>extend</code>方法生成类，和view类似使用<code>new</code>创建实例，可以在<code>defaults</code>属性中设置默认属性。在生成实例时，需要提供各属性的具体值，且需要有主键字段，便于和MangoDB等数据库互动。</p>
		<ul>
			<li><code><strong>get(attr)，set(attr,[options])</strong></code>分别用来获取和设置该实例的值。在有特殊字符防止xss时，推荐使用<code><strong>escape</strong></code>方法代替<code>get</code>方法。</li>
			<li><code><strong>has(attr), unset(attr,[options]), clear([options])</strong></code>：分别检测是否有某属性，删除某属性和删除所有除id外的属性，<code>options</code>中可以指定<code>silent</code>，不触发<code>change</code>事件。另外，属性可以直接通过<code>attributes</code>访问。</li>
			<li><code><strong>idAttribute</strong></code>属性：指定作为主键的字段。可通过<strong>id</strong>访问。</li>
			<li><code><strong>toJSON([options])</strong></code>：将该实例json化，常和<code>View.template</code>配合使用。</li>
			<li><code><strong>fetch([options])</strong></code>：通过jquery发起XHR请求，获取model数据。在<code>options</code>中可以分别指定<code>success</code>和<code>error</code>的回调，回调分别接受<code>model, response, options</code>。使用方法如下：</li>
			<pre><code>var user = new User ({id: 1});
user.fetch({
    success: function (user){
        console.log(user.toJSON());
    }
})</code></pre>
			<li><code><strong>save([attr], [options])</strong></code>：通知服务器新建或更新Model，如果Model实例不含id属性，将使用<code>POST</code>新建，如果Model带有id属性，<code>save</code>方法将使用<code>PUT</code>更新实例。<code>options</code>和<code>fetch</code>用法类似。</li>
			<li><code><strong>validate(attr, [options])</strong></code>检测属性是否合法会，触发<strong>invalid</strong>事件。<code>isValid()</code>方法会执行validate返回是否合法的结果。</li>
		</ul>
		<p>另外<code>destroy</code>方法清除一个实例，<code>clone</code>拷贝一个实例，<code>hasChanged</code>检测属性是否已更新。Underscore关于对象的如<code>keys</code>，<code>pick</code>等方法也可使用。</p>
		<h4 id="backbone_collection">Collection</h4>
		<p>Colletcion是<strong>同一类</strong>Model的集合，如Model是学生，Collection就是班级；Model是歌，Collection就是专辑。如下面代码所示：</p>
		<pre><code>var Song = Backbone.Model.extend({});
var Album = Backbone.Collection.extend({
    model: Song
});		</code></pre>
		<ul>
			<li><code><strong>add(models, [options]), remove(models, [options])</strong></code>：将new出来的实例直接放入Collection的实例，或通过<code>id</code>字段值移除Model实例。</li>
			<li><code><strong>get(id), set(model, [options])</strong></code>获取collection中的某个model，或重设整个collection。在重设时通过融合的方式完成。</li>
			<li><code><strong>model([attrs], [options])</strong></code>指定collections所包括的Model。<strong>modelId</strong>属性指定Collection标记Model的方法，函数接受<code>attrs</code>。多用在不同<code>idAttribute</code>的情况。</li>
			<li><code><strong>comparator</strong></code>指定排序Model的标准字段。<code>sort([options])</code>方法会跟这个属性来排列Models。</li>
			<li><code><strong>pluck(attr), where(attr)</strong></code>取出所有Models的某一列，返回满足<code>where</code>条件的所有Model。<code>findWhere(attr)</code>返回第一个满足条件的结果。</li>
			<li><code><strong>fetch([options])</strong></code>类似Model中的用法，获取整个Collection。</li>
			<li><code><strong>create(attr, [options])</strong></code>通过Collection创建一个Model。</li>
		</ul>
		<p>此外，underscore和原生用于数组的方法如<code>push, pop, shift, unshift, forEach, every</code>等等函数也可以使用。</p>
		<h3 id="backbone_demo">Demos</h3>
		<p>由于Backbone.js并非使用模块来构建Web应用，且自由度很高，结合上面介绍的API，可以方便地构建很多单页面应用。官网也提供了许多demos，便于初学者上手掌握。</p>
		<p>可以先从<a href="http://arturadib.com/hello-backbonejs/" target="_blank">Hello-backbonejs</a>上手，感受backbone的基本使用。之后学习<a href="http://backbonejs.org/examples/todos/index.html" target="_blank">Todos</a>（系列的<a href="https://github.com/tastejs/todomvc" target="_blank">TodoMVC</a>也是很不错的学习<a href="https://angularjs.org/" target="_blank">Angular</a>，<a href="http://emberjs.com/" target="_blank">Ember.js</a>等的demo），就可以开始自己捣鼓点小东西了。个人认为对比下面介绍的框架，已经好上手很多了。</p>
		<h3 id="backbone_more">更多</h3>
		<p><strong>Backbone.locaStorage</strong>也是很常用的backbone的插件，用于将Model和Collection的数据插入到本地存储中，根据介绍，使用很简单：</p>
		<pre><code>window.SomeCollection = Backbone.Collection.extend({

    localStorage: new Backbone.LocalStorage("SomeCollection"), // Unique name within your app.

    // ... everything else is normal.

});		</code></pre>
		<p>另外很喜欢官网的style，和underscore以及zepto的一样，简约而便于检索。本文的样式也参考自此。</p>
		<hr>
		<h1 id="express">Express JS</h1>
		<h3 id="express_brief">概述</h3>
		<p>Express是基于Node.js的流行Web开放框架，没有对NodeJS进行二次抽象。可以快速搭建一个完整功能的网站。后面我们将用一个例子简单展示express的特点。</p>
		<p>新建一个项目目录，进入该目录新建<span class="i">package.json</span>文件，填写项目的一些配置信息。包括<span class="i">name, description, version, dependencies</span>等等。其中<code>dependencies</code>，/中可指定express的版本范围，如<code>4.x</code>. 执行<code>npm install</code>指令安装环境。</p>
		<p>新建<span class="i">index.js</span>，写入如下样例：</p>
		<pre><code>var express = require('express');
var app = express();

app.get('/',function(req, res){
	res.send('Hello, world!');
});

app.listen(8888);
</code></pre>
		<p>即可在浏览器看到页面效果。其中<code>app.get</code>对路由的处理还可以拓展到其他路径，封装成路由模块。</p>
		<h3 id="express_basic">基本原理</h3>
		<p>Express框架建立在nodeJS内置的<code>http</code>模块上。上面的<code>app</code>实际上就是由<code>http</code>的<code>createServer</code>方法生成的。而express只是做了一层包装。</p>
		<p>中间件是处理http请求的函数。多个中间件按照流水线的形式处理请求，单个中间件处理完成后，通过调用<code>next</code>方法交给下个中间件处理。<code>next</code>方法所带参数表示抛出错误。可以通过<code>use</code>方法注册中间件。样例如下：</p>
		<pre><code>var express = require('express')
var http = require('http');
var app = express();

app.use('/home', function(req, res, next){
	res.writeHead(200, {"Content-Type": "text/plain"});
	res.end("Welcome!");
});

app.use('/about', function(req, res, next){
	res.writeHead(200, {"Content-Type": "text/plain"});
	res.end("About.");
});

app.use(function(req, res){
	res.writeHead(404, {"Content-Type": "text/plain"});
	res.end("404 error!\n");
});

app.listen(8888);
</code></pre>
		<h3 id="express_methods">常用方法</h3>
		<p>除了上文中用到的<code>use</code>,/，对于一些特殊的<code>use</code>使用，还有别名的方法。如<code>all</code>方法表示所有满足第一个条件的请求都必须通过该中间件，<code>*</code>则表示所有请求都必须通过。<code>get</code>方法和<code>post, put, delete</code>等方法也类似，它们没有<code>next</code>方法，只要一个中间件被调用，后面的中间件就不再调用。注意，<code>app.get(name)</code>意为获取全局变量值。</p>
		<p>这些方法的第一个参数都是请求的路径。Express允许模式匹配，即可以在路径中匹配并捕获模式字段，字段后加上<code>?</code>表示模式可选。范例如下：</p>
		<pre><code>app.get('/hello/:who?', function(req, res){
	if(req.params.who) res.end("Hello " + req.parmas.who + "!"); 
	else res.send("Hello guest.");
});		</code></pre>
		<p>url匹配还支持正则匹配。范例略。同时，<code>set</code>方法可以为系统变量指定新值。</p>
		<p><code>response</code>对象也有一些常用方法。<code>redirect</code>方法用于网页重定向，<code>sendFile</code>用于发送文件，<code>render</code>用于渲染网页模板，向模板中传递数据。<code>Request</code>也有着许多常用对象，<code>ip</code>用于获得请求的ip地址，<code>files</code>用于获取上传的文件。</p>
		<p>搭建https服务器的方法略。更多API见<a href="http://expressjs.com/zh-cn/api.html" target="_blank">官方文档</a>。</p>
		<h3 id="express_template">网页模板</h3>
		<p>通常，对于大部分请求，返回的结果都为较复杂的网页，此时使用<code>send</code>方法就不再方便。展示静态网页模板时，使用<code>response</code>对象的<code>sendFile</code>方法可以解决此问题。渲染动态网页可以使用<code>render</code>方法，也可以利用一些模板引擎完成。</p>
		<p>在模板中通过{{}}(因模板而异)加载动态数据。模板后缀，视图模板存放的路径，渲染引擎入口等可以在入口js处统一声明。</p>
		<p>静态文件通过<code>express.static</code>方法指定路径，在浏览器发出非HTML文件请求时，去指定的目录寻找。</p>
		<h3 id="express_router">路由</h3>
		<p>在4.0后，express将路由功能封装成了一个单独的组件<code>Express.Router</code>。同样拥有<code>use, get, param, route</code>方法。用法和<code>app</code>极为相似。方便通过<code>app.use(xxx, router)</code>的形式挂载不同的根目录。<code>route</code>方法以路径作为输入参数，之后跟<code>post</code>或其他方法绑定到该路径上。注意，<code>router</code>中的<code>use</code>中间件须放在HTTP动词方法之前，否则不会执行。</p>
		<p><code>app</code>同样有<code>route</code>属性，<code>app.route</code>是<code>express.router()</code>的等价形式。</p>
		<h3 id="express_modules">常用模块</h3>
		<p>使用Express快速开发网络应用的时候，会用到许多现成的模块辅助开发。它们能在express的组织下方便地完成各种功能。</p>
		<h4 id="body-parser"></h4>
		<p>body-parser是express的处理请求体的中间件。它接受stream格式的<code>request</code>体，并以用户需要的格式友好地返回。以下是一些body-parser提供的API。</p>
		<p><code>bodyParser.json(options)</code>解析json格式的请求体，接受Unicode编码的请求提，支持gzip和deflate格式。<code>req.body</code>会被解析后的<code>body</code>替代。</p>
		<p><code>bodyParser.raw(options)</code>将请求题以Buffer类型解析。返回的解析器将请求体解析为<code>buffe</code>r格式。<code>bodyParser.text(options)</code>类似，解析为<code>string</code>格式。</p>
		<p><code>bodyParser.urlencoded(options)</code>只解析urlencoded请求体，接受UTF-8编码。生成的新的请求体是键值对的格式。</p>
		<p>这些API可以按顺序多次列写，依次尝试解析直到body体被成功解析为止。更多信息见<a href="https://github.com/expressjs/body-parser" target="_blank">官方解释</a>。</p>
		<h4 id="cookie-parser"></h4>
		<p>cookie是用来解决HTTP协议无状态的问题的。Cookie通过服务器发往客户端浏览器，在浏览器每次发起请求时附带，有<code>path, expire, maxAge, secure, httpOnly</code>等参数。</p>
		<h4 id="express-session">Express-session</h4>
		<p>为了保证cookie的安全性，session因此诞生。Session通过<code>sid</code>标识，通常储存在cookie中，服务器每次接收到请求，将session id对应的<code>data</code>关联，进行相应操作。Session可以存放在1) 内存2) cookie 3) redis, memcached缓存 4)数据库中。</p>
		<p>Express中操作session用来这个模块主要通过<code>session(options)</code>初始化并作为处理回话(session)的中间件。Options中的主要参数有<code>name</code>，用来指定cookie中保存session的字段名，<code>store</code>指定session的存储方式，<code>secret</code>指定hash加密cookie的方式，<code>cookie</code>指定存放sid的cookie的相关选项，<code>genid</code>指定生成新sid时用到的函数，<code>rolling</code>指定每个请求是否重新设置一个cookie，<code>resave</code>指定session未更改时，是否保存session值。</p>
		<h4 id="connect-mongo">Connect-mongo</h4>
		<p>这个组件是用来方便地将用户session存储在mongodb中的。通过<code>require(xxx)(session)</code>引入后，如<code>session(new MongoStore(opts))</code>这样使用。<code>opts</code>里可以通过Mangoose或其他驱动器或url指定MondoDB服务器。详情见<a href="https://github.com/kcbanner/connect-mongo" target="_blank">github api解释</a></p>
		<h4 id="ejs">Ejs</h4>
		<p>实际上ejs严格来说是一个模板引擎，负责将模板文件替换成html文件再发回到客户端。ejs有三种标签。<code><% code %> <%= code %> <%- code %></code>分别对应JS代码，可以通过使用for循环显示列表内容。ejs还可以使用<code><%- include a %></code>引入其他模板从而实现页面布局的效果。</p>
		<p>个人认为jade模板引擎Markdown式的写法更简洁。</p>
		<h4 id="express-mongo">Mongodb</h4>
		<p>Node开发经常使用的MongoDB做数据库。MongoDB是Mongo在node.js中的驱动。在2.x版本的mongodb中，通过<code>MongoClient.connect(url, opts, callback)</code>创建和数据库的连接，其中<code>callback</code>可以读取<code>err</code>和<code>db</code>对象，从而对数据库操作。通过<code>db.collection(name)</code>获取指定集合，使用得到的collection的<code>insert, insertMany, find(quert), sort, limit, update, delete</code>完成增删改查。使用<code>toArray</code>可以把查询的数据转成数组格式。</p>
		<p>更多Mongodb使用参见<a href="http://mongodb.github.io/node-mongodb-native/2.1/api/" target="_blank">node-mongodb API文档</a>.</p>
		<h4 id="express-flash">Connect-flash</h4>
		<p>flash使用session的特殊区域。信息在展示前被写入<code>flash</code>，展示给用户后即被擦除。Flash常用于跳转页面，保证信息能够正确传递到下一个被渲染的界面。</p>
		<p>使用时，在初始化session后，创建<code>flash</code>中间件即可。在页面即将跳转时，写入信息到<code>req.flash</code>中，在跳转的页面里，即可通过<code>req.flash</code>获取到。</p>
		<h3 id="express_more">更多</h3>
		<p>在实际开发中，通常综合了许多的模块。惯例下，在<span class="i">bin</span>目录下放置可执行文件，<span class="i">models</span>目录下放置模型定义和与数据库沟通的文件充当Model部分，<span class="i">node_modules</span>放置依赖包，<span class="i">public</span>放置静态文件包括css文件等，<span class="i">routes</span>放置路由文件充当Controller部分，<span class="i">views</span>放置视图模板作为View部分。父目录下还有<span class="i">app.js</span>作为入口文件，<span class="i">package.json</span>作为项目配置文件，<span class="i">settings.js</span>储存常用设置参数如数据库端口等。</p>
		<p>Express有着丰富的模块可供选择，模块文档可以在npm和github上找到，这些模块可以帮助你轻松完成复杂功能，让开发者专注于工程结构和代码逻辑。以上的笔记来自<a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank">阮一峰博客</a>和<a href="https://github.com/nswbmw/N-blog/wiki/%E7%AC%AC1%E7%AB%A0--%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%9A%E5%AE%A2" target="_blank">开发简单博客的实例</a>。</p>
		<hr>
		<h1 id="react">React JS</h1>
		<h3 id="react_what_why"><a href="https://facebook.github.io/react/blog/2013/06/05/why-react.html" target="_blank">What and Why</a></h3>
		<p>React起源于facebook的内部项目。起初用来搭建Instagram的UI界面，渐渐地发展为前后端都有的网络应用解决方案。React作为开发UI界面的库，特点十分明显。</p>
		<ul>
			<li>组件化，react允许将代码封装成一个个组件，然后像插入HTML标签一样，在网页中插入这个组件。在定义好组件后，要做的只是组建的复用和组合。</li>
			<li>组件就像台有限状态机，用户交互改变状态变化，自动触发重新渲染。组件的生命周期内，有特定处理函数去处理状态变化，并更新改变的部分。这在页面数据经常更新时，会非常方便。</li>
		</ul>
		<p>关于它还有些需要明确的东西。首先，React并不是一个完整的MVC框架，它和MVC中的V更像；react也并不是一种新的模板语言，没有<span class="i">JSX</span>的React也能正常工作，<span class="i">JSX</span>是为那些更偏好HTML写法的人准备的。React提供了服务器端的Render能力，但实际上这并不是它的核心出发点，事实上React官方教程是以浏览器端应用介绍为主的。</p>
		<h3 id="thinking_in_react_way"><a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank">Thinking in React Way</a></h3>
		<p>使用React可以快速构建Web应用程序组件。在使用React构建一个产品时，通常有如下几步：</p>
		<ul>
			<li><strong>拆分界面为一个组件树</strong>，理想状态下一个组件应该只做一件事，当功能较大时就需要拆分成更小的子组件。</li>
			<li><strong>利用React创建一个静态版本</strong>，不考虑交互功能，只将数据模型渲染在UI上。在这个过程中，将会构造一些组件，这些组件重用其他组件，并通过props传递数据。注意，这里不用到state，state用来实现交互功能。</li>
			<li><strong>为组件设计最小完整state</strong>，<code>state</code>使得交互触发底层数据模型的变化。考虑设计中的所有数据片段，从父级传入的，不随时间变化的，根据其他<code>props</code>和<code>state</code>算出的多半不适合做state。</li>
			<li><strong>确定state的生命周期</strong>，在上一步确定作为state的数据片段后，需要确定改变或拥有这些state数据的组件。因为React中数据沿着组件树从上向下单向流动，通常，选择基于state渲染节点的组件的共同祖先组件维护这个state。</li>
			<li><strong>添加反向数据流</strong>，在上面的步骤后，数据流已经基于<code>props</code>和<code>state</code>沿组件树从上到下单项渲染。层级较深的组件需要更新state时，需要祖先组件传递一个回调函数，在特定事件时触发。</li>
		</ul>
		<h3 id="react_data">数据呈现</h3>
		<p>用户界面做的最多的就是数据的呈现。React让呈现更简单，且数据变化时，用户界面自动更新。例子见<span class="i">reactjs-demo</span>的<span class="i">hello-react</span>。</p>
		<p>React并不会去操作真实DOM（除非必要），它用一个快速的内置虚拟DOM元素呈现改变来达到高效率。组件的数据输入称为<code>props</code>，通过JSX语法传递，且只读。React组件就像是函数，接受<code>props</code>和<code>state</code>做参数，渲染单个HTML节点。</p>
		<p>MVC模型中通常将模板显示和数据逻辑分离开，React开发者认为这样会产生过多代码。因此，React的解决方案是通过Javascript直接生成模板，允许在js中使用HTML语法，这种js和HTML混用的语法被称为JSX。JSX和HTML很像，在babel的帮助下，可以在多种环境下使用JSX。</p>
		<p><strong>React不强制使用JSX，完全可以使用React API（<code>React.createElement</code>）和原生Javascript创建React元素</strong>。方便起见，可以通过工厂方法<code>React.createFactory()</code>创建自定义组件。React已经为HTML标签设置了内置工厂方法。</p>
		<h4 id="jsx">JSX</h4>
		<p>JSX很像XML的Javascript的语法拓展，通过React可以做JSX的简单转换。虽然不强制，但是React建议使用JSX语法。XML标签的语法可以使组件关系更加清晰，比方法调用和字面量的形式可读性更好。</p>
		<p>React可以渲染HTML标签(string)和React组件(classes)，其中前者需要在JSX中使用小写字母开头的标签名，后者需要创建一个大写字母开头的本地变量（使用时是也是大写字母开头的标签名）。这是React约定俗称的。需要注意的是，<strong>JSX中的一些标识符如<code>class</code>和<code>for</code>替代为<code>className</code>和<code>htmlfor</code></strong>（它们是js的保留字）。</p>
		<p>React会将类XML语法的JSX转成纯粹的Javascript，XML元素，属性和子节点会被转换成<code>React.createElement</code>的参数。JSX同样允许类似XML的方式定义子节点。示例如下：</p>
		<pre><code>var Nav, Profile;
// React Input (JSX):
var app = &lt;Nav color="blue">&lt;Profile>click&lt;/Profile>&lt;/Nav>;
// React Output (JS):
var app = React.createElement(
    Nav,
    {color:"blue"},
    React.createElement(Profile, null, "click")
);		</code></pre>
		<p>上面代码中，Input和output的语句是等效的。JSX还将从变量名中设定组件的<code>displayName</code>，若使用<code>React.createClass</code>时没有指定<code>displayName</code>的属性。</p>
		<p>V0.11.0后，React支持命名空间组件，当构建一个有许多子节点的组件时，可以通过设置父组件的命名空间避免过多的变量定义。在定义时，使用类似于<code>FatherComponent.son = xxx</code>的形式定义。</p>
		<p>Javascript表达式在JSX中使用一对大括号{}包裹，不使用引号。组件中的提及的属性默认为<code>true</code>，未提及的属性默认为<code>false</code>。子组件也可以作为表达式使用。</p>
		<h4 id="jsx_html">JSX属性扩散与HTML</h4>
		<p>若事先知道组建的全部属性（<code>props</code>），JSX可以很轻松地定义组件。同时，如果不知道应该设置哪些props，最好不要设置它。JSX的新特性属性扩散支持通过<code>{…props}</code>的形式将属性传递进组件内。它可以多次使用，且可以和其他属性一起使用，后面的属性会覆盖前面的。语法类似下面：</p>
		<pre><code>var props = {};
props.foo = x;
props.bar = y;
var component = &lt;Component {...props} />;
</code></pre>
		<p><code>...</code>操作符实际上也是<a href="#es2015">ES6新规范</a>中的新特性。</p>
		<p>JSX中可以插入HTML实体，但JSX会对所有字符串做二次转义，避免XSS攻击。最简单的方法是直接使用Unicode字符，或者通过<code>\u00xx</code>的形式插入Unicode字符，万不得已，可以在div的<code>dangerouslySetInnerHTML</code>的属性里直接指定原始HTML。</p>
		<p>可以为原生HTML元素指定自定义属性，但需要在属性前加上<code>data-</code>的前缀，否则React不会渲染它们。然而自定义元素支持任意属性表示网络可达性的<code>aria</code>属性会被正确渲染。</p>
		<h3 id="react_interact">添加交互</h3>
		<p>React用<code>state</code>记录因用户交互改变的组件状态。把事件处理器以驼峰命名形式当作组件props传入即可，就像使用普通HTML一样。在背后，React把事件回调隐式绑定在它的组件实例上，减少了用户的代码量。实际上，React也并没有把事件处理器绑定在节点上，而是用一个最外层的唯一事件监听器处理和分发事件，分发时根据组件在内部映射的事件处理器做处理。</p>
		<p>如之前提到的，可以把用户界面的组件想象成状态机，React只需更新组件的<code>state</code>，然后根据<code>state</code>重新渲染界面，无需操作DOM。常用的通知React数据变化的方法是调用<code>setState(data, callback)</code>合并<code>data</code>到<code>this.state</code>中，触发重新渲染。</p>
		<p>实际上，大多数的组件完成的工作只是从<code>props</code>里读取数据并渲染，但是在需要响应用户操作、服务器请求或时间推移时，<code>state</code>是需要的。<strong>React建议将尽量多的组件无状态化</strong>，这样可以减少冗余，更好描述组件业务逻辑。因此，<strong>通常的模式是创建多个只负责渲染数据的无状态(stateless)组件，并在它们上层创建一个有状态(stateful)组件，这个组件封装了所有的用户交互逻辑，而它的无状态子组件负责声明式渲染数据</strong>。</p>
		<p>承接上文，由于React会根据<code>state</code>自动渲染，因此尽量只把组件的状态原子化，会避免经常性的手动保持数据同步。计算所得数据、React组件、基于props的重复数据不建议包括在state中。总结下来就是，<strong>state内储存的数据相互独立且和props的数据相互独立</strong>。</p>
		<h3 id="react_component">组合组件</h3>
		<p>上面的介绍都局限在但各组件内，React里能通过开发简单组件将程序的不同关注点分离，获得类似于使用函数和类的好处。官网提供的Avatar组件例子清晰易懂：</p>
		<pre><code>var Avatar = React.createClass({
  render: function() {
    return (
      &lt;div>
        &lt;ProfilePic username={this.props.username} />
        &lt;ProfileLink username={this.props.username} />
      &lt;/div>
    );
  }
});

var ProfilePic = React.createClass({
  render: function() {
    return (
      &lt;img src={'http://graph.facebook.com/' + this.props.username + '/picture'} />
    );
  }
});

var ProfileLink = React.createClass({
  render: function() {
    return (
      &lt;a href={'http://www.facebook.com/' + this.props.username}>
        {this.props.username}
      &lt;/a>
    );
  }
});

React.render(
  &lt;Avatar username="pwh" />,
  document.getElementById('example')
);		</code></pre>
		<p>从上面的例子看到，组件的拥有者为组件设置<code>props</code>，反之亦然。同样的道理，组件无法修改自己的<code>props</code>。React中，<strong>从属关系</strong>和<strong>父子关系</strong>是两个不同的概念。上一个例子中，<code>Avatar</code>是<code>div</code>、<code>ProfilePic</code>和<code>ProfileLink</code>的拥有者，<code>div</code>是<code>ProfilePic</code>和<code>ProfileLink</code>实例的父级。</p>
		<p>在React组件实例化时，可以在闭合标签内引用其他组件或javascript表达式。通过<strong><code>this.props.children</code></strong>这个<code>props</code>读取子级。每次render后，React会根据子级的渲染顺序校正子级。当状态化组件需要删除组件时，通常采用设置<code>display: none</code>来解决。React里，数据通过上面介绍的<code>props</code>从拥有着流向从属者，这就是React中的<strong>单向数据绑定</strong>。拥有者可以通过<code>props</code>和<code>state</code>计算出一些值，然后将结果绑定在从属组件的<code>props</code>上。结合ES7的实验特性，使用<code>var {x, y, …other}=this.props</code>（解构赋值）定义组件<code>props</code>，把未知属性批量提取出来，避免传递不必要的<code>props</code>给子组件。</p>
		<p>随着应用不断拓展，确保组件正确使用很重要。<strong><code>React.propTypes</code></strong>提供了很多验证其来验证传入数据的有效性，如<code>React.PropTypes.element</code>可以限定只能传入一个子级。当<code>props</code>接收到无效数据时，Javascript控制器会抛出警告。出于性能考虑，通常只在开发环境验证<code>propType</code>。官网教程给出了<code>propType</code>的各种用法，在使用时，<code>propTypes</code>需要写在组件的属性里。<code>getDefaultProps</code>属性支持用声明式的方式定义<code>props</code>的默认值。保证父级未传入<code>props</code>时，<code>this.props.value</code>有默认值。利用JSX的属性扩散语法，可以轻松传递<code>props</code>，就像下面这样：</p>
		<pre><code>var CheckLink = React.createClass({
    render: function() {
        return &lt;a {...this.props}>{'√ '}{this.props.children}</a>;
    }
});

React.render(
    &lt;CheckLink href="/checked.html">
        Click here!
    &lt;/CheckLink>,
    document.getElementById('example')
);		</code></pre>
		<p>组件间有时也需要共用一些功能，React使用mixins解决这类问题。在mixins定义好之后，通过指定组件的<code>mixins</code>属性，并用<code>[]</code>包裹引用mixin。另外，利用ES6的js新特性class定义，可以使用<code>class HelloMessage extends React.Component</code>定义组件。</p>
		<h3 id="react_form">表单组件</h3>
		<p>React的表单组件支持几个受交互影响的属性: <code>value, checked</code>和<code>selected</code>。组件可以通过<code>onChange</code>回调函数监听组建变化。设置了<code>value</code>的<code>&lt;input></code>是一个受限组件，渲染出来的HTML始终保持<code>value</code>属性的值。没有设置<code>value</code>的<code>&lt;input></code>组件是一个不受限的组件，渲染的元素直接反应用户输入，可以通过<code>defaultValu</code>e设置初始值。同样地，radio，checkbox的<code>&lt;input></code>支持<code>defaultChecked</code>属性，<code>&lt;select></code>支持<code>defaultValue</code>属性。</p>
		<p>设置受限组件和不受限组件是因为React的组件实际上反映了视图在任何时间点的状态。所以既然明确写出value=xxx，那么输入框的值在任何时间点被渲染都应该不变。另外，<code>textarea</code>和<code>select</code>标签也使用<code>value</code>和<code>defaultValue</code>方便进行组件控制。</p>
		<h3 id="react_component_life">组件说明与生命周期</h3>
		<p>组件通过<code>React.createClass</code>创建（ES6新特性下，继承<code>component</code>类亦可）。</p>
		<ul>
			<li><code>render</code>方法是必须的，它应该是纯粹的，不修改组件<code>state</code>，不涉及交互，每次调用返回相同信息。</li>
			<li><code>getInitialState</code>方法在组件挂载前调用，设置<code>this.state</code>的初值。</li>
			<li><code>getDefaultProps</code>在组件创建时调用一次，返回值被缓存下来，用于父组件遗漏props，这个方法不能依赖<code>this.props</code></li>
			<li><code>propType</code>对象允许验证传入组件的<code>props</code></li>
			<li><code>mixins</code>对象允许使用mixin来在组件间共享行为。</li>
			<li><code>statics</code>对象允许定义静态方法在组件类上调用</li>
			<li><code>displayName</code>字符串输出调试信息</li>
		</ul>
		<p>组件的生命周期分为三个阶段：挂载、更新、移除。React提供生命周期方法，其中<strong><code>will</code>方法</strong>在某些行为发生前调用，<strong><code>did</code>方法</strong>在某些行为发生后调用。</p>
		<p><strong>挂载</strong>：组件被插入到DOM中。<code>getInitialState()</code>方法在组件挂载前调用。状态化组件需要实现这个方法，返回初始的state数据。<code>componentWillMount()</code>在前，<code>componentDidMound</code>在后。</p>
		<p><strong>更新</strong>：组件被重新渲染，查明DOM是否应该刷新。</p>
		<ul>
			<li><code>componentWillReceive(obj nextProps)</code>当一个挂在组件接收到新的<code>props</code>时候被调用。该方法应该用于比较<code>this.props</code>和<code>nextProps</code>的不同来判断是否使用<code>this.setState()</code>来改变<code>state</code>。</li>
			<li><code>shouldComponentUpdate(o- bj nextProps, obj nextState): boolean</code>当组件作出是否要更新DOM决定时被调用，实现该函数优化<code>this.props</code>和<code>nexProps</code>以及<code>this.state</code>和<code>nextState</code>的比较，如果不需要更新，返回<code>false</code>。</li>
		</ul>
		<p><code>componentWillUpdate()</code>和<code>componentDidUpdate()</code>分别在更新发生前后调用。</p>
		<p><strong>移除</strong>：组件从DOM中移除。<code>componentWillUnmount()</code>在组件移除和销毁前被调用。</p>
		<h3 id="refs">Refs</h3>
		<p><strong>React从不直接操作DOM</strong>，它在内存中维护一个DOM描述，并通过描述快速计算差异然后更新浏览器中的DOM。另外，React实现了完备的虚拟事件系统，确保所有事件对象符合W3C标准。但是，React也提供了直接使用底层DOM API的途径。</p>
		<p>通过<code>React.findDOMNode</code>函数可以通过DOM节点获取挂载在之上的React组件。通过<code>his.refs.xxx</code>指向一个声明了<code>ref</code>属性的组件。</p>
		<p>另外，render方法返回UI结构时，有时会出现超出虚拟DOM限制的需求，在render返回的组件实例上调用某些方法。通常，这对于应用中的数据流是不必要的。因为这些数据流总是确保最新的props被传递到每一个从<code>render()</code>输出的子级上。React提供<code>refs</code>属性来满足一些特殊情况，如操作DOM表现形式，在非React环境下使用React等。</p>
		<p>ReactDOM库提供了<code>render()</code>方法（不要和组件类的render方法搞混），在绑定组件类的同时返回元素的支撑实例。一般在最外层使用。</p>
		<p>React支持非常特殊的<code>ref</code>属性，可以绑定到render()输出的任何组件上。这个属性允许引用render()返回的响应支撑实例。使用时通过<code>this.refs.xxx</code>来获取支撑实例。在最新的React版本中这种方式已经不推荐，而推荐使用下面的ref回调属性。</p>
		<p>React支持在组件上绑定ref回调函数属性，这个回调会在组件被挂载后立即执行。被引用的节点将被传入作为输入参数，回调函数可以立即使用这个节点或者将之保存下来<code>(this.xxx = input)</code>为以后使用做准备。ref使用在DOM组件上时，会返回DOM节点，使用在React组件上时会返回组建对象实例。</p>
		<p>React建议在通常情况下，使用props和state向子组件发送消息，在场景不那么reactive时，使用<code>refs</code>。Ref的优点在于1）可以通过它调用组件类中的公共方法； 2）方便可靠地管理DOM； 3）Ref被自动管理，会和实例同生共死，不用考虑内存问题。在使用时，要注意以下问题：1）不要在render()方法中访问refs； 2）尽量通过在父级使用state避免refs的过度使用。</p>
		<h3 id="react_api">API</h3>
		<p>React JSX语法所提供的完全可以由React的API调用所替代。下面是react一些API的reference（主要摘自官方文档）</p>
		<h4 id="react_reactapi">React</h4>
		<p><span class="i">React</span>是React库的入口。使用预编译包时，React是全局的；如果使用CommonJS的模块规范，则通过<code>require</code>引入。</p>
		<p><span class="i">Component</span>是定义React组件的基本类，通过ES6的新特性，可以通过<code>extends</code>定义自己的组件类。</p>
		<ul>
			<li><code>React.createClass(specification)</code>方法创建一个组件类，并给出定义。定义中必须给出render方法。组件定义和声明周期参见别节。</li>
			<li><code>React.createElement(type, [props], [children ...])</code>创建一个指定类型的ReactElement，<code>type</code>可以为DOM原型或ReactClass。</li>
			<li><code>React.createFactory(type)</code>返回一个可以生成指定类型ReactElement的函数。</li>
			<li><code>React.cloneElement(element, [props], [children ...])</code>克隆一个已有的元素，并融合进新的<code>props</code>，是新增特性</li>
		</ul>
		<p>除此之外，还有<code>isValidElement</code>判断是否是合法元素，DOM方法更方便地创建DOM元素，<code>PropTypes</code>方法方便表单检验。React的<code>Children</code>对象提供了对<code>props.children</code>数据结构处理的工具，有<code>map</code>和<code>forEach</code>（与array的同名方法类似），以及<code>count</code>计算总数、<code>only</code>返回children仅有的子级元素和<code>toArray</code>方法将children数据专转为数组结构。</p>
		<h4 id="reactdomapi">ReactDOM</h4>
		<p>ReactDOM包使用在React应用的最外层，用于进行网页原生DOM操作（虽然官方不推荐），其中render方法时最为常用的。<code>ReactDOM.render(element, DOM container, [function callback]) </code>React用于将组件绑定在DOM上，若已被绑定，则会更新。在绑定时，会将DOM原内容清除。React预计会在未来支持将多个组件类绑定在同一个DOM内。</p>
		<p><code>unmountComponentAtNode(DOM container)</code>方法和<code>findDOMNode(React component)</code>方法分别用于移除DOM上的组件和找到组件所对应的DOM。其中后者是ref的替代用法（官方不推荐），且不能在无状态组件内使用。</p>
		<h4 id="reactdomserverapi">ReactDOMServer</h4>
		<p><code>renderToString</code>和<code>renderToStaticMarkup</code>方法用于将React元素渲染成HTML内容。其中后者不会添加额外的DOM属性。另外，两个方法都只能在服务器环境下运行。</p>
		<h4 id="reactcomponentapi">Component</h4>
		<p>Component实例在渲染时创建，并在之后的渲染中重复使用。可以在组件方法中用<code>this</code>访问。唯一一种外部访问的方法是储存<code>ReactDOM.render</code>的返回值，在其他组件里还能通过refs来实现同一效果。</p>
		<ul>
			<li><code>setState(function/obj nextState, [function cb])</code>方法<strong>合并</strong>nextState和当前state，支持回调函数。<strong><i>绝不要</i></strong>直接改变<code>this.state</code>。另外，除非在<code>shouldComponentUpdate()</code>中实现条件渲染逻辑，否则，该方法触发一次重绘。</li>
			<li><code>replaceState</code>方法和<code>setState</code>方法类似，区别在于该方法会先<strong>删除</strong>现有<code>state</code>。</li>
			<li><code>forceUpdate([function cb])</code>用在<code>this.props</code>和<code>this.state</code>未改变而仍需要重绘时调用，在手动修改<code>this.stat</code>e时也是如此。在该方法触发重绘时，子组件也会重绘（官方不推荐使用该方法= =）。</li>
			<li><code>bool isMounted()</code>方法判断组件是否已被绑定在DOM中，该方法多用在异步场景下。</li>
		</ul>
		<p><code>setProps</code>和<code>replaceProps</code>方法在新版本中已被删去。</p>
		<h3 id="react_others">标签/属性/事件</h3>
		<p>React支持几乎所有的html和svg标签，同时也支持所有标准属性。React中的属性都用驼峰命名，<code>class</code>和<code>for</code>属性改为<code>className</code>和<code>htmlFor</code>。React还添加了特殊的非DOM属性：</p>
		<ul>
			<li><code>key</code>作为唯一标识器，用于在渲染和差异检测时将顺序打乱后，确保组件还存在。</li>
			<li><code>ref</code>，介绍略。</li>
			<li><code>dangerouslySetInnerHTML</code>提供插入纯HTML字符串功能</li>
		</ul>
		<p>React对浏览器本地事件也有封装，且保证了浏览器兼容性。需要时，通过<code>nativeEvent</code>属性获得底层浏览器事件。通过<code>e.preventDefault()</code>可以避免事件冒泡。React的事件处理器在事件冒泡阶段出发，通过在事件后添加<code>Capture</code>（如<code>onClickCapture</code>）可以在捕获阶段处理事件。包括剪贴板、键盘、鼠标、焦点、表单、选择、触摸、UI、鼠标滚轮、多媒体、图片、动画、渐变事件（html5标准后添加了许多）。具体参加<a href="https://facebook.github.io/react/docs/events.html" target="_blank">官方文档介绍</a>。</p>
		<h3 id="flux">Flux/Redux</h3>
		<p>React为开发者提供了状态化组件的前端开发方式，这仅仅完成了MVC的V部分。Flux是Facebook提出了用于M和C部分的解决方案（实际上并不能称为M和C）。Flux是一种架构约定和架构模式。根据<a href="http://facebook.github.io/flux/docs/overview.html" target="_blank">文章</a>介绍一个Flux应用主要包含四部分：dispatcher，stores，views，actions。数据流在它们之间单向流动。如下图所示：</p>
		<img src="./img/flux.png" />
		<ul>
			<li>首先定义一些action creator方法。根据需要提供给dispatcher来分发。</li>
			<li>View部分通过交互触发Action。</li>
			<li>Dispatcher会分发出发的Action给所有注册的Store的回调函数</li>
			<li>Store回调函数根据Action的payload的部分更新自身数据，并触发一个change事件</li>
			<li>View会监听该事件，通过Store的方法拿到新数据，调用<code>setState</code>更新组件UI</li>
		</ul>
		<p>数据流在整个过程都是单向移动的，通过dispatcher来组织，由Store来维护所有状态。各部分分工明确。Dispatcher分发动作给Store注册的回调函数，官方提供了<a href="https://github.com/facebook/flux/blob/master/src/Dispatcher.js" target="_blank">Dispatcher.js</a>这个demo，与<a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc/js" target="_blank">flux-todomvc</a>作为使用样例。在样例中可以学到flux的简单使用。</p>
		<p>Redux提出于2015年，充分利用函数式编程的特点，简化了flux的的用法。将flux中的action和dispatcher进一步解耦，且将dispatcher从store中解耦， store成为了stateless function（state,action）=> state。现在的store只<strong>管理</strong>状态，从而增强了其可拓展性。</p>
		<p>在Redux中，action只是包含type和payload的对象，需要通过<code>store.dispatch()</code>方法来发送，action creator可以返回一个事件。Reducer用来处理action触发的对state的修改，形式类似于(oldState, action)=>newState。Redux将store视为唯一可信数据源，整个状态由一个store储存，由一个<strong>root reducer</strong>管理，在root reducer下，可以定义pure function管理状态树的各子树。</p>
		<p>Redux的Store提供<code>getState</code>方法获取state，提供<code>dispatch</code>方法发送action修改state，提供<code>subscribe()</code>方法注册回调函数监听state的修改。总结起来，<code>store.dispatch(action)</code>触发事件，action的type和payload说明事件情况；action触发指定root reducer，根据type和payload返回一个新的state；所有通过subsribe注册的监听函数会被调用，它们可以通过<code>getState</code>拿到新的state。</p>
		<h3 id="react_more">更多</h3>
		<p>React仍然没有一个系统且用户友好的学习教程（循序渐进且有demo）。个人认为效率较高的学习方式是先由<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank">阮一峰的博客</a>获得感性认识，再通过<a href="https://facebook.github.io/react/docs/getting-started.html" target="_blank">官方文档</a>和<a href="http://reactjs.cn/react/docs/getting-started.html" target="_blank">中文文档</a>的讲解获得全面认识。文档中也有demo展示。另外，<a href="http://react-china.org/" target="_blank">React中文社区</a>里会有一些不错的资源和讨论，<a href="https://www.gitbook.com/book/hulufei/react-tutorial/details">React入门教程</a>也有些补充，如Flux和Redux的介绍。</p>
		<p>另外，React一直处在发展中，直到现在也未推出1.0版，且框架特点和使用方法和typical MVC框架差别较大，学习成本较高。在学习文档的同时根据"Tutorial"的介绍训练，效果会更好。</p>
		<hr>
		<h1 id="angular">Angular JS</h1>
		<h3 id="angular_brief">简介与安装</h3>
		<p>Angular是比较新的技术，1.0版本发布于2012年。它采用MVVM架构，和MVC架构的React不同，View和ViewModel有着数据的双向绑定。Angular现由Google正式支持。</p>
		<p>Angular和React类似着眼点在前端的内容展示，不同于React尝试将UI界面组件化，Angular试图拓展HTML的功能来弥补与实际Web应用间的鸿沟。如：</p>
		<ul>
			<li>通过<code>{{}}</code>绑定数据</li>
			<li>使用DOM控制结构迭代或隐藏DOM片段</li>
			<li>将逻辑代码关联到DOM元素上</li>
			<li>将HTML做成可重用组件</li>
		</ul>
		<p>Angular具有很好的抽象性简化了应用的开发，且在CRUD应用中灵活性也很好，在DOM操作频繁且复杂的应用里，Angular并不适合。如游戏或是图形编辑器。这时使用React或者jQuery会好些。</p>
		<p>Angularjs可以使用npm或者bower进行安装，<code>bower/npm install angular</code>。之后便可以在<span class="i">node_modules</span>或<span class="i">bower_components</span>中找到。在<code>script</code>标签中引入即可。</p>
		<h3 id="angular_usage">使用</h3>
		<h4 id="angular_app">应用/控制器</h4>
		<p>Angular在后台通过定义AngularJS module确定应用；在前端通过<code>ng-app</code>指定Angular应用所绑定的位置（通常是html标签）。应用的所有controller也由模块包含。后台应用通过<code>angular.module(name, [])</code>构造，前者确定应用名，后者确定依赖模块。</p>
		<p>Angular支持创建自己的指令，使用<code>app.directive(name, function(){})</code>即可。自定义的指令可以通过元素名、属性、类名甚至注释来调用。在function部分的return中设置<code>restrict</code>为E A C M分别限制指令只能通过元素名、属性、类名、注释使用，可以叠用，默认为EA。</p>
		<p>应用可以有多个控制器处理不同功能，后台通过<code>app.controller(name, function(){})</code>定义，前端通过指定<code>ng-controller</code>绑定。Angular控制器是对象类型，有属性和方法，都可以通过<code>$scope</code>访问，其他方法可以通过<code>ng-click</code>等命令绑定在前端标签。应用和控制器的后台js文件可以外部通过<code>script</code>标签导入，建议放在body后。</p>
		<h4 id="angular_expression">Angular表达式</h3>
		<p>Angular的表达式写在双大括号内，把数据绑定在HTML内，和<code><strong>ng-bind</strong></code>有一样的效果，Angular表达式和js表达式很像，可以包含数组，对象，字符串、数字、运算等等，但是不支持条件判断和过程控制，且支持过滤器。</p>
		<h4 id="angular_model">数据模型</h4>
		<p>在controller中，可以为<code>$scope</code>变量赋值，从而定义应用的数据模型。在前端可以用<code>ng-bind</code>或<code>{{}}</code>使用已定义好的数据模型，或通过<code>ng-model</code>在前端输入域绑定数据。由于Angular采用数据双向板顶，修改输入域的值时，AngularJS的属性值也将<strong>同步</strong>更改。</p>
		<p>指定标签<code>ng-show</code>属性，可以在后台结果返回为<code>true</code>时显示标签。<code>ng-model</code>还可以为应用数据提供状态值，通过<code>$invalid, $dirty, $touched, $error</code>访问。</p>
		<p>同时在CSS类中，指定<code>ng-invald, ng-empty, ng-not-empty, ng-touched, ng-un-touched, ng-valid, ng-dirty, ng-pending, ng-pristine</code>类，可以让样式跟着模型状态改变。</p>
		<h4 id="angular_filter">过滤器</h4>
		<p>过滤器可以被添加在Angular语句中，用来格式化数据。有如下的一些可以选择：</p>
		<ul>
			<li><code>currency</code>格式化为指定货币；<code>date</code>格式化为指定日期；<code>number</code>格式化数字为字符串</li>
			<li><code>json</code>格式化为json字符串</li>
			<li><code>filter</code>筛选数组的子集</li>
			<li><code>limitTo</code>限制数组或字符串指定数目的长度</li>
			<li><code>lowercase/uppercase</code>格式化为大写或小写</li>
			<li><code>orderBy</code>使数组按序排列</li>
		</ul>
		<p>在使用时，通过一个管道字符<code> | </code>和一个过滤器添加到表达式中，如<code>{{price | currency}}</code>或<code>{{x in names | filter: ’Bill’ | orderBy:’name’}}</code>。filte支持自定义，在后台通过<code>app.filter(name, function(){return function(){}})</code>定义即可。</p>
		<h4 id="angular_service">服务</h4>
		<p>AngularJS中，服务是一个函数或对象，以<code>$</code>开头，可以在应用中使用（<strong>注意服务需要作为一个参数传递到controller中，需要先传入后使用</strong>），用来构造一些常用或是复杂的操作。AngularJS内建有30多个服务。</p>
		<p><code>$location</code>服务返回当前页面的地址信息等，有<code>absURL()</code>等方法使用。<code>$index</code>记录着<code>ng-repeat</code>的序号。<code>$timeout</code>有类似于<code>setTimeout</code>的作用；同理<code>$interval</code>对应着<code>setInterval</code>函数。</p>
		<p><code>$http</code>是Angular应用最常用的服务，用于向特定位置发送请求，并通过<code>then(function(){})</code>获取返回。发送的方法有get/delete/head/jsonp/patch/post/put等。也可以直接通过类似如下的方式发起请求：</p>
		<pre><code>var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $http) {
    $http({
        method : "GET",
        url : "welcome.htm"
    }).then(function mySucces(response) {
        $scope.myWelcome = response.data;
    }, function myError(response) {
        $scope.myWelcome = response.statusText;
    });
});		</code></pre>
		<p>返回值<code>response</code>有<code>config, data, header, status, statusText</code>等属性可以使用，可以在<code>then</code>方法的第二个参数指定错误处理函数。</p>
		<p>另外，可以通过<code>app.service(name,function(){})</code>自定义服务对象，然后在控制器中使用。常用服务一节还列举了一些其他服务。</p>
		<h4 id="angular_sql">Sql</h4>
		<p>由于Angular是一个前端的框架，需要后台如PHP，ASP等的辅助才可完成和数据库的交互，解决跨域问题的方法从略。</p>
		<h4 id="angular_dom">DOM事件</h4>
		<p><code>ng-disabled</code>和<code>ng-show</code>、<code>ng-hide</code>结合<code>ng-model</code>可以实现disabled和show/hide的效果。Angular还提供了许多DOM事件监听器。有<code>ng-blur, change, click, copy, cut, dbclick, focus, keydown, keypress, keyup, mousedown, mouseenter, mouseleave, mouseover, mouseup, paste</code>等。指定标签的这些属性即可为DOM事件绑定处理函数。Angular事件并不会重写HTML事件。</p>
		<h4 id="angular_form">表单验证</h4>
		<p>Angular的数据双向绑定使得表单验证更加简洁，结合HTML5的新特性。<code>required</code>属性要求不能为空，type限制输入的数据类型。在输入域改变的同时，<code>$untouched</code>, <code>$touched</code>, $<code>pristine</code>（未被修改过）<code>$dirty</code>（已被修改过）<code>$invalid</code> <code>$valid</code>等状态也随之改变。表格则有<code>$pristine $dirty $invalid $valid $submitted</code>等状态。使用样例如下</p>
		<pre><code>&lt;input name="myName" ng-model="myName" required>
&lt;span ng-show="myForm.myName.$touched && myForm.myName.$invalid">The name is required.&lt;/span>
</code></pre>
		<p>另外，在数据模型中一节已提到，Angular会新增CSS类在标签上，便于设置CSS样式。结合HTML5新属性，会有很不错的效果。在特殊情况，可以通过<code>app.directive</code>定义新的验证方法，添加在控制器的$parsers中，当输入域的值改变时做检验。具体添加方式可参见文档。</p>
		<h4 id="angular_router">路由</h4>
		<p>AngularJS通常用来构造单页网络应用。因此，URL采用<code>/#/name</code>的形式。在后台指定应用的依赖模块<code>ngRoute</code>，并通过<code>app.confi</code>配置<code>routeProvider</code>服务，使用依赖注入引入<code>routeProvider</code>服务，通过<code>when(path, object).otherwise(object)</code>按顺序定义所有路由。其中<code>when</code>的第二个输入参数是路由配置对象，有如下的参数可以配置：</p>
		<ul>
			<li><code>template</code>: 直接在<code>ng-view</code>中插入简单的HTML内容</li>
			<li><code>templateUrl</code>: 在<code>ng-view</code>中插入HTML模板文件</li>
			<li><code>controller</code>: 在当前模板执行的controller函数，生成新的<code>scope</code></li>
			<li><code>controllerAs</code>: 为controller指定别名</li>
			<li><code>redireTo</code>: 重定向地址</li>
			<li><code>resolve</code>: 指定当前controller所依赖的其他模块</li>
		</ul>
		<h4 id="angular_api">通用API函数</h4>
		<p><code>angular.copy</code>复制变量；<code>angular.element</code>；方法可以将元素包装为jquery对象；<code>equals</code>判断两个变量是否相等；<code>fromJson</code>反序列化一个JSON字符串；<code>isArray, Date, Defined, Element,  Function, Number, Object, String, Undefined</code>分别判断数据类型。<code>merge</code>方法合并两个变量；<code>noop</code>执行一个空函数。</p>
		<h3 id="dependency_injection">依赖注入</h3>
		<p>依赖注入是一种软件设计模式，用来为代码的依赖关系解耦。如杂项里介绍的，在需要其他依赖通过依赖的对象创建并传入。在Angular JS中引入服务，实际上就是依赖注入的一种语法糖。以输入参数的形式注入了控制器的依赖关系。这一点可以通过控制器的<code>$inject</code>来访问到。</p>
		<p>为了更好地理解，我们通过下面的代码创建一个注入器inject，来向函数中注入依赖：</p>
		<pre><code>var inject = {
    dependencies: {},
    register: function(key, value) {
        this.dependencies[key] = value;
    },
    resolve: function(deps, func, scope) {
        var arr = [];
        for (var i = 0 ; i < deps.length ; i++) {
            if (this.dependencies.hasOwnProperty(deps[i])) {
               arr.push(this.dependencies[deps[i]])
            }
        }
        console.log(arr);
        return function(){
            func.apply(scope || {}, arr);
        }

    }
}		</code></pre>
		<p>其中<code>dependencies</code>属性存储所有依赖，<code>register</code>方法注册依赖，<code>resolve</code>方法实现依赖注入，在之后可以模仿Angular用register注册几个模块，Angular的依赖注入服务<code>$inject</code>就是采取类似的思路完成依赖注入，先对函数使用<code>toString()</code>方法，之后通过正则匹配获得函数的输入参数，再加入依赖。</p>
		<h3 id="angular_extend_command">基础拓展指令</h3>
		<p>Angularjs通过<code>ng-directives</code>拓展了HTML。下面介绍了一些常用的directives。</p>
		<p><code><strong>ng-app</strong></code><strong>：定义一个AngularJS</strong>应用程序，一般绑定在html标签下。当然也可以在个别标签下绑定。范例：<code>&lt;html ng-app> &lt;div ng-app></code>。</p>
		<p><code><strong>ng-controller</strong></code>：指定特定<strong>控制器控制一个AngularJS应用程序</strong>，位于ng-app下，一般为应用下的自功能。范例：<code>&lt;body ng-controller=”MainCtrl”></code>。控制器端，<code>app.controller (‘MainCtrl’, function($scope){…})</code>。</p>
		<p><code><strong>ng-init</strong></code>： 在视图中<strong>初始化变量</strong>，范例：<code>&lt;div ng-init="book=[…]"></code>；可以同时初始化多个变量，引号内用分号隔开即可。通常使用时，在控制器内完成，不推荐使用<code>ng-init</code>初始化。</p>
		<p><code><strong>ng-bind</strong></code>：把<strong>变量绑定到视图</strong>中。范例：<code>&lt;span ng-bind="book">&lt;/span></code>。</p>
		<p><code><strong>ng-model</strong></code>：<strong>定义模型数据</strong>，绑定输入域值到模型数据，Angular支持数据双向绑定，可以轻松实现数据实时更新。范例：<code>&lt;input type="search" ng-model="criterial"></code></p>
		<p><code><strong>ng-repeat</strong></code>：<strong>遍历集合中的元素</strong>，用来<strong>迭代DOM元素</strong>。范例：<code>&lt;li ng-repeat="book in books"> {{book.name}}&lt;/li></code>. 使用过滤器可以实现过滤文本，改变格式，甚至实现搜索功能，<code>filter:criteria | orderBy</code>。利用<code>ng-repeat</code>结合<code>tr</code>和<code>td</code>可以方便地绘制表格。</p>
		<p><code><strong>ng-include</strong></code>：<strong>引入本地或跨域html文件</strong>，实现组件化的效果。</p>
		<p>还有一些<code>ng-directives</code>会根据条件真假决定是否是否展示，如<code>ng-show, ng-if, ng-invalid</code>等。其中<code>ng-show</code>和<code>ng-if</code>后有<code>$odd</code>和<code>$even</code>辅助条件判断(<code>ng-repeat</code>中)。</p>
		<p>还有<code>ng-click ng-href ng-show ng-hide</code>等。更多请参考文档。</p>
		<h3 id="angular_services">常用服务</h3>
		<p><code><strong>$scope</strong></code>：是带有属性和方法的对象，是控制器后台和前端模型数据的粘合剂。可以通过它定义数据，绑定元素等。在定义控制器时，可以作为输入参数传入，使得视图可以获取控制器属性。在大型项目中，<code>$scope</code>(作用域)往往不止一个，在使用时要注意区别开。所有应用都有一个<code>$rootScope</code>，可以在同一<code>ng-app</code>下的所有控制器中使用，是各个scope间的桥梁。</p>
		<p><code><strong>$watch</strong></code>：每次绑定一些东西(如<code>ng-model</code>)到UI时，就会向<code>$watch</code>队列插入一条<code>$watch</code>，它可以检测model里有变化的东西。需要注意的是，通过<code>$scope</code>定义的模型在绑定前不会加入<code>$watch</code>，且对象内的属性和数组内的元素也会作为一个个体添加如<code>$watch</code>队列中。<code>$watch</code>可以手动绑定。<code>$scope.$watch(”xxx”, function(oldvalue,newvalue){},true/false)</code></p>
		<p><code><strong>$digest</strong></code>：Angular拓展了浏览器等待用户交互的时间循环，生成一个称为Angular context的执行环境。在浏览器接收到可以进入Angular context的事件时，<code>$digest</code>将会遍历<code>$watch</code>，检查值的变化，至少一个<code>$watch</code>更新后，循环就会再次触发。$digest循环后，DOM相应发生变化。<strong>1</strong>个事件会触发<strong>1</strong>个<code>$digest</code>循环。</p>
		<p><code><strong>$apply</strong></code>：决定事件是否能进入Angular context。Angular会自动封装事件到一个<code>$apply</code>调用。因此jQuery没有调用<code>$apply</code>时，<code>$digest</code>循环不会执行。可以通过<code>scope.$apply()</code>强制一次<code>$digest</code>循环。</p>
		<p><code><strong>$q</strong></code>：提供了广义的异步回调机制，<code>$http</code>即在此基础上构建。<code>$q</code>有四种方法，<code>all([p1, p2])</code>方法合并多个<code>promise</code>为1个，<code>defer()</code>方法返回一个defer</code>对象，<code>reject(data)</code>触发后链的链式回调，用在<code>p.then().then()</code>的链式环境下。<code>when()</code>方法用来将数据包装成<code>promise</code>对象。<code>defer()</code>方法返回一个<code>defer</code>对象，<code>promise</code>属性是一个<code>promise</code>对象，<code>resolve</code>和<code>reject</code>方法分别触发成功和失败回调。</p>
		<p><code><strong>$log</strong></code>：向终端打印一些信息，<code>error(), info(), warn(), log()</code>方法分别打印不同级别的信息。</p>
		<p><code><strong>$cacheFactory</strong></code>：简单封装了一个缓存机制，调用时需要id和配置项如capacity。缓存实例有<code>info(), put(k, v), get(k), remove(k), removeAll(), destroy()</code>等方法。</p>
		<p><code><strong>$resource</strong></code>：Angular封装了一个更面向RESTful的模块代替<code>$http</code>使用，通过<code>$resource</code>的配置对象可以轻松实现CRUD操作。</p>
		<h3 id="angular2">Angular 2</h3>
		<p>Angular的开发团队在2015年7月推出Angular 2.0版本。对比1.x版本，Angular的2.0版本改动很大。2.0版本<strong>完全由Atscript书写</strong>，完全<strong>支持最新的ES6特性</strong>。AtScript改进自Typescript，后者由微软提出于2012年，简单来看是ES5+ES6+Type，在完全兼容Javascript的同时，提出了弱类型等更像传统编程语言的特性（又是一个新坑，日后再学）。目前（<span class="i">2016/7</span>）官网中并无Javascript版的2.0介绍。同时，一些诸如scope和controller的传统概念也被完全删除。<strong>组件化</strong>和<strong>面向对象</strong>成了2.0版本的最大特点。</p>
		<h4 id="componency">组件化</h4>
		<p>如上文所说，<code>controller</code>和<code>$scope</code>等概念被替代成组件和命令。控制器都由模板的方式定义为类的样式，如在下文的代码中，将组件（component）绑定到<code>&lt;angularComponent></code>标签上，所有使用组件都需经<code>bootstrap</code>挂载，且被页面导入（imported）：</p>
		<pre><code>//&lt;reference path="typeings.tsd.d.ts" />
import {Component, View, bootstrap} from 'angular2/angular2';
//Annotation section
@Component({
selector: 'angularComponent',
templateUrl: '/list.html’,
directives:  'importedComponent’
})
@View({
    templateUrl: 'component.html'
})
class angularComponent{
    constructor(){
        //code
    }
}
bootstrap(angularComponent);
</code></pre>
		<p><i>注意：上文应保存为.ts文件。</i></p>
		<p>Angular 2.0采用ES6自带的模块特性进行模块管理，并保证全局域安全。定义组件时（Angular 1.x中称为module）中通过<code>import from</code>的形式引入依赖，并通过Component注解完成控制器注册。而控制器本身是通过<code>export class xxxComponent{}</code>的形式定义的。在组件的构造函数中用输入参数的形式完成依赖注入。</p>
		<h4 id="angular2_extend_commonds">拓展命令</h4>
		<p>拓展命令的用法也做了较大改动。<code>ng-app</code>和<code>ng-controller</code>已经结合在模块的定义中。<code>ng-click</code>等事件删除前缀<code>ng-</code>，用<code> () </code>包裹，交由<code>component</code>方法处理。<code>ng-href</code>, ng-hide</code>等有HTML5标签对应的命令删去前缀<code>ng-</code>，用<code> [] </code>包裹。特别地，在路由中，a标签的路径已经不需要<code> # </code>。<code>ng-if</code>和<code>ng-for</code>等控制命令删去短划线采用驼峰命名，前方加星号<code> * </code>。<code>ng-model</code>双向绑定数据使用<code>[(ngModel)]</code>。</p>
		<p><code>{{}}</code>仍起着单向绑定的作用，过滤器使用管道<code>pipe</code>方法替代，<code>ngFor</code>中的变量用<code>let</code>声明。另外，过滤器中的<code>filter</code>和<code>orderBy</code>被删除，需要自行实现，<code>limitTo</code>改为<code>slice</code>。</p>
		<p>总体来说，Angular 2.0的出现也是顺应了时代的步伐，减少了繁冗的API，和对前端页面元素的过多装饰，改为更适合开发的模块化封装，通过修饰器约束组件的特性。同时保留了数据双向绑定等特点。无论如何，对于1.x的使用者来说，都要花上不少时间去适应全新的一切。更多的改变可以参考<a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html" target="_blank">官网的对比</a>。</p>
		<h3 id="angular_more">更多</h3>
		<p>Q 使用Angular JS和jQuery可以兼容吗？如何做到？</p>
		<p>A. Angular JS采用的MVVM的架构和jQuery的思路并不十分兼容，<a href="http://stackoverflow.com/questions/14994391/thinking-in-angularjs-if-i-have-a-jquery-background" target="_blank">建议使用前者，养成不用后者的习惯</a>。</p>
		<p>Angular JS 1.x版本有着较丰富的参考资料，官网有<a href="https://docs.angularjs.org/api/" target="_blank">API reference</a>和demo分析，<a href="http://www.w3schools.com/angular/" target="_blank">w3school的教程</a>也是不错的学习资料。另外还有<a href="http://www.cnblogs.com/whitewolf/category/404298.html" target="_blank">一些博客</a>和<a href="https://checkcheckzz.gitbooks.io/angularjs-learning-notes/content/chapter4/chapter4.html" target="_blank">gitbook</a>可供参考。Angular 2.0版本较新，Angular 2.0版本的内容主要参考自<a href="https://dzone.com/articles/typed-front-end-with-angular-2" target="_blank">DZone的一篇文章</a>，同时2.0版本有了<a href="https://angular.io/" target="_blank">新的官网</a>。</p>
		<hr>
		<h1 id="mangodb">MangoDB</h1>
		<p>MangoDB是node开发中经常用的数据库。这里做简单介绍。</p>
		<h3 id="mango_brief">简介</h3>
		<p>MangoDB是一个基于分布式文件存储的NoSQL数据库，介于关系数据库和非关系数据库间。NoSQL相比关系数据库而言，更适合与海量的网络应用数据，而SQL则更适合商业事务的存储与处理。基于NoSQL的MangoDB由C++编写，它将数据存储成文档，数据结构由键值对组成，类似于JSON对象。</p>
		<p>MangoDB的安装部署十分简单。去官网下载预编译包安装后，在根目录下创建数据目录即可。</p>
		<h3 id="mango_unit">基本单位</h3>
		<p>MangoDB中保留了database和索引的概念，将表视作集合，将数据记录行视作文档，将数据字段视作域，联表替换成文档嵌入，会自动将<code>_id</code>字段设置为主键。</p>
		<p>在MangoDB自身提供的shell下，<code>show dbs</code>可以查看所有已有的数据库。<code>db</code>可以查看当前的数据库对象，使用<code>use xxx</code>可以切换数据库。数据库通过名字来标识，<span class="i">admin, local, config</span>是保留的特殊数据库。</p>
		<p>文档是一个键值对，文档不需要设置相同的字段，且相同字段不要求相同数据类型。同时文档中的值甚至可以是其他的富数据类型。</p>
		<p>集合等同于RDBMS中的表，存在于数据库中，没有固定结构。当第一个文档插入时，集合就会被创建。Capped collection是固定大小的集合，是高性能的自动维护对象插入顺序的集合。需要显示的创建。</p>
		<p>数据库的信息储存在<span class="i">{dbname}.system</span>这个系统空间中，它的各字段包含着多种系统信息。其中个别字段支持修改或删除。</p>
		<h3 id="mango_database">连接/创建/删除数据库</h3>
		<p>在shell（支持JavaScript语法）下，通过命令<code>mongodb://localhost</code>连接数据库，若有用户名和密码，须写成<code>mongodb://username:password@hostname/dbname</code>的形式。</p>
		<p>使用<code>use</code>命令可以创建或切换到指定数据库。使用<code>db.dropDatabase()</code>删除当前数据库，使用<code>db.createCollection()</code>创建集合。<code>db.collection.drop()</code>删除集合。</p>
		<h3 id="mango_crud">CRUD操作</h3>
		<p><code>db.COLLECTION_NAME.insert(document)</code>插入文档，文档格式和JSON基本一样，也可以先将文档存储在变量中。若指定的集合不在数据库中，MongoDB会自动创建该集合并插入。<code>insert()</code>方法可以认为是不指定<code>_id</code>字段的<code>save()</code>方法。</p>
		<p><code>db.COLLECTION_NAME.update(QUERY, UPDATE,{upsert: BOOL, multi: BOOL, writeConcern: …})</code>. <code>query</code>是查询条件, <code>update</code>是update内容和更新操作符。常用操作符有<code>$set $unset $inc $rename $setOnUpdate $(query)</code>等. <code>upsert</code>意义是如果不存在update的记录是否插入新纪录，<code>multi</code>意为若找到多条是否更新多条。<code>save</code>方法则通过传入一个带有<code>_id</code>的文档，替换原id的文档。</p>
		<p><code>db.COLLECTION_NAME.remove(QUERY, JUST_ONE)</code>，第一个参数指定查询条件，第二个参数选择是否只删除一条。</p>
		<p><code>db.COLLECTION_NAME.find()</code>以非结构化方式显示所有文档。<code>pretty()</code>方法以格式化方式显示所有文档。<code>find()</code>方法可以接受条件作为where子句。同样用<code>{}</code>方式表示大小关系，有<code>$lt $lte $gt $gte $ne</code>操作符，这些操作符可以并列书写，如<code>{likes: {$lt: 200, $gt: 100}}</code>。用逗号隔开的键值表示并列的<code>AND</code>条件，用<code>$or</code>表示<code>OR</code>条件，以<code>$or:[{}{}]</code>的方式使用。同时<code>$type</code>操作符可以用于筛选特定类型的字段。</p>
		<p><code>limit()</code>方法同样可以跟在<code>find()</code>后面，类似于SQL语句中的<code>LIMIT</code>。<code>skip()</code>方法用于跳过<code>find(n)</code>方法得到的前n条文档。<code>sort()</code>类似于<code>ORDER BY</code>，通过<code>{KEY: 1/-1}</code>来控制特定字段的升降序。</p>
		<h3 id="mango_index">索引与聚合</h3>
		<p><code>db.COLLECTION_NAME.ensureIndex({KEY: 1/-1}. {background: true/false})</code>用来创建索引，提高搜索效率。<code>KEY</code>的位置可以指定多个字段，创建复合索引。第二个参数指定是否后台执行。</p>
		<p>集合还有<code>aggergate(middleware)</code>方法用于聚合，类似SQL的聚合函数。接受若干个中间件作为输入参数。中间件可以有<code>project，match，limit，skip，unwind，group，sort，geoNear</code>。分别修改输入文档的结构，过滤数据，跳过指定数目文档，拆分数组类型字段，文档分组，排序输出，按地理位置排序。<code>$group</code>类似SQL中的<code>group by</code>，需要指定<code>_id</code>和输出字段名。聚合表达式有<code>$sum, $avg, $min, $max, $first, $last, $push, $addToSet</code>.</p>
		<h3 id="mango_others">其他</h3>
		<p>可以通过应用ObjectId的方式嵌入文档实现关系。当引用在不同的数据库、集合、文档时，通过DBRefs引用外部内容，有操作符<code>$ref</code> <code>$id</code> <code>$db</code> 可以使用。</p>
		<p>查询的<code>explain()</code>和<code>hint()</code>方法分别用来提供查询信息和强迫MongoDB使用特定索引查询。</p>
		<p>复制：在使用mongod启动时指定<code>--replSet</code>参数设置副本集。在客户端通过<code>rs.add</code>加入。</p>
		<p>分片：通过<span class="i">Shard, Config Server, Query Router</span>完成分割数据的功能，具体略</p>
		<p>备份：使用mongodump工具指定要备份的数据库，使用mongorestore数据恢复</p>
		<hr>
		<h1 id="socketio">Socket.io</h1>
		<p><strong>TODO</strong></p>
		<hr>
		<h1 id="jade">Jade</h1>
		<h3 id="jade_brief">简介</h3>
		<p>Jade实际上属于模板引擎的一种，模板引擎可以便于HTML文档的书写。Jade受Haml简写法的影响，它是用JS实现的，可以供Node.js使用，具有高度可读性。Jade通过行首的标签和缩进控制文档结构。通过过滤器可以书写less、markdown、coffee-script等内容。同时，jade也有其他语言的实现，包括php，scala，ruby，java等，可以实现前后端渲染的统一。</p>
		<p>通过<code>npm install jade</code>下载jade，指定全局选项-g后，可以使用jade命令。</p>
		<h3 id="jade_lang">语法</h3>
		<p>Jade的语法和markdown也有许类似。</p>
		<p>Jade使用<code>doctype html, xml, transitional, mobile, basic, 1.1</code>...代替最外围的标签结构，默认为html5，在<code>doctype</code>下书写html开始文档。</p>
		<p>Jade中，将标签放在行首，它能自动识别自闭标签如<code>&lt;input></code>。标签后加空格，可以添加标签文本，嵌套标签时，换行使用缩进即可。当标签内容很多时，在标签后添加句点. 配合缩进或者在每段前加入<code> | </code>将下面的文本转为plain text类型。</p>
		<p>Jade中使用<code>()</code>分割属性，<code>()</code>内的内容和html标签一致，可以用空格或逗号隔开。注释使用<code>//</code>书写，在<code>//</code>后添加短横线<code>-</code>，可以将注释视作jade注释。同时支持IE版本注释。</p>
		<p>使用类似于css选择器的方法，用<code>#</code>和句点标注id和class，在标签后紧跟不带空格，如果没有标签名，默认为<code>div</code>标签。</p>
		<p>使用<code>#</code> <code>{}</code>使用之前用<code>var</code>声明的变量，变量中的特殊字符会被转义，使用<code>!</code>代替<code>#</code>表示不转义。以短横线<code>-</code>开始非缓冲代码，如<code>for</code>循环结构。用紧跟标签的<code>=</code>表示缓冲代码，会默认转义内容，<code>!=</code>表示不转义。循环结构用<code>each VAL[,KEY] in OB</code>表示。选择结构用<code>case when</code>表示类似于<code>switch</code>，可以多个<code>when</code>执行同一语句块。</p>
		<p>Jade允许使用<code>extends</code>结合<code>block</code>关键字预定义一个模板文件给其他模板调用，实现模板的集成。<code>includes</code>允许我们插入另一个jade文件到当前文件中，从而实现多重继承，除了<code>.jade</code>文件还可以引用<code>.html</code>甚至<code>.css</code> <code>.js</code>以及纯文本文件等。可以通过过滤器引入其他模板格式的模板。</p>
		<p>通过<code>mixin name(args)</code>可以定义代码片段，通过<code>+name(args)</code>的形式引用，类似于函数的用法。Mixin中还支持<code>attribute</code>，可以在<code>+name(args)</code>后跟其他的属性。同时在mixin中指定了<code>block</code>时，可以使用<code>include</code>那样的块。</p>
		<p>使用过滤器如<code>:markdown</code>可以导入其他格式的模板。下面是一个使用jade模板引擎的样例：</p>
		<pre><code>doctype html
html(lang="en")
  head
    - var name = 'Jade'
    title= name
    meta(charset="utf-8")
    link(rel="stylesheet", type="text/css" href="/stylesheets/style.css")

  body
    h1 Jade - node template engine
    #container.col
      if name === 'Jade'
        p #{name} is very cool
      else
        p Get on Jade
    footer
      p.
        Jade is a terse and simplae
        templating language with a
        strong focus on performance
        and powerful features.</code></pre>
		<p>更多参考<a href="http://blog.jayself.com/2014/07/28/Jade/" target="_blank">中文教程</a>，还可以进行<a href="http://naltatis.github.io/jade-syntax-docs/" target="_blank">在线演示</a>。另外，由于jade商标已被其他的商业公司注册，<strong>jade-lang现已更名为pug</strong>，官网已更换为<a href="https://pugjs.org/" target="_blank">pugjs</a>。</p>
		<hr>
		<h1 id="d3">D3.js</h1>
		<h3 id="d3_brief">简介</h3>
		<p>D3全称<span class="i">Data-Driven Document</span>，是使用javascript的实现数据可视化的函数库。它是一个颇受关注的开源项目，官网为<a href="http://d3js.org" target="_blank">http://d3js.org</a>。它不仅可以完成dom元素操作，更可以在画布上完成图表的绘制。</p>
		<p>HTML中提供两种标签<i>SVG</i>和<i>Canvas</i>来完成这个功能。其中SVG使用XML格式定义图形，绘制矢量图；Canvas是H5提出的新标签，用JS绘图，绘制的是位图。D3的许多图形生成器都是只支持SVG的。因此下面先对SVG做简要介绍。</p>
		<h3 id="svg">SVG介绍</h3>
		<p>SVG同XML格式定义二维图形和绘图程序，在改变尺寸时不会损失图像质量，是W3C的标准之一。svg可以通过<code>embed</code>，<code>object</code>或<code>iframe</code>标签嵌入进HTML页面中，并按照后来居上的规则渲染。下面的内容糅合自<a href="http://www.w3school.com.cn/svg/index.asp" target="_blank">w3school</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank">MDN的SVG教程</a>。</p>
		<h4 id="svg_axis">坐标</h4>
		<p>SVG使用的坐标系统以左上角为原点，x轴正方向向右，y轴正方向向下。点或形状的左上角以坐标的形式定位。SVG中的长度不标注单位时表示使用相对大小，默认为用户单位。</p>
		<h4 id="svg_shape_path">形状与路径</h4>
		<p>SVG有许多<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element" target="_blank">预设的形状元素</a>。其中常用的有<code>&lt;rect> &lt;circle> &lt;ellipse> &lt;line> &lt;polyline> &lt;polygon> &lt;path></code>。<code>&lt;rect></code>有<code>x, y, width, height, rx, ry</code>(圆角半径)等属性。<code>&lt;circle></code>有<code>r, rx, ry</code>三个属性，<code>&lt;ellipse></code>有<code>rx, ry, cx , cy</code>(圆心位置)四个属性，<code>&lt;line></code>有<code>x1, x2, y1, y2</code>四个属性。<code>&lt;polyline></code>将转折点系列放在<code>points</code>属性中，<code>&lt;polygon></code>和polyline类似，不同的是polygon路径最后一个点会返回第一个点。<code>&lt;path></code>通过<code>d</code>属性绘制路径。</p>
		<p><code>&lt;path></code>常用于绘制复杂的图形。<code>d</code>属性由命令和位置组成。命令由一个字母表示，大写字母表示绝对定位，小写字母表示相对定位。<code>M [x, y]</code>命令表示将画笔当前位置移动到<code>(x, y)</code>，但并不画线。使用<code>L [x, y] H x V y</code>可以画线，后者表示水平和垂直线。<code>Z</code>命令表示添加一条线段到路径起点闭合路径。<code>C [x1 y1, x2 y2, x y]</code>绘制三次贝塞尔曲线，<code>S [x2 y2, x y]</code>命令延长三次贝塞尔曲线，<code>Q [x1 y1, x y]</code>绘制二次贝塞尔曲线，<code>T x y</code>延长二次贝塞尔曲线。<code>A [rx ry x-asis-rotation large-arc-flag sweep-flag x y]</code>绘制弧形，<code>rx ry</code>分别表示椭圆长短轴长度，<code>x-axis-rotation</code>表示椭圆旋转角度，<code>large-arc-flag</code>表示是否选择较长弧，<code>sweep-flag</code>表示选择画弧旋转方向，<code>x y</code>表示终点坐标。</p>
		<h4 id="svg_fill_stroke">填充与边框</h4>
		<p>SVG使用属性<code>fill</code>和<code>stroke</code>属性完成填充和描边上色，颜色命名可以已使用css颜色命名方案。<code>fill-opacity</code>和<code>stroke-opacity</code>分别控制两者的透明度。描边里，<code>stroke-width</code>确定描边宽度，<code>stroke-linecap</code>指定线段两端格式，有<code>butt, square, round</code>可以选择，<code>stroke-linejoin</code>指定线段连接处格式，有<code>miter, round, bevel</code>可以选择。<code>stroke-dasharray</code>指定虚线的空白和实线长。另外，还有<code>fill-rule</code>定义重叠位置上色，<code>stroke-miterlimit</code>定义绘制miter效果的情况，<code>stroke-dashoffset</code>定义虚线开始位置。另外，可以通过css修饰svg标签，同样有内联、内部定义和引入外部css文件三种方式。需要注意的是，内部定义许放在svg标签的<code>&lt;def></code>中，使用<code>fill</code>和<code>stroke</code>表示填充和描边。</p>
		<p><code>&lt;pattern></code>元素中，可以包含任何之前包含的基本形状。它定义了单元系统和大小位置。<code>x</code>和<code>y</code>属性定义了pattern的起始点，<code>width</code>和<code>height</code>定义了下一个box要跨过多远。<code>patternUnits</code>用于描述模式本身的单位系统。<code>patternContentUnits</code>描述了基于基本形状的单元系统。对象改变大小时，pattern对象会自适应，但是对象里面的内容不会。pattern的单位系统混合使用了<code>userSpaceOnUse和objectBoundingBox</code>，易混淆。详细讨论略。</p>
		<p>文字写在<code>&lt;text></code>元素内，通过<code>x</code>和<code>y</code>属性确定位置。<code>&lt;tspan></code>用来强调文本，有<code>x, dx, y, dy, rotate, textLength</code>等属性，须放在<code>&lt;text></code>或<code>&lt;tspan></code>下使用。<code>tref</code>元素允许通过<code>xlink:href</code>引用已定义的文本。<code>textPath</code>利用<code>xlink:href</code>获得一个任意路径，让字体环绕路径。<code>text-anchor</code>属性可以改变文字的对齐方式，可以选择<code>start, middle</code>和<code>end</code>。<code>&lt;text</code>中的内容可以用字体相关的属性修饰，如<code>font-size</code>。</p>
		<h4 id="svg_transform_distord">渐变与变形</h4>
		<p><code>&lt;linearGradient></code>通过绑定id为标签添加渐变效果，通过<code>&lt;stop></code>子标签设置关键位置，在其中指定<code>offset, stop-color, stop-opacity</code>属性。同时渐变的走向由<code>linearGradient</code>标签的<code>x1, x2, y1, y2</code>决定。径向渐变由标签<code>&lt;radialGradient></code>完成，在属性里用<code>cx, cy, r</code>决定渐变的范围，由<code>fx, fy</code>决定渐变的中心。渐变的格式可以用CSS格式定义。整个渐变定义写在<code>defs</code>标签内，通过<code>fill=url(#gradient2)</code>的形式引用。</p>
		<p>两种渐变都有<code>spreadMethod</code>属性控制渐变到达终点的行为，可以为<code>pad, reflect, repeat</code>几种选择。同时<code>gradientunits</code>属性描述渐变大小和方向的单位系统。</p>
		<p><code>&lt;g></code>元素通过为之赋属性将属性赋给整个元素集合。元素的<code>transform</code>属性有许多变换方式，<code>translate(x,y)</code>将元素移动到<code>x,y</code>的位置，<code>rotate(x)</code>旋转x°，<code>skewX</code>和<code>skewY(x)</code>可以将矩形斜切为菱形，<code>scale()</code>可以以一定比例缩放元素。<code>Matrix(a,b,c,d,e,f)</code>可以指定通用的变形。</p>
		<h4 id="svg_cut">剪切与遮罩</h4>
		<p>clipping用来移除编出定义元素的部分内容，即剪切。masking允许使用透明度和灰度遮罩计算的的软边缘。<code>&lt;clipPath></code>通常定义在<code>defs</code>标签里，通过元素的<code>clip-path</code>属性引入，在<code>clipPath</code>标签中的形状最终不会绘制，它的像素只用来确定哪些像素需要呈现出来。剪切外的形状将彻底消失。利用遮罩可以将一个元素淡入淡出，同样<code>mask</code>标签内的形状确定了它的影响范围，但渐变性质将会反映到引入它的形状上。Mask中标签属性可以用<code>fill-opacity</code>和<code>stroke-opacity</code>指定透明度。</p>
		<h4 id="svg_filter">滤镜</h4>
		<p>SVG中有着相当丰富的滤镜。滤镜需要写在<code>&lt;filter></code>标签内，有<code>feBlend</code>,<code> feColorMatrix</code>, <code>feComponentTransfer</code>, <code>feComposite</code>, <code>feConvolveMatrix</code>, <code>feDiffuseLighting</code>, <code>feFlood</code>, <code>feGaussianBlur</code>等许多，它们有着不同的配置方式，且有的原理并不好理解。这里不做过多介绍。具体可参见<a href="https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#filters" target="_blank">W3C的filters部分</a>介绍</p>
		<h4 id="svg_others">其他</h4>
		<p>SVG中可以通过<code>&lt;font></code>定义一个字体，该标签中有<code>font-face, missing-glyph, glyph</code>等标签可以使用。在<code>font</code>定义完成后，在<code>text</code>的<code>font-family</code>属性中即可引入自定义字体。实际上，css3中已有了引用远程字体的<code>@font-face</code>。SVG中也有<code>image</code>元素，支持PNG, JPG和SVG图像，引入后可以对之进行SVG的一些操作。<code>foreighObject</code>元素用来引入任意XML。</p>
		<h3 id="d3_dom">DOM操作API</h3>
		<p>D3提供了许多可用的API，从基本的<code>array</code>到DOM操作再到SVG绘图十分丰富。<a href="https://github.com/d3/d3/wiki/API-Reference" target="_blank">官方API reference</a>做了详尽的解释。</p>
		<p>D3对DOM的操作和jquery类似，有一个全局对象d3，先选取元素再对元素做操作。由于d3的方法通常返回也是包含<code>htmlElement</code>的d3对象，因此支持链式调用。D3采用CSS3的<strong>选择器</strong>语法选择元素，包含标签、类名、伪类、id名、<code>attribute([type=text])</code>或容器(<code>parent, child</code>)。同时D3的选择器支持逻辑运算即<code>AND, OR</code>。在选取元素后，D3通过对之<strong>操作</strong>完成功能。<strong>操作</strong>包括获取、设置属性, <code>style, properties, HTML, text</code>等等，或是添加移除元素。D3中可以直接对<strong>选择集(<code>selection</code>)</strong>做操作，或是<code>each</code>遍历操作。</p>
		<p>在选择元素时，d3提供了<code>d3.select</code>和<code>d3.selectAll</code>两种方法。它们都支持选择器和节点两种输入参数。后者可能会在时间监听中以<code>d3.select(this)</code>的形式出现。</p>
		<p>选择集通常是元素的数组。可以通过D3的操作函数统一对选择集做操作。<code>Selection.attr(name[ ,value])</code>获取或修改选择集的特定属性。<code>value</code>为常量时，所有属性一致，<code>value</code>为<code>function</code>时，接受数据<code>datum</code>，索引<code>i</code>和<code>this</code>只想当前的DOM元素，函数返回值将替代源值。当<code>value</code>为<code>null</code>时，视作<code>removeAttr</code>。<code>name</code>可以为<code>object</code>类型。</p>
		<p><code>Selection.classed(name[, value])</code>是用来修改<code>class</code>属性的attr的特殊版本。<code>name</code>中用空格隔开或输入object可以同时设定多个classes。与上面类似，<code>value</code>可以为function。<code>value</code>为<code>false</code>时，等同于<code>removeClass</code>。只有<code>name</code>时，返回选择集中第一个非空元素是否有该类。</p>
		<p><code>Selection.style(name[, value[, priority]])</code>和以上类似，用来设置和获取CSS格式。<code>name</code>可以输入对象, <code>value</code>可以输入函数。没有<code>value</code>时，返回计算后的CSS格式。</p>
		<p><code>Selection.property(name[, value])</code>用来修改/获取<code>attr</code>获取不到的属性值，如<code>text</code>区域的<code>value</code>，<code>checkbox</code>的<code>checked</code>属性或<code>__data__</code>等。使用方式同上。</p>
		<p><code>Selection.text([value])</code>用来获取修改选择集的文本值, 使用方式同上<code>。Selection.html([value])</code>用来获取<code>innerHTML</code>。区别在于前者基于<code>textContent</code>，后者基于<code>innerHTML</code>。</p>
		<p><code>Selection.append(name)</code>在当前元素后添加一个子元素作为选择集的最后一个结果。数据将继承当前元素。同样<code>name</code>接受返回DOM元素的函数，此时函数可以接受<code>datum</code>、<code>i</code>和<code>this</code>。<code>name</code>为<span class="i">string</span>时，将继承所在父空间的namespace。</p>
		<p><code>Selection.insert(name[, before])</code>在选择集中<code>before</code>选择的元素前插入元素。如果<code>before</code>未找到匹配，将在最后插入。<code>before</code>可以是选择器或返回DOM元素的函数。</p>
		<p><code>Selection.remove()</code>删除当前选择集。返回选择集本身，因此<strong>也可以链式调用</strong>。</p>
		<p>关于数据绑定，有<code>selection.data([values[, key])</code>, values可以是数组或是返回数组的函数。在<code>key</code>未指定时，<code>values</code>和<code>selection</code>中的元素一一对应。在绑定后写入在元素的<code>__data__</code> property中。函数返回<code>update</code>选择集。提供了<code>enter</code>和<code>exit</code>方法获取<code>enter</code>和<code>exit</code>选择集。<code>key</code>参数规定了<code>values</code>和<code>selection</code>元素的绑定方式，具体参见<a href="https://github.com/d3/d3/wiki/Selections" target="_blank">wiki</a>。<code>data</code>方法不能用来清除已有的绑定数据。通过<code>Selection.merge(name)</code>和已知<code>selection</code>合并。</p>
		<p><code>Selection.datum([value])</code>设置或获取绑定数据，简化版的<code>data</code>方法。可以理解成上文中<code>property</code>方法的子集。由于没有绑定过程，因此也没有<code>enter</code>和<code>exit</code>选择集。<code>value</code>可以接受常量或是函数，用法类似其他使用<code>value</code>的方法。它还能和W3C的<code>dataset</code>属性互动。和<code>data</code>不同的是，<code>datum</code>绑定为元素们绑定相同的数据，且新插入的元素也会具有相同的<code>datum</code>。而<code>data</code>则是将数组中的各元素一一绑定在一个个元素上。</p>
		<p><code>Selection.enter()</code>返回<code>enter</code>选择集：未和<code>data</code>匹配的占位符。只定义在<code>update</code>选择集后，其后只能跟<code>append, insert, select</code>和<code>call</code>方法，用在数据较多时，通常添加元素并赋予属性值。<code>Selection.exit()</code>返回<code>exit</code>选择集：未和<code>data</code>匹配的节点，其后可以跟普通的操作方法，但通常使用<code>remove()</code>删除多余元素。两者相互对应。</p>
		<p><strong><i>注：<code>update, enter</code>和<code>exit</code>和选择集是较难理解的一部分。这些概念出现在绑定数据时，<code>update</code>记录更新的选择集，<code>enter</code>和<code>exit</code>分别用于两者并不等量的情况。Ourd3js中的图会起到帮助理解的作用。应用模板的介绍参见<a href="http://www.ourd3js.com/wordpress/?p=841" target="_blank">教程</a></i></strong></p></h4>
		<p><code>Selection.filter(selector)</code>用来过滤选择集，同上面的函数，<code>selector</code>除了选择符外还可以是返回DOM节点的函数，函数接受<code>d</code>和<code>i</code>两个参数，<code>this</code>表示当前DOM节点。</p>
		<p><code>Selection.sort([comparator])</code>，根据<code>comparator</code>函数排序选择集，再重新插入到文档的元素中，并返回新的选择集。排序非稳定。<code>Selection.order()</code>可以迅速按照<code>order</code>重排元素。</p>
		<p><code>Selection.on(type[, listener[, capture]])</code>用法和jquery类似，<code>listener</code>为函数，可以接受<code>datum</code>及<code>index</code>两个参数并使用<code>this</code>。其余的还有<code>d3.event</code> <code>d3.mouse(container)</code> <code>d3.touch(container[, touches], id)</code> <code>d3.touches</code>事件可以利用。通过这个方法，可以为d3创建的图表添加交互式操作。</p>
		<p><code>Selection.transition([name])</code>开启一个渐变过程，使得上面的这些操作能够有渐变效果。关于<code>transition</code>更多选项见<a href="https://github.com/d3/d3/wiki/Transitions" target="_blank">API的transition</a>部分。<code>Selection.interrupt([name])</code>可以立即停止一个渐变，没有<code>name</code>时会停止当前渐变。</p>
		<p>最后<code>selection.each(fucntion)</code>和<code>selection.call(function[, args])</code>分别对选择集每个元素操作和调用特定函数对选择集处理。<code>Selection.empty(), Selection.node(), Selection.size()</code>返回选择集的一些性质。</p>
		<h3 id="d3_scale">比例尺API</h3>
		<p>比例尺常用在d3制图当中，在d3的v3.x版本中，位于scale子模块内，在v4.0版本中抽离了出来作为单独模块使用。D3中的比例尺有连续比例尺、序列比例尺、临界比例尺、分位数比例尺、量化比例尺与序数比例尺。这些比例尺都有定义域和值域分别称为<code>domain</code>和<code>range</code>。使用时指定两者的范围便可得到映射关系。而以上的比例尺则是根据定义域和值域类型区分的。</p>
		<p>线性比例尺将连续区间映射到另一连续区间。通过<code>d3.scale.linear()</code>初始化，在4.0中通过<code>scaleLinear()</code>初始化，链式定义<code>domain([numbers])</code>，<code>range([numbers])</code>即可。<code>linear(x)</code>得到y，<code>linear.invert(y)</code>可以得到x。<code>tick([count])</code>设置刻度数，默认为<code>10</code>，<code>tickFormat(count, [format])</code>设置刻度格式。注意，定义域和值域都可以定义成多段，类似于分段函数。<code>d3.max</code>和对<code>d3.min</code>方法分别可以计算数组内的最大/小元素。</p>
		<p>其他的比例尺还有<code>identity()</code>恒等比例尺，<code>domain</code>和<code>range</code>永远一致，且默认值为<code>[0, 1]</code>，类似于恒等变换。<code>pow()</code>和<code>log()</code>也是两种特殊的连续比例尺，即指数和对数变换，用法与<code>linear</code>一致。time比例尺是v4.0中新的比例尺，是以时间为定义域的连续比例尺。</p>
		<p>序数比例尺的定义域是离散的。类似<code>linear()</code>，有<code>domain</code>和<code>range</code>方法。同时还有<code>rangePoints</code>, <code>rangeRoundPoints</code>, <code>rangeBands</code>, <code>rangeRoundBands</code>这些<code>range</code>的替代方法修饰输出的比例尺。这些在v4.0中分别作为了独立的比例尺类型。</p>
		<p>其余的比例尺还有<code>quantize()</code>，定义域是连续的，值域是离散的。根据值域等比例划分定义域，有<code>domain</code>, <code>range</code>, <code>invert</code>等方法。其他的比例尺还有和<code>quantize</code>很像的<code>quantile</code>以及<code>threshold</code>比例尺。具体见文档。V4.0中还有序列比例尺，它的range是根据插值器写死的且不可配置，利用已有的颜色插值器可以生成超酷的颜色比例尺。具体见<code>d3-scale-chromatic</code>。</p>
		<p>这些比例尺都有<code>copy</code>方法，方便地复制给其他比例尺变量。</p>
		<h3 id="d3_axis">坐标轴API</h3>
		<p>V3.x中作为svg的一个组件，V4.0中提出为单独组件。<code>d3.svg.axis()</code>创建一个默认的轴，在V4.0中可以直接使用<code>d3.axis()</code>。定义后通过<code>axis(selection)</code>绑定在<code>svg</code>或是<code>g</code>元素上，通常采用<code>.append(g).attr(transform ,translate(x,y)).call(axis)</code>的形式使用。</p>
		<p><code>axis.scale([scale])</code>方法设置比例尺，从而将刻度与实际长度对应。<code>axis.orient([orientation])</code>选择坐标轴方向和刻度方向，默认为<code>bottom</code>。<code>axis.tick([args])</code>方法指定刻度属性，参数将传递给<code>scale.tick()</code>方法生成刻度值。<code>axis.tickValues([values])</code>设置/获取刻度值。<code>axis.tickSize([inner, outer])</code>设置内外部刻度尺寸。另外外有<code>tickPadding</code>, <code>tickFormat</code>等方法。V4.0中直接通过<code>d3.axisTop, d3.axisRight, d3.Bottom, d3.Left</code>设置方向</p>
		<h3 id="d3_transition">渐变API</h3>
		<pD3通过<code>transition()和<code>ease()</code>完成渐变和动画效果。在V3.x版本中主要由<code>transition()</code>完成渐变，<code>ease</code>模块添加于4.0版本。渐变通过<code>d3.transiton([selection], [name])</code>或者<code>selection.transition()</code>初始化，以后者为主。方法返回<code>transition</code>对象，并启动过渡。<code>transition.duration([duration])</code>指定过渡时间，<code>ease([value[, args]])</code>方法指定过渡方式，<code>delay([dalay])</code>方法指定延迟时间。<code>ease</code>方法常用的有<code>linear, circle, elastic, bounce, cubic, exp, poly(k), sin</code>等缓动函数。V4.0版本中，ease单独拿出来作为了一个模块，有更丰富的用法，可参加V4.0 API文档。></p>
		<p><code>transition</code>后还可以跟<code>attr</code>, <code>style</code>, <code>text</code>方法做缓动变化。<code>tween</code>方法介绍见API文档，这里从略。<code>transition</code>中同样可以通过子选择集创建子过渡，也有类似于<code>selection</code> 的<code>each, empty, node, size, call</code>等方法。</p>
		<p><strong>注：<code>transition</code>在使用时和<code>selection</code>有很大相似之处。但实际上，两者类型不同，<code>selection</code>对应d3的选择集对象，<code>transition</code>对应d3中的渐变对象。如<code>on</code>方法可以跟在<code>selection</code>后却不能更在<code>transition</code>后。另外，<code>transition</code>可以通过<code>selection.transtion()</code>方法获取。</strong></p>
		<h3 id="d3_layout">布局API & 形状API</h3>
		<p>布局API起到将数据转换为用于绘图的关键作用。它更适合那些希望有更开放设计空间而不仅是利用Highcharts或是Echarts的用户。D3的V3.x版本的layout模块里提供了12个基本布局：饼图，力导向图，弦图，树状图，集群图，捆图，打包图，直方图，分区图，堆栈图，矩阵树图，层级图。其中层级图不能直接用来使用。它们的作用是将数据转成更适合这些图展示的新的数据。V4.0中这些子类型图都独立出来作为单独模块。这些图的样子可以参见官网<a href="http://d3js.org" target="_blank">d3js.org</a>。</p>
		<p>布局API输出的是格式化后的用户数据，还需要svg的部件形状AP来画出图形。部件的各部分同样在V4.0中抽出独立。有<code>arc, area, chord, diagonal, line, symbol</code>等几种帮助用户轻松画出svg中复杂的<code>&lt;path></code>。</p>
		<h4 id="d3_pie">饼状图</h4>
		<p>饼图布局可以将数据转成有着起始和终结角度的弧，然后轻松地通过arc shape做出饼图。实际上可以直接通过<code>arc</code> shape完成这一功能。通过<code>d3.layout.pie()</code>完成布局初始化，之后由<code>pie(values[, index])</code>为饼图布局赋值。返回的每一个对象都有着<code>value, startAngle, endAngle, padAngle, data</code>5个属性。返回元素的排序和原数组一致。此外，<code>pie</5个属性。返回元素的排序和原数组一致。此外，<code>对象还有<code>value([accessor])</code>方法预处理数组数据，<code>sort([comparator])</code>方法为数据排序，保留原index，排序函数可以接受键值对，同时可以使用<code>d3.descending</code>和<code>d3.ascending</code>。另外<code>startAngle, endAngle</code>和<code>padAngle</code>方法可以获取/设置起始，终结，填充角度值。</p>
		<p>通过上面API得到的piedata通过弧生成器即可得到饼图各部分。<code>d3.svg.arc()</code>可以构造一个新的弧生成器，<code>arc.innerRadius([radius])</code>和<code>arc.outerRadius([radius])</code>及<code>cornerRadius([radius])</code> padRadius([radius])</code>分别设置内环，外环，边角半径，同样可以输入函数。<code>startAngle()</code>，<code>endAngle()</code>和<code>padAngle()</code>也是类似的道理。通过<code>centroid(args)</code>还可以得到产生弧的中心，便于插入文本描述。</p>
		<h4 id="d3_force">力导向图</h4>
		<p>力导向图是一种互动性很强的可视化图。这种图中，节点间用连线连接，连线长度几乎相等，且不相交。节点和连线间都有里的作用，这个力是根据节点和连线运动轨迹计算的。根据里的作用来不断计算节点和连线的轨迹，最终达到能量最低的稳定态。可以看到，很适合拓扑图，实际生活关系图等多对多关系的绘制。</p>
		<p>从上面描述可以知道，力导向图的数据由节点间的连接情况组成。同上节，需要用到layout中的force部件。force创建的布局是有状态的，所以对于给定的力导向布局，只能与单一数据集绑定。通过<code>d3.layout.force()</code>初始化力导向实例。有<code>links, nodes, size, friction, strength, distance, charge, gravity, theta, alpha</code>等参数可以定制。</p>
		<p>links()和nodes()分别用来导入节点和链路数据，导入后的节点多了<code>index</code>索引，<code>px py</code>记录上个位置，<code>x y</code>记录当前位置，<code>weight</code>记录节点权重。导入后的链路有<code>source</code>和<code>target</code>属性标注链接关系。<code>size([width, height])</code>用来确定力作用域的范围，力的中心为<code>[x/2, y/2]</code>。若节点无x和y属性，则会被初始化为<code>[0,x]</code>和<code>[0,y]</code>的上的随机值。<code>linkDistance([distance])</code>设置连线长度，可以传入函数，函数接受<code>link, i</code>两个参数。链路约束采用的力学模型不是弹簧式的，而更像弱位置约束。可以在<code>tick</code>方法中修改默认力学模型。<code>linkStrength([strength])</code>设置链路的坚硬程度，需在<code>[0,1]</code>之间，可以输入函数。<code>friction([f])</code>方法描述节点减速的快慢，需在<code>[0,1]</code>之间，越靠近1，节点越快停止运动。<code>charge([charge])</code>描述相互作用力的大小，可以输入函数，负值表示斥力，正值表示引力，可以根据场景选择。<code>chargeDistance()</code>设置力的作用距离，默认为无穷。<code>theta()</code>方法设置算法的准确度。<code>gravity()</code>方法设置作用域中心对节点的吸引力，越靠近中心越小。<code>alpha()</code>获取/设置当前能量，从而影响收敛程度。</p>
		<p><code>force.start()</code>方法启动力导向布局的仿真，并根据<code>alpha</code>的值逐步收敛并最终停止。<code>resume()</code>方法和<code>drag</code>动作会重新启动force仿真。<code>force.resume()</code>等同于<code>force.alpha(.1)</code>可以重新启动一个force仿真。<code>force.stop()</code>终止一个仿真。<code>force.tick()</code>进行一步force仿真。</p>
		<p><code>force.on(type, listener)</code>注册一个监听器。<code>force.drag()</code>可以通过<code>node.call()</code>的形式调用，并允许拖拽效果，在<code>dragstart</code>事件中设置<code>fixed</code>为<code>true</code>还可以拖拽后固定节点。范例如下：</p>
		<pre><code>var drag = force.drag()
	.on("dragstart",function(d,i){
		d.fixed = true; // true or false
	})	</code></pre>
		<h4 id="d3_chord">弦图</h3>
		<p>弦图可以用来描述两个节点间的联系和权重程度，且两点间的联系是有向的，非对称的。弦布局同弦形和弧形协同工作。通过<code>d3.layout.chord()</code>或<code>d3.chord()</code>初始化。</p>
		<p><code>chord.matrix([matrix])</code>指定用到的数据矩阵，V4.0中使用<code>chord([matrix])</code>实例化生成。<code>chord.padding([paddings])</code>指定不同组间的填充角度，可以为函数。<code>sortGroups()</code>方法使用指定函数为布局设定分组排列顺序。<code>sortSubgroups([comparator])</code>方法设定组内各列的排列顺序，<code>sortChords([comparator])</code>指定弦在Z轴上的堆叠顺序。<code>chords()</code>方法返回通过给定参数计算过的弦对象。<code>groups()</code>返回计算过的分组对象。<code>groups</code>为对象的数组，对象有<code>endAngle, index, startAngle, values</code>4个属性。Chord的元素有<code>source</code>和<code>target</code>两个属性，这两个属性也是对象类型，内部都有<code>endAngle, index, startAngle, subindex, value</code>这几个属性。在使用<code>layout.chord()</code>生成弦和边缘时，分别由arc生成器和chord生成器生成形状。同样，<strong>生成的<code>path</code>最好包裹在<code>&lt;g></code>标签内</strong>。</p>
		<p>在V4.0版本中，计算出的chords会交给<code>d3.ribbon</code>完成展示，且可以直接通过指定<code>startAngle, endAngle, radius</code>来绘制弦。</p>
		<h4 id="d3_cluster">集群图/树状图/矩阵树图</h4>
		<p>集群图用来表示包含和被包含的关系。如学科的细分，类的成员方法等。它会生成树状的结构，且树上每个叶子节点的深度相等。在层级结构上是较特殊的一种。通过<code>d3.layout.cluster()</code>初始化，V4.0中包含在<code>hierarchy</code>模块中，通过<code>d3.cluster()</code>初始化。相对上面的3种图，构造较为简单。可以通过简单地读取JSON格式数据构造。</p>
		<p><code>cluster(root)</code>构造cluster树状结构。<code>cluster.nodes</code>方法运行簇布局，返回节点数组。<code>links(nodes)</code>通过指定节点数组，返回节点间的关系。每个节点都是具有两个属性<code>source, target</code>的对象。<code>sort</code>方法可以指定节点的排序方法。<code>separation([separation])</code>使用指定函数节点间距，通常可以根据深度大小响应调整间距，如<code>return (a.parent == b.parent ? 1 : 2) / a.depth</code>。此外还有<code>size, nodesize, value</code>等方法。</p>
		<p>层级图中树枝的曲线绘制通常使用贝塞尔曲线，通过<code>d3.svg.diagonal()</code>构造。最经常用在node-link类型的图中。<code>diagonal(datum[, index])</code>根据<code>datum</code>返回<code>path</code>数据字符串。<code>diagonal.source/target([source/target])</code>分别用来设置曲线的起点和终点，且接受函数作为输入参数。<code>projection[projection]()</code>方法修改diagonal的映射方向，以返回<code>[x,y]</code>的函数作为输入参数。在V4.0版本中作为hierarchy的一部分，被移除。</p>
		<p>d3的请求API中提供了对JSON格式数据的请求。在集群图数据较复杂时（实际上其他类型的图也会遇到数据需要从外部导入的情况），通过<code>d3.json</code>引入外部文件也可以轻松生成图表。</p>
		<p>树状图和集群图一样从属于层级图(hierarchy)的范畴，区别在树状图的叶子结点深度不都相同。同样的有树布局<code>d3.layout.tree</code>。用法和<code>cluster</code>几乎完全一致。这里从略。</p>
		<p>矩阵树图是用大小矩形表示树的节点，并面积大小表示节点从属关系和重要性。<code>d3.layout.treemap()</code>提供矩阵树图布局构造。<code>links, children, value</code>方法设置布局如何读取链路/子节点/值信息。<code>sort</code>方法用作节点排序，<code>size</code>方法设置布局展示范围，<code>padding</code>设置矩形间隔，默认为<code>0</code>。<code>round</code>方法设置约成的像素数，减少锯齿出现。<code>sticky</code>方法可以使得矩阵树在变形时保持比例，<code>mode</code>方法用来设置矩阵树的布局模式。<code>ratio</code>设置矩形长宽比，默认为黄金比例。V4.0版本中，去掉了<code>round，sticky和mode</code>。通过<code>tile</code>方法设置矩阵树布局模式，且有更多模式可以选择。</p>
		<h4 id="d3_bundle">捆图</h4>
		<p>捆图几乎都是和其余布局一起使用的。用来计算节点见的路径。在V4.0版本中已经取消。V3.x中，捆图布局只有两个函数<code>d3.layout.bundle()</code>和<code>bundle(links)</code>。前者创建捆图布局，后者根据<code>links</code>数组的<code>source</code>和<code>target</code>计算路径。通常在使用时，通过集群图、打包图、分区图、树状图等等计算出节点位置，再用捆图计算连线路径。捆图需要的<code>links</code>数组可以通过其他布局的<code>links</code>方法轻松得到。</p>
		<h4 id="d3_pack">打包图</h4>
		<p>打包图用来表示包含和被包含的关系，同时通过大小表示相互的权重大小。通常用圆套圆的样子呈现。相较层级图更强调包含的关系。与它类似的还有treemap矩形树。将层级展开后，还可以用来创建气泡图。</p>
		<p>通过<code>d3.layout.pack()</code>构造，<code>pack(root)</code>实例化，<code>nodes</code>方法返回节点，<code>links</code>方法返回链路信息，<code>sort</code>方法用来为同级节点排序。这些方法和<code>cluster</code>及<code>tree</code>是很相似的。区别是<code>nodes</code>中多了<code>r</code>计算半径，<code>links</code>很少使用。<code>size</code>方法和<code>radius</code>分别设置展示范围和最小圆半径，<code>padding</code>指定相邻圈间的大概填充，默认为<code>0</code>。在V4.0中，改进了画图算法。</p>
		<h4 id="d3_partition">分区图</h4>
		<p>分区图用图形的面积和依附关系表示层级和层级间的从属关系。图形可以是矩形，圆环等等。通过<code>d3.layout.partition, d3.partition()</code>初始化分区布局，<code>partition(root)</code>加入数据，通过<code>partition.nodes(root), partition.link(root)</code>获取分区节点和分区链路。<code>partition.children()</code>设置孩子访问器。同其他布局，<code>partition</code>有<code>sort, value, size</code>等方法，分别用于设置是否排序，如何获取value和布局范围<code>[width, height]</code>。V4.0中将层级的通用方法放在<code>hierarchy</code>中，增添了<code>round([round]), padding([padding])</code>方法。</p>
		<p>在使用原型分区图的时候，可以通过<code>size()</code>方法和<code>arc</code>的<code>innerRaidus, outerRadius</code>方法巧妙实现。<code>size([Math.PI*2, radius*radius])</code>可以保证相同比重的区域面积相等。</p>
		<h4 id="d3_geo">地理图</h4>
		<p>地理图相较此前的图表要复杂许多。展示地图边界需要用到<code>GeoJSON</code>格式的数据，数据获取参见<a href="http://www.ourd3js.com/wordpress/?p=668" target="_blank">中文教程</a>。绘制地图需要投影函数，类似于我们之前介绍的布局，将3维的经纬度转成2维平面内的横纵坐标。<code>d3.geo.projection(raw)</code>可以自定义一个投影函数，不过通常都是使用现有的投影函数。通过<code>projection(location)</code>来映射位置，输入经纬度返回横纵坐标。Projection本身还提供了<code>invert, rotate, center([longtitude, latitude]), translate, scale([scale])</code>等方法，类似于比例尺。<code>clipAngle</code>和<code>clipExtent</code>方法会裁剪投影范围。</p>
		<p><code>geo</code>还提供了一些常见投影。<code>albers()</code>是<code>conicEqualArea()</code>投影的别名，默认以美国为中心，<code>albersUsa()</code>用来绘制美国地图，<code>azimuthalEqualArea()</code>方位角等面积投影(经纬线绘成的区域等面积)，<code>azimuthalEquildstant()</code>方位角等距投影(投影点到投影中心和到大弧距离等比例)。<code>ConicConformal()</code>兰伯特等角二次曲线投影地球为一个锥形，<code>parallels</code>方法可以设定投影的标准平行线为特定的二元纬度数组。<code>conicEqualArea()</code>是一个等区域的投影，保留了地理特征，它也有<code>parallels</code>方法。<code>conicEquidistant()</code>等距离的投影，同上。<code>equirectangle()</code>方法是正方形投影，经纬度类似光栅效果。<code>geoGnomonic()</code>方法是个方位角投影，它投射大圆（赤道）为直线，将半球投射在切平面上。<code>mercator()</code>是最常用的墨卡托投影，将经纬度投射在和地球相切或相割的圆柱体表面，有面积大小的失真。<code>orthographic()</code>投射点位于无穷远，用于投射半球，多用于卫星摄影。<code>。tereographic()</code>方法，立体投影。<code>transverseMercator()</code>方法是横向墨卡托投影。另外通过<code>d3.geoProjection</code>和<code>d3.geoProject-ionMutator</code>方法可以设置和修改自定义的projection。</p>
		<p>显示地理数据需要用到<code>d3.geo.path</code>。它通过读入GeoJSON数据，生成SVG字符串或直接渲染在<span class="i">Canvas</span>上（V4.0）。<code>d3.geo.path()</code>可以创建一个地理路径生成器。<code>path</code>的<code>projection</code>方法指定投影类型，除了上述的投影函数，还可以自定义接受经纬度返回横纵坐标的函数。<code>path(object[, args])</code>可以生成标点，多标点，边缘，多边形，地理对象，特写等许多地理对象。椭圆类型也支持，以用来绘制球形轮廓。<code>path</code>对象有许多方法，<code>area(object)</code>计算区域面积，<code>bounds(object)</code>返回区域盒模型区域，<code>centroid(object)</code>返回区域中心，多用来插入文本。<code>path.context([context])</code>指定<code>path</code>渲染内容，<code>context</code>必须实现一些<code>CanvasRenderingContext2D</code>的方法。<code>path.pointRadius([radius])</code>设置标点的半径。</p>
		<p>还有一些常用的<code>geo</code>绘图对象，如<code>circle</code>，V4.0中通过<code>geoCircle()</code>构造，有<code>center, raidus, precision</code>几种方法，分别制定圆心位置，半径和精确度。<code>graticule</code>对象用来绘制经纬线的网格图，表现出投影的转换。通过<code>geoGraticule()</code>（同样是V4.0中），<code>extent, extentMajor</code>和<code>extentMinor</code>方法设置网格范围。<code>step</code>设置步长，同样有<code>stepMajor</code>和<code>stepMinor</code>两种方法，<code>precision</code>方法设置精度。<code>graticule</code>的<code>lines()</code>方法给出线型<span class="i">GeoJSON</span>数组，数组各项对应每一条经纬线，<code>outline()</code>方法给出整个网格图的<span class="i">GeoJSON</span>多边形对象。</p>
		<p><span class="i">GeoJSON</span>是一项国际标准，用来编码大量地理数据。<span class="i">GeoJSON</span>支持点、线、多边形、多点、多多边形几种地理形状。整个内容用<code>FeatureCollection</code>包裹起来。<code>type</code>中指定<code>featureColelction</code>，在<code>features</code>字段中加入地理对象，每个地理对象由<code>type, geometry, properties</code>几部分组成，分别表示类型，地理信息和额外信息。<code>geometry</code>里<code>type</code>和<code>coordinates</code>分别表明类型和系列点。<span class="i">TopoJSON</span>对<span class="i">GeoJSON</span>规范做了简化，如使用整数等，在D3中使用<span class="i">TopoJSON</span>较多。</p>
		<p><strong>注：<a href="http://mapshaper.org/" target="_blank">mapshaper</a>可以帮助简化<span class="i">GeoTopo</span>文件，做<span class="i">GeoJSON</span>和<span class="i">TopoJSON</span>间的转换</strong></p>
		<h4 id="d3_histogram">直方图</h4>
		<p>直方图多用来可视化离散的序列数据，或用来描述分布。通过<code>d3.layout.histogram()</code>构造，<code>histogram(data)</code>初始化，它将数据装在一个个组中(bin)，容器有<code>x0</code>和<code>x1</code>两个属性确定容器的上限和下限。<code>value([value])</code>方法用于设置<code>value</code>域的预处理器，类似之前提到的各图的布局。<code>domain([domain])</code>方法用来限制输入数据的范围，<code>thresholds([count])</code>用来设置分组的界限。此外，还有一些预设方法将值组织在各组中。V3.x中，通过<code>range</code>方法限制输入范围，通过<code>bins</code>方法设置分组数/界限，且有<code>frequency</code>方法指定统计个数或是概率。</p>
		<h4 id="d3_stack">堆栈图</h4>
		<p>堆栈图用于描述多组数据的堆叠变化（连续和离散），如产品间随时间变化的销量组成展示。通过<code>d3.layout.stack()</code>构造布局，<code>stack(layers[, index])</code>读入堆叠数据，生成的布局有<code>x, y, y0</code>三个属性。<code>values([accessor])</code>方法设定获取值的方法，<code>offset([offset])</code>方法设置生成布局的方式，<code>order([order])</code>指定堆栈排序方法。<code>x([accessor])和y([accessor])</code>方法设置x和y轴的数据来源。V4.0中将<code>x</code>和<code>y</code>方法替换成了<code>keys</code>方法。</p>
		<h3 id="d3_xhr">请求API</h3>
		<p>对于小数据集，可以将它硬编码到脚本内，或通过数据属性嵌入到DOM中。对于大数据集，最常用的方法是通过<code>XMLHttpRequest(XHR)</code>加载数据到浏览器，这允许异步加载数据，比<span class="i">JSONP</span>更方便。d3的请求API就建立在<span class="i">XHR</span>的基础上。</p>
	</div>
</body>
</html>