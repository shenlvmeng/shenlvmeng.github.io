<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="utf-8">
	<meta name="keywords" content="javascript,js,front-end,book,tutorial,shenlvmeng">
	<meta name="description" content="前端技术学习笔记">
	<meta name="author" content="shenlvmeng">
	<title>Front-end tools book(1)</title>
	<link rel="stylesheet" type="text/css" href="./css/book.css">
	<link rel="stylesheet" href="./css/atom-one-dark.css">
	<script src="./highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
	<aside>
		<a href="#" class="title">前端技术学习笔记</a>
		<ul>
			<li><a href="#introduction">前言</a></li>
			<li><a href="#tail">尾注</a></li>
		</ul>
		<hr>
		<a href="#nodejs">nodeJS</a>
		<ul>
			<li><a href="#node_what_why">What and Why</a></li>
			<li><a href="#node_install">安装</a></li>
			<li><a href="#node_modules">模块</a></li>
			<li><a href="#node_require">代码组织</a></li>
			<li><a href="#node_file">文件操作</a></li>
			<li><a href="#node_network">网络操作</a></li>
			<li><a href="#node_thread">进程管理</a></li>
			<li><a href="#node_features">特点</a></li>
			<li><a href="#node_examples">使用示例</a></li>
			<li><a href="#node_more">更多</a></li>
		</ul>
		<a href="#npm">npm</a>
		<ul>
			<li><a href="#npm_introduction">简介</a></li>
			<li><a href="#npm_install">安装</a></li>
			<li><a href="#npm_commands">常用命令</a></li>
			<li><a href="#npm_download">下载第三方包</a></li>
			<li><a href="#npm_install_cmd">安装命令行程序</a></li>
			<li><a href="#npm_release">发布自己的包</a></li>
			<li><a href="#npm_version">版本号控制</a></li>
			<li><a href="#npm_sum_up">小结</a></li>
			<li><a href="#npm_more">更多</a></li>
		</ul>
		<a href="#bower">Bower</a>
		<ul>
			<li><a href="#bower_introduction">简介</a></li>
			<li><a href="#bower_usage">使用</a></li>
			<li><a href="#bower_question">Bower or npm?</a></li>
		</ul>
		<a href="#browserify">Browserify</a>
		<ul>
			<li><a href="#brow_intro_usage">简介与使用</a></li>
			<li><a href="#brow_manage_generate">管理与生成</a></li>
		</ul>
		<a href="#webpack">Webpack</a>
		<ul>
			<li><a href="#webpack_why">Why</a></li>
			<li><a href="#webpack_usage">安装使用</a></li>
			<li><a href="#webpack_config">配置文件</a></li>
			<li><a href="#webpack_more">更多</a></li>
		</ul>
		<a href="#grunt">Grunt</a>
		<ul>
			<li><a href="#grunt_tutorial">入门</a></li>
			<li><a href="#gruntfile">Gruntfile</a></li>
			<li><a href="#grunt_config">任务配置</a></li>
			<li><a href="#grunt_example">配置实例</a></li>
			<li><a href="#grunt_task">任务与插件</a></li>
			<li><a href="#grunt_more">更多</a></li>
		</ul>
		<a href="#gulp">Gulp</a>
		<ul>
			<li><a href="#gulp_tutorial">入门</a></li>
			<li><a href="#gulp_api">常用API</a></li>
			<li><a href="#gulp_cli">CLI使用</a></li>
			<li><a href="#gulp_more">更多</a></li>
		</ul>
		<a href="#commonjs">CommonJS</a>
		<ul>
			<li><a href="#common_brief">简介</a></li>
			<li><a href="#common_feature">特点</a></li>
			<li><a href="#common_module">Module</a></li>
			<li><a href="#require">Require</a></li>
			<li><a href="#amd">AMD and more?</li>
			<li><a href="#common_more">更多</a></li>
		</ul>
		<a href="#backbone">Backbone.js</a>
		<ul>
			<li><a href="#backbone_brief">概述</a></li>
			<li><a href="#backbone_structure">项目组成</a></li>
			<li>
				<a href="#backbone_api">API介绍(v1.3.3)</a>
				<ul>
					<li><a href="#backbone_view">View</a></li>
					<li><a href="#backbone_event">Events</a></li>
					<li><a href="#backbone_router">Router</a></li>
					<li><a href="#backbone_model">Model</a></li>
					<li><a href="#backbone_collection">Collection</a></li>
				</ul>
			</li>
			<li><a href="#backbone_demo">Demos</a></li>
			<li><a href="#backbone_more">更多</a></li>
		</ul>
		<a href="#express">Express JS</a>
		<ul>
			<li><a href="#express_brief">概述</a></li>
			<li><a href="#express_basic">基本原理</a></li>
			<li><a href="#express_methods">常用方法</a></li>
			<li><a href="#express_template">网页模板</a></li>
			<li><a href="#express_router">路由</a></li>
			<li><a href="#express_modules">常用模块</a></li>
			<ul>
				<li><a href="#body-parser">body-parser</a></li>
				<li><a href="#cookie-parser">cookie-parser</a></li>
				<li><a href="#express-session">Express-session</a></li>
				<li><a href="#connect-mongo">Connect-mongo</a></li>
				<li><a href="#ejs">Ejs</a></li>
				<li><a href="#express-mongo">Mongodb</a></li>
				<li><a href="#express-flash">Connect-flash</a></li>
			</ul>
			<a href="#express_more">更多</a>
		</ul>
		<a href="#react">React JS</a>
		<ul>
			<li><a href="#react_what_why">What and Why</a></li>
			<li><a href="#thinking_in_react_way">Thinking in React Way</a></li>
			<li><a href="#react_data">数据呈现</a></li>
			<ul>
				<li><a href="#jsx">JSX</a></li>
				<li><a href="#jsx_html">JSX属性扩散与HTML</a></li>
			</ul>
			<li><a href="#react_interact">添加交互</a></li>
			<li><a href="#react_component">组合组件</a></li>
			<li><a href="#react_form">表单组件</a></li>
			<li><a href="#react_component_life">组件说明与生命周期</a></li>
			<li><a href="#refs">Refs</a></li>
			<li><a href="#react_api">API</a></li>
			<ul>
				<li><a href="#react_reactapi">React</a></li>
				<li><a href="#reactdomapi">ReactDOM</a></li>
				<li><a href="#reactdomserverapi">ReactDOMServer</a></li>
				<li><a href="#reactcomponentapi">Component</a></li>
			</ul>
			<li><a href="#react_others">标签/属性/事件</a></li>
			<li><a href="#flux">Flux/Redux</a></li>
			<li><a href="#react_more">更多</a></li>
		</ul>
		<a href="#angular">Angular JS</a>
		<ul>
			<li><a href="#angular_brief">简介与安装</a></li>
			<li><a href="#angular_usage">使用</a></li>
			<ul>
				<li><a href="#angular_app">应用/控制器</a></li>
				<li><a href="#angular_expression">表达式</a></li>
				<li><a href="#angular_model">数据模型</a></li>
				<li><a href="#angular_filter">过滤器</a></li>
				<li><a href="#angular_service">服务</a></li>
				<li><a href="#angular_sql">Sql</a></li>
				<li><a href="#angular_dom">DOM/事件</a></li>
				<li><a href="#angluar_form">表单验证</a></li>
				<li><a href="#angular_router">路由</a></li>
				<li><a href="#angular_api">通用API函数</a></li>
			</ul>
			<li><a href="#dependency_injection">依赖注入</a></li>
			<li><a href="#angular_extend_command">基础拓展指令</a></li>
			<li><a href="#angular2">Angular 2</a></li>
			<ul>
				<li><a href="#componency">组件化</a></li>
				<li><a href="#angular2_extend_commonds">拓展命令</a></li>
			</ul>
			<li><a href="#angular_more">更多</a></li>
		</ul>
		<a href="#mangodb">Mangodb</a>
		<ul>
			<li><a href="#mango_brief">简介</a></li>
			<li><a href="#mango_unit">基本单位</a></li>
			<li><a href="#mango_database">连接/创建/删除数据库</a></li>
			<li><a href="#mango_crud">CRUD操作</a></li>
			<li><a href="mango_index">索引与聚合</a></li>
			<li><a href="#mango_others">其他</a></li>
		</ul>
		<a href="#socketio">Socket.io</a>
		<a href="#jade">Jade</a>
		<ul>
			<li><a href="#jade_brief">简介</a></li>
			<li><a href="#jade_lang">语法</a></li>
		</ul>
		<a href="#d3">D3.js</a>
		<ul>
			<li><a href="#d3_brief">简介</a></li>
			<li><a href="#svg">SVG介绍</a></li>
			<ul>
				<li><a href="#svg_axis">坐标</a></li>
				<li><a href="#svg_shape_path">形状与路径</a></li>
				<li><a href="#svg_fill_stroke">填充与边框</a></li>
				<li><a href="#svg_pattern_text">模式与文字</a></li>
				<li><a href="#svg_transform_distord">渐变与变形</a></li>
				<li><a href="#svg_cut">剪切与遮罩</a></li>
				<li><a href="#svg_filter">滤镜</a></li>
				<li><a href="#svg_others">其他</a></li>
			</ul>
			<li><a href="#d3_dom">DOM操作API</a></li>
			<li><a href="#d3_scale">比例尺API</a></li>
			<li><a href="#d3_transition">渐变API</a></li>
			<li><a href="#d3_layout">布局API & 形状API</a></li>
			<ul>
				<li><a href="#d3_pie">饼状图</a></li>
				<li><a href="#d3_force">力导向图</a></li>
				<li><a href="#d3_chord">弦图</a></li>
				<li><a href="#d3_cluster">集群图/树状图/矩阵树图</a></li>
				<li><a href="#d3_bundle">捆图</a></li>
				<li><a href="#d3_pack">打包图</a></li>
				<li><a href="#d3_partition">分区图</a></li>
				<li><a href="#d3_geo">地理图</a></li>
				<li><a href="#d3_histogram">直方图</a></li>
				<li><a href="#d3_stack">堆栈图</a></li>
			</ul>
			<li><a href="#d3_xhr">请求API</a></li>
			<li><a href="#d3_random">随机数API</a></li>
			<li><a href="#d3_behavior">行为API</a></li>
			<li><a href="#d3_color">颜色API</a></li>
			<li><a href="#d3_more">更多</a></li>
		</ul>
		<a href="#es2015">ES6新特性</a>
		<a href="#groccery">杂项</a>
		<ul>
			<li><a href="#markdown">Markdown</a></li>
			<li><a href="#jsonp">JSONP & CORS</a></li>
			<li><a href="#dependency_infection_intro">依赖注入</a></li>
			<li><a href="#candy">语法糖</a></li>
			<li><a href="#function_language">函数式编程</a></li>
			<li><a href="#iife">IIFE</a></li>
			<li><a href="#stream">Nodejs中的Stream</a></li>
			<li><a href="#crypto">Crypto</a></li>
		</ul>
		<p>&copy; shenlvmeng</p>
	</aside>
	<div class="container">
		<h3 id="introduction">前言</h3>
		<p>此文源于6月初的一个知乎问题“<a href="http://www.zhihu.com/question/29875948" target="_blank">为什么市场上优秀的前端这么少，国外也是这样吗?</a>”，简单阅览了答案后才发现，有那么多的web技术自己还闻所未闻。于是开始从javascript(js)开始，广度优先地学习起一些新技术（当然有些列举的已经不算新了）。在学习的过程中，也发现了作为一名前端工程师的不易：</p>
		<ul>
			<li>科技树太广，需要广泛的知识面</li>
			<li>随着js的发展，前端技术已渗透到各个方面，做前端≈做全栈</li>
			<li>新技术出现太快，需要保持open mind</li>
		</ul>
		<p>这里整理了对一些技术的学习笔记，几乎都是与js相关的技术，按照分类列举在下面（有些未做学习）:</p>
		<ul>
			<li><strong>框架</strong>：AngularJS, EmbedJS, ReactJS, ExpressJS, Backbone.JS</li>
			<li><strong>环境</strong>：NodeJS</li>
			<li><strong>包管理</strong>：Bower, npm</li>
			<li><strong>包构建</strong>：Browserify, Webpack</li>
			<li><strong>任务自动化</strong>：Grunt, Gulp</li>
			<li><strong>模块化规范</strong>：RequireJS, CommonJS, AMD, CMD</li>
			<li><strong>DOM操作</strong>：jQuery, Zepto</li>
			<li><strong>数据库</strong>：MongoDB</li>
			<li><strong>可视化</strong>：D3</li>
			<li><strong>测试工具</strong>：Protractor, Selenium, PhantomJS, mocha</li>
			<li><strong>其他</strong>：Jade, Markdown, Socket.io等</li>
		</ul>
		<p>关于本文，还有一些想说的。首先，前端技术发展很快，文中提到的用法等内容是有一定时效性的，请谨慎；其次，写本文的时候是奔着信息充分，便于日后检索去的，所以当作工具书更为适合；最后，水平有限，纰漏还望指正。</p>
		<hr>
		<h1 id="nodejs">NodeJS</h2>
		<h3 id="node_what_why">What and Why</h3>
		<p>NodeJS是以下介绍的许多技术的出发点和基础。它让JS从前端技术走到后台开发。对于独立运行的JS来说，NodeJS就是一个解析器，就像PHP。但是和PHP不同的是，NodeJS在实现应用的同时，还实现了整个HTTP服务器，不像PHP需要Apache等的帮助。</p>
		<p>NodeJS具有很好的事件机制和异步IO模型。类似于浏览器，NodeJS提供了内置对象给用户操作。</p>
		<h3 id="node_install">安装</h3>
		<p>Windows下和Mac OS X系统下，分别去<a href="http://nodejs.org" target="_blank">nodejs.org</a>下载.msi和.pkg后缀的安装文件。Linux下需要下载.tar.gz包编译安装。</p>
		<p>Windows环境下安装后可以在命令行中使用<code>node –v</code>, <code>npm –v</code>查看是否成功。另外终端下直接输入node命令可进入命令交互模式.</p>
		<h3 id="node_modules">模块</h3>
		<p>运行简单的web应用程序时，可以直接通过命令或是<code>node example.js</code>的形式启动。在程序稍大时，通常会将代码模块化。文件即模块，通过<code>require</code>、<code>exports</code>、<code>module</code>命令导入、导出、声明模块。范例：</p>
		<pre><code>var foo = require("./foo");
exports.hello = function(){
    console.log("Hello World!");
}
module.exports = function(){
    console.log("Hello World!");
}		</code></pre>
		<p><code>require</code>函数用于在当前模块中加载和使用别的模块，返回一个模块导出对象。模块名可以以相对或是绝对路径。模块后缀名可省略。<code>exports</code>对象用于导出模块共有方法和属性，导出的内容由别的模块使用<code>require</code>获取。<code>module</code>对象可以访问当前模块的一些相关信息，包括导出对象。</p>
		<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。通过命令行传递给NodeJS启动的模块称为主模块。</p>
		<p>最后，NodeJS支持使用C/C++编写二进制模块，使用方法和JS模块相同，它可以使用操作系统提供的所有功能，潜能很大，但是难以跨平台。这里从略。</p>
		<h3 id="node_require">代码组织</h3>
		<p><code>require</code>函数支持绝对、相对路径，可以通过<span class="i">node_modules</span>目录，<span class="i">NODE_PATH</span>定制。</p>
		<p>当模块较复杂时，可以使用包结构将多个子模块。将这些子模块放在同一目录下，使用<code>index.js</code>作为入口模块。这样路径只需写到文件夹即可。范例：</p>
		<pre><code>var head = require('./head');
var body = require('./body');

exports.create = function (name) {
    return {
        name: name,
        head: head.create(),
        body: body.create()
    };
};		</code></pre>
		<p>另外，使用<code>package.json</code>可以自定义入口模块的文件名和存放位置。使用name,main即可</p>
		<p>标准的工程目录应该包括<span class="i">bin/</span>, <span class="i">doc/</span>, <span class="i">lib/</span>, <span class="i">node_modules/</span>, <span class="i">tests/</span>, <span class="i">package.json</span>, <span class="i">README.md</span>等部分，分别存放命令相关代码、文档、API相关代码、第三方包、测试用例、元数据文件、说明文件。nodeJS有许多内置的模块可供使用，下面分几个部分分别介绍之。</p>
		<h3 id="node_file">文件操作</h3>
		<p>NodeJS作为后台解析环境，可以完成很多文件操作。使用NodeJS内置的<code>fs</code>模块的API可以完成如拷贝等功能。拷贝小文件时，使用<code>writeFileSync</code>, <code>readFileSync</code>即可完成，大文件拷贝时，使用<code>createReadStream</code>, <code>pipe</code>, <code>createWriteStream</code>可以完成。</p>
		<p>同时NodeJS还提供了<code>Buffer</code>，<code>Stream</code>，<code>Path</code>用于完成更完善的文件操作功能。</p>
		<p><a href="https://nodejs.org/api/buffer.html" target="_blank"><code>Buffer</code></a>对象是与<code>String</code>对等的二进制数据类型，可以用<code>to_string</code>和<code>string</code>相互转换。不同的是，<code>buffer</code>对象是可写的，这点和C很像。因此，<code>buffer</code>更像是指针操作的C语言数组，如使用<code>slice</code>命令更像是将指针赋予了新值，对新值做的修改对原值有直接影响。因此，拷贝<code>buffer</code>时，需要先创建一个新的<code>buffer</code>才能复制新数据。</p>
		<p><a href="https://nodejs.org/api/stream.html" target="_blank"><code>Stream</code></a>对象在内存无法一次装下大文件的数据时，或需要一边读取一边处理时提供对数据流的操作，例如可用<code>createReadStream</code>创建一个只读数据流<code>rs</code>，<code>rs</code>有<span class="i">on, pause, resume, end</span>等功能。<code>Stream</code>对象都是事件驱动的，上文提到的rs即可监听<span class="i">data, end, drain</span>等事件。<code>pipe</code>方法提供了防爆仓控制，用于大文件拷贝。</p>
		<p><a href="https://nodejs.org/api/fs.html" target="_blank"><code>fs</code></a>模块提供了许多有用的API，包括文件属性读写，文件内容读写，底层文件操作。这些API大多为异步，不过都有同步版本，并在函数名后添加Sync。</p>
		<p><a href="http://nodejs.org/api/path.html" target="_blank"><code>Path</code></a>模块用于文件路径的操作。<code>Normalize</code>方法将传入的路径转换为标准路径，<code>join</code>方法将传入的多个路径拼接成标准路径。</p>
		<p>下面是一个遍历目录的同步例子，用到了以上介绍的内容：</p>
		<pre><code>function travel(dir, callback) {
    fs.readdirSync(dir).forEach(function (file) {
        var pathname = path.join(dir, file);

        if (fs.statSync(pathname).isDirectory()) {
            travel(pathname, callback);
        } else {
            callback(pathname);
        }
    });
}		</code></pre>
		<p>除了以上介绍的文件操作外，一些其他需求也经常出现，如去文件BOM头，GBK转换UTF-8编码，单字节编码。</p>
		<p>NodeJS提供的这些文件操作功能对于变现前端工具是很有帮助的。</p>
		<h3 id="node_network">网络操作</h3>
		<p>由于NodeJS的用途是实现高性能的Web服务器，给独立运行的JS提供解释环境，它所提供的网络操作可以完成相对底层的网络操作，如Socket和HTTP协议相关。NodeJS提供了<code>http, https, url, querystring, zlib, net</code>等库帮助开发者实现网络编程。</p>
		<p><a href="https://nodejs.org/api/http.html" target="_blank"><code>http</code></a>模块提供了两种使用方式: 作为服务端使用和作为客户端使用。如测试第1例中所写，<code>createServer</code>方法创建一个服务器（这也是最常用的一种用法），然后抵用listen方法监听端口。客户端每请求一次，创建时输入的回调函数就调用一次。函数中的<code>request</code>和<code>response</code>实际上也是数据流的格式，所以可以用文件操作函数来读取，如<code>request.on</code>, <code>request.write</code>等方法.</p>
		<p>在作为客户端使用时，有<code>get</code>, <code>post</code>等方法，同样地，可以使用<code>response</code>对象访问响应头数据，还能把<code>response</code>对象当作一个只读数据流访问响应体数据。用法范例如下：</p>
		<pre><code>http.get('http://www.example.com/', function (response) {
    var body = [];

    console.log(response.statusCode);
    console.log(response.headers);

    response.on('data', function (chunk) {
        body.push(chunk);
    });

    response.on('end', function () {
        body = Buffer.concat(body);
        console.log(body.toString());
    });
});		</code></pre>
		<p><a href="https://nodejs.org/api/https.html" target="_blank"><code>https</code></a>模块和<code>http</code>模块很类似，区别在于<code>https</code>模块需要额外的SSL证书处理，在<code>createServer</code>时，将公钥和私钥放在<code>option</code>里作为输入参数。同时<code>https</code>的<code>addContext</code>方法还可以使用多个域名提供服务。在客户端模式下，<code>https</code>模块默认拒绝连接未从颁发机构购买SSL证书的服务器。在<code>options</code>中添加<code>rejectUnauthorized: false</code>即可在开发条件下允许自制证书。</p>
		<p><a href="https://nodejs.org/api/url.html" target="_blank"><code>url</code></a>模块允许生成、解析、拼接url。url分为<span class="i">protocol, auth, hostname, port, pathname, search(query) hash/host, path, href</span>等部分。<code>parse</code>方法可以将url解析成以上部分，且不要求url完整。<code>parse</code>的第二和第三个参数分别可以将query部分转换成对象和解析不带协议头的URL。相反地，<code>format</code>方法允许将URL对象转换为URL字符串。<code>resolve</code>方法支持URL的拼接。</p>
		<p><a href="https://nodejs.org/api/querystring.html" target="_blank"><code>querystring</code></a>实现了query字符串和参数对象之间的转换，类似于PHP的<code>$_GET，$_POST</code>。同样适用<code>parse</code>方法和<code>stringify</code>方法完成两个方向的转换。</p>
		<p><a href="https://nodejs.org/api/zlib.html" target="_blank"><code>zlib</code></a>函数支持压缩和解压到功能，在对HTTP响应体数据压缩时，可能需要用到这个模块。下面的范例是官网文档使用的判断用户端是否支持gzip，并在支持时返回gzip之后的响应体数据：</p>
		<pre><code>http.createServer(function (request, response) {
    var i = 1024,
        data = '';

    while (i--) {
        data += '.';
    }

    if ((request.headers['accept-encoding'] || '').indexOf('gzip') !== -1) {
        zlib.gzip(data, function (err, data) {
            response.writeHead(200, {
                'Content-Type': 'text/plain',
                'Content-Encoding': 'gzip'
            });
            response.end(data);
        });
    } else {
        response.writeHead(200, {
            'Content-Type': 'text/plain'
        });
        response.end(data);
    }
}).listen(80);</code></pre>
		<p>同理，<code>zlib</code>可以使用<code>gunzip</code>解压缩文件。</p>
		<p><a href="https://nodejs.org/api/net.html" target="_blank"><code>net</code></a>模块可以创建底层的socket服务器或是客户端，但是在前端领域使用范围并不广。它可以在socket层面实现HTTP请求和响应。需要有网络编程的底层认识和HTTP协议的熟悉。</p>
		<p>最后还需要注意的几点是，<code>http</code>模块创建的服务器返回响应时默认使用<code>chunked</code>传输模式，因为<code>writeHead</code>方法后的响应体数据长度未知，设置<code>header</code>中的<code>Content-Length</code>字段后，NodeJS就不会自动添加<code>Transfer-Encoding</code>字段。<code>http</code>模块提供一个全局客户端<code>http.globalAgent</code>，允许直接使用<code>request</code>方法和<code>get</code>方法，但是最多只允许5个并发连接，通过<code>http.globalAgent.maxSockets</code>可以修改这个值。</p>
		<h3 id="node_thread">进程管理</h3>
		<p>NodeJS可以可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。与之相关的API有<code>process, child_process, cluster</code>等等。</p>
		<p>其中<code>process</code>对象可以感知和控制NodeJS自身进程的方方面面，它是一个全局对象，可以在任何地方使用。通过<code>process</code>可以感知nodeJS进程的各种状态，如<code>process.argv</code>获取命令行参数。它也继承<code>eventEmitter</code>。有<code>exit</code>等事件可以监听，同时有<code>exit, stdin, stdout, env</code>等对程序的精细控制。</p>
		<p><a href="https://nodejs.org/api/child_process.html" target="_blank"><code>child_process</code></a>可以创建和控制子进程，利用<code>spawn, fork</code>方法创建新的进程，使用<code>exec, execFile</code>方法执行命令、文件。<code>Spawn</code>方法还被其他API做进一步的封装，以适应不同场景。<code>cluster</code>模块是对<code>child_process</code>的进一步封装，用于解决单进程NodeJS Web服务器不能充分利用多核CPU的问题。</p>
		<p>这里以进程降权和子进程间通过信号通讯为例，熟悉简单API的一些使用：</p>
		<pre><code>http.createServer(callback).listen(80, function () {
    var env = process.env,
        uid = parseInt(env['SUDO_UID'] || process.getuid(), 10),
        gid = parseInt(env['SUDO_GID'] || process.getgid(), 10);

    process.setgid(gid);
    process.setuid(uid);
});
/* parent.js */
var child = child_process.spawn('node', [ 'child.js' ]);

child.kill('SIGTERM');

/* child.js */
process.on('SIGTERM', function () {
    cleanUp();
    process.exit(0);
});		</code></pre>
		<p>实际上父子进程都为NodeJS进程时，可以通过IPC通讯双向传递数据，双方通过<code>on</code>和<code>send</code>方法在IPC上双向传递数据。具体范例见官网对<code>child.send()</code>的范例。这种情况下，子进程通常使用<code>process.fork</code>方法创建。</p>
		<h3 id="node_features">特点</h3>
		<p>正如<a href="#node_what_why">What and Why</a>中所说，NodeJS最大的特点就是事件机制和异步调用。JS是单线程运行的，但是setTimeout，setInterval这样的函数可以通过创建平行进程的形式实现异步的效果。因此实际运行时，JS主进程会顺序向下执行除回调函数以外的代码，这也意味着，回调函数的执行在JS主线程后。例子见<a href="https://nqdeng.github.io/7-days-nodejs/#4.2.2" target="_blank">参考</a>。</p>
		<p>因此，虽然NodeJS提供了很多异步函数的同步版本，但是为了利用它的优势，熟悉回调和异步的编码思路还是很必要的。如，在同步中以返回值的形式嵌套调用，异步里采用回调函数套回调函数。在遍历等步骤时要更为复杂。</p>
		<p>异常处理也是如此，由于异步调用的形式会打断错误冒泡的路径，使之不会被try语句catch住，因此NodeJS提供的try catch语句只能在同步形式下使用。异步API通常采用向回调函数中传入<code>err</code>参数实现。从以上可以看到，NodeJS最大的特点会增大代码的复杂度，尤其在有异常处理的情况下。对此，NodeJS提供了一些解决方法。</p>
		<p><a href="https://nodejs.org/api/domain.html" target="_blank"><code>domain</code></a>模块可以简化异步代码的异常处理。对于全局异常，可以直接通过<code>process</code>的<code>uncaughtException</code>事件捕获。对于普通异常，我们为每个请求创建一个子域，子域内运行的代码可以随意抛出异常，这些异常可以通过子域对象统一捕获，会使得代码简介很多。范例如下：</p>
		<pre><code>function async(request, callback) {
    // Do something.
    asyncA(request, function (data) {
        // Do something
        asyncB(request, function (data) {
            // Do something
            asyncC(request, function (data) {
                // Do something
                callback(data);
            });
        });
    });
}

http.createServer(function (request, response) {
    var d = domain.create();

    d.on('error', function () {
        response.writeHead(500);
        response.end();
    });

    d.run(function () {
        async(request, function (data) {
            response.writeHead(200);
            response.end(data);
        });
    });
});		</code></pre>
		<p>根据NodeJS官方文档的说法，无论怎么捕获到异常，都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。这是由于NodeJS的部分API内部是用C/C++实现的，代码在执行过程中穿梭在JS引擎内部和外部，因此JS的异常抛出机制可能会打断正常的代码执行，导致C/C++部分代码表现异常。而使用JS语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上述问题。</p>
		<h3 id="node_examples">使用示例</h3>
		<p>这一部分主要展示了一个完整的应用实例。</p>
		<p>1. 为了展示NodeJS的最基本的使用和简单的调试方式。我们创建一个用于启动应用的主文件，起名为<code>server.js</code>，写入如下代码。</p>
		<pre><code>var http = require("http");

http.createServer(function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello, World!");
    response.end();
}).listen(8888);</code></pre>
		<p>将文件放在NodeJS目录下（其他目录亦可），接着用NodeJS执行这段脚本。打开浏览器访问<a href="http://localhost:8888" target="_blank">http://localhost:8888</a>，可看到此网页。对比PHP还是看出很大不同的。</p>
		<p>回调函数很好地反映了使用JS做服务器的特点：事件驱动、异步。在请求到达后交给<code>onRequest()</code>函数处理，函数接受两个参数<code>request</code>和<code>response</code>。</p>
		<p>2. 上文的<code>server.js</code>是启动服务器基本代码，需要交给主文件<code>index.js</code>使用。因此，采用模块一节介绍的方法，使用<code>exports</code>对象。新建<code>index.js</code>，使用<code>require</code>导入。</p>
		<pre><code>var http = require("http");

function start(){
    http.createServer(function(request, response){
        console.log("Request Received");
        response.writeHead(200, {"Content-Type": "text/plain"});
        response.write("Hello, World!");
        response.end();
    }).listen(8888);
    console.log("Server has started.");
}

exports.start = start;

var server = require("./server");
server.start();</code></pre>
		<p>这次同样使用<code>node index.js</code>启动脚本，可以实现同样的效果。</p>
		<p>3. 路由也是一个Web应用开发的关键一块。利用<code>url</code>模块可以完成这一功能。同时在<code>server.js</code>中，将<code>route</code>作为参数传入<code>start</code>函数中。在<code>index.js</code>中，导入<code>router</code>模块。<code>router.js</code>代码如下。</p>
		<pre><code>function route(handler, pathname){
    console.log("Handle a request to " + pathname);
    if(typeof(handler[pathname]) === "function")
        handler[pathname]();
    else
        console.log("Handler for "+ pathname+ " not found.");
}

exports.route = route;</code></pre>
		<p>4. 在start路径下允许用户输入数据，并在upload目录下获得POST数据，需要用到<code>stream</code>和<code>querystring</code>的内容。<span class="i">Server.js</span>和<span class="i">requestHandler.js</span>关键部分定义如下：</p>
		<pre><code>function start(router, handler){
    http.createServer(function(request, response){
	var pathname = url.parse(request.url).pathname;
	var postData = "";
	console.log("Request for "+pathname+" received");

	request.setEncoding("utf-8");
	request.on("data", function(chunk){
		postData += chunk;
		console.log("Receive POST data chunk "+chunk+".");
	});

	request.on("end", function(){
		router(handler,pathname,response,postData);
	});
		
    }).listen(8888);
    console.log("Server has started.");
}
var querystring = require("querystring")

/* requestHandler.js */
function start(response, data){
    console.log('Handler \'start\' was called.');
    var body = '&lt;html>'+
        '&lt;head>'+
        '&lt;meta http-equiv="Content-Type" content="text/html; '+
        'charset=UTF-8" />'+
        '&lt;/head>'+
        '&lt;body>'+
        '&lt;form action="/upload" method="post">'+
        '&lt;textarea name="text" rows="20" cols="60">'+
        '&lt;textarea>'+
        '&lt;input type="submit" value="Submit text" />'+
        '&lt;/form>'+
        '&lt;/body>'+
        '&lt;/html>';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, data){
    console.log('Handler \'upload\' was called.');
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("You have sent "+ querystring.parse(data).text);
    response.end();
}
</code></pre>
		<p>5. 利用NodeJS的异步特点和子进程模块，可以将<code>start</code>和<code>upload</code>函数中的耗时操作设为异步进行，将异步运行的结果交给回调函数处理。在<span class="i">requestHandler.js</span>中添加<code>exec</code>语句即可。同时，允许用户上传文件，并将图片在浏览器中显示出来。可以用第三方插件完成大部分功能。这里从略。可以见更多中的Node入门。</p>
		<h3 id="node_more">更多</h3>
		<p><a href="https://nqdeng.github.io/7-days-nodejs/" target="_blank">七天学会NodeJS</a>，<a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank">Node入门</a></p>
		<hr>
		<h1 id="npm">npm</h1>
		<h3 id="npm_introduction">简介</h3>
		<p>npm是NodeJS随同安装的包管理工具。由于NodeJS使用模块组织工程的特点，npm能解决NodeJS部署上的很多问题。它允许用户从npm服务器下载别人编写的三方包到本地使用、允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用、允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</p>
		<p>同时，NPM还是NodeJS的开放式模块登记和管理系统。它构建了一个NodeJS模块平台，发挥了类似github的功能。</p>
		<h3 id="npm_install">安装</h3>
		<p>npm一般随NodeJS一起安装。安装后，可以通过<code>npm intall npm@latest –g</code>进行更新。<code>npm help</code>和<code>npm –l</code>可以查看npm的帮助信息。</p>
		<h3 id="npm_commands">常用命令</h3>
		<p><code><strong>npm init</strong></code>: 在项目文件根目录下，需要有<span class="i">package.json</span>来完成模块的开发说明。该命令可以初始化新的<span class="i">package.json</span>文件，通过询问的方式完成。使用参数<code>-f</code>和<code>-y</code>可以跳过询问。</p>
		<p><code><strong>npm set</strong></code>: 用来设置npm的环境变量，类似于<code>git config –global</code>。有<code>init-author-name</code> <code>init-author-email</code> <code>init-author-urllicense</code>等选项可供选择。针对某个项目有特殊设置时，可以另行<code>npm config</code>。</p>
		<p><code><strong>npm info</strong></code>: 查看模块具体信息。类似于查看<span class="i">package.json</span>。还可以查看字段信息。如，<code>npm info {{module_name}} description</code>。</p>
		<p><code><strong>npm search</strong></code>: 按照模块名搜索具体模块。npm的包名必须唯一。</p>
		<p><code><strong>npm list</strong></code>: 树形结构列出当前项目安装的模块和其依赖模块。可以跟<code>-global</code></p>
		<p><code><strong>npm install</strong></code>: 最常用的一个命令。安装可以选择本地（当前文件夹的<span class="i">node_modules</span>下）或全局。全局安装只适用于工具模块。该命令甚至支持通过github代码库地址安装。参数<code>-f</code>可以强制重新安装一个模块。删除<span class="i">node_modules</span>目录，执行该命令可以强制安装所有模块。</p>
		<p>在模块后，可以用<code>@</code>后接版本号安装特定版本，<code>latest</code>表示最新版，<code>beta</code>表示测试版。后接<code>--save</code>会添加<code>dependencies</code>到<span class="i">package.json</span>中。<code>--save-exact</code>可以添加确切版本。<code>--save-dev</code>添加到<code>devDependencies</code>中。可以简化为<code>-S</code>或<code>-D</code>。<code>--production</code>会安装<code>dependencies</code>中的依赖而不考虑<code>devDependencies。</code></p>
		<p><code><strong>npm update</strong></code>: 升级已安装的本地或者全局模块。<code>--depth</code>可以指定迭代的深度，升级依赖的依赖。</p>
		<p><code><strong>npm uninstall</strong></code>: 卸载已安装模块。</p>
		<p><code><strong>bpm run</strong></code>: 执行<span class="i">package.json</span>中的<code>scripts</code>字段对应的脚本。其中<code>npm run test</code>和<code>npm run start</code>可以简写成<code>npm test</code>和<code>npm start</code>。可以将脚本存成文件，在<code>scripts</code>字段中写上文件路径。同时，<code>npm run</code>执行的命令可以跟命令行参数。（实际上，<a href="http://gruntjs.com/" target="_blank">grunt</a>和<a href="http://gulpjs.com/" target="_blank">gulp</a>这样的工具就是完成此类工作）</p>
		<p><code>npm run</code>的每个命令都有两个钩子pre和post。在执行命令command之前，npm会检查是否有precommand，执行之后会检查是否有postcommand。同时<code>npm run</code>可以使用一些内部变量，如<span class="i">package.json</span>中的<code>name</code>字段可以用<code>$npm_package_name</code>代表。<code>config</code>字段里可以设置内部字段。</p>
		<p><code><strong>npm link</strong></code>: 将开发中的模块链接中本地的<span class="i">node_modules</span>中，方便边开发边使用。<code>npm unlink</code>可以删除符号链接。</p>
		<p><code><strong>npm bin</strong></code>: 执行本地<span class="i">node_modules/.bin</span>目录下的命令。</p>
		<p><code><strong>npm adduser</strong></code>: 在npmjs.com中添加一个用户。</p>
		<p><code><strong>npm publish</strong></code>: 发布模块，在拥有npm账户后。使用<code>npm login</code>登录，接着在本地目录下输入命令即可发布模块。<code>--tag</code>可以为发布模块添加标记</p>
		<p><code><strong>npm deprecate</strong></code>:  废弃某个版本或某个版本范围的模块，后面可以跟警告文本。如<code>npm deprecate mymodule@"&lt;0.2" "fix critical bugs"</code></p>
		<p><code><strong>npm owner</strong></code>: 管理模块的维护者。有<code>ls, add, rm</code>命令可以选择。</p>
		<p>其他的命令还有<code>npm install . –g</code>可用于发布包前的本地测试；<code>npm update cache clear</code>可以清空缓存；<code>npm unpublish {{package}}@{{version}}</code>可以撤销自己发布过的某个版本代码等。更多详细介绍见<a href="https://docs.npmjs.com/cli/" target="_blank">官网文档</a></p>
		<h3 id="npm_download">下载第三方包</h3>
		<p>使用命令<code>npm install {{module_name}}</code>，将包下载到node_modules后，直接使用<code>require({{module_name}})</code>即可加载第三方模块。同时，修改<span class="i">package.json</span>，添加<code>dependencies</code>项，即可批量加载第三方包，这样做的好处在他人加载你的模块时是非常明显的。用户只需关心自己直接使用的第三方包，而不需要自己解决依赖问题。</p>
		<h3 id="npm_install_cmd">安装命令行程序</h3>
		<p>方法和上面类似，如<code>npm install pug –g</code>(<code>-g</code>表示全局安装)，全局安装时，pug默认会安装到<span class="i"><strong>/usr/local(for Linux)</strong></span>或 <span class="i"><strong>%APPDATA%\npm(for Windows)</strong></span>下。npm会自动创建Linux下的软链和Windows下的<code>.cmd</code>文件。</p>
		<h3 id="npm_release">发布自己的包</h3>
		<p>需要在npm注册自己的账号，之后运行<code>npm adduser</code>。账号配置完成后，编辑<span class="i">package.json</span>文件，包括<span class="i">name, version, dependencies, main, bin, man</span>等内容，之后就可以在<span class="i">package.json</span>目录下运行<code>npm publish</code>发布代码了。<span class="i">package.json</span>下字段的更多解释参见<a href="https://docs.npmjs.com/files/package.json" target="_blank">官网文档。下面是一个<span class="i">package.json</span>的样例</a></p>
		<pre><code>{
    "name": "my_package",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "keywords": [],
    "author": "ag_dubs",
    "license": "ISC",
    "repository": {
        "type": "git",
        "url": "https://github.com/ashleygwilliams/my_package.git"
    },
    "bugs": {
        "url": "https://github.com/ashleygwilliams/my_package/issues"
    },
    "homepage": "https://github.com/ashleygwilliams/my_package"
}</code></pre>
		<h3 id="npm_version">版本号控制</h3>
		<p>npm使用语义版本号进行版本号控制。分<code>X.Y.Z</code>三位，分别代表主版本号，副版本号，补丁版本号。其中主版本号对下不兼容，有大变动，次版本号只是新增功能向下兼容，补丁版本号只是修复bug。</p>
		<p>在这个保证下，<code>dependencies</code>可以指定一定范围的版本码。包括>, >=, <, <=, ~, 0.0.x, *, -等等。</p>
		<h3 id="npm_sum_up">小结</h3>
		<p>npm是NodeJS自带的包管理工具。在复杂的工程背景下，通常需要使用许多的第三方包，在第三方框架下搭出可靠好用的应用。尤其在新技术层出不穷的web应用中，包管理成了很重要的一个环节。对于使用模块构建工程的NodeJS，NPM这样的包管理工具将更有利于它的发展和开发者的使用。</p>
		<h3 id="npm_more">更多</h3>
		<p><a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank">npm模块管理器</a></p>
		<hr>
		<h1 id="bower">Bower</h1>
		<h3 id="bower_introduction">简介</h3>
		<p><a href="https://bower.io/" target="_blank">Bower</a>由<a href="https://twitter.com/" target="_blank">twitter</a>推出，是一个和<a href="https://www.npmjs.com/" target="_blank">npm</a>功能十分类似的包依赖管理软件。不同的是，npm管理整个工程项目的包依赖，而Bower专注于前端各网络资源的管理。它可以帮助快速搭建起前端以来环境，并管理各组件的版本状态。</p>
		<p>和npm类似，Bower使用<span class="i">bower.json</span>作为项目配置文件中。使用<code>bower install</code>命令时，后面可以跟包名、github路径、git仓库路径、url或者干脆不要参数。Bower本身的配置文件为项目根目录下的<span class="i">.bowerrc</span>，通过<code>directory, json, endpoint, searchpoint, shorthand_resolver</code>指定了存放库文件的目录、描述库的json文件名，搜索库文件的路径，备选路径，库名称简写形式。下面是一个<span class="i">bower.json</span>的样例: </p>
		<pre><code>{
    "name": "app-name",
    "version": "0.0.1",
    "dependencies": {
        "sass-bootstrap": "~3.0.0",
        "modernizr": "~2.6.2",
        "jquery": "~1.10.2"
    },
    "private": true
}		</code></pre>
		<h3 id="bower_usage">使用</h3>
		<p>通过<code>npm intall bower –g</code>全局安装bower，以便可以使用bower命令。通过<code>bower help</code>可以查看所有的bower命令。bower命令和npm命令是很类似的。有<code>init, install, cache, search, list, info, uninstall</code>等命令。Bower在下载依赖包时，会保存一份到缓存中，通过<code>bower cache list</code>查看。</p>
		<h3 id="bower_question">Bower or npm?</h3>
		<p>由于前后端资源特点的不同，npm基于CommonJS的规范开发，是利于后端模块的依赖管理的，通过<span class="i">package.json</span>管理树形的依赖结构，模块间用require、export沟通。而这在带宽紧张的前端是不完全适合的，前端更需要扁平和松散的依赖关系，减少文件的传输次数。因此，使用简单的Bower在推出后，收到了很大欢迎。但是Bower的缺陷也很明显，bower管理松散、缺乏统一的构建机制。包的格式并没有限制，只通过<span class="i">bower.json</span>沟通。同时，bower缺少npm那样的registry，而直接取用github。</p>
		<p>在Browserify, Webpack这样的工具出现后，使用npm管理前端时，不会出现CommonJS的规范下加上其他规范模块的不伦不类感。未来前后端包依赖统一管理的趋势是必然的，在node良好的生态环境下，使用npm统一管理似乎是更受欢迎的。</p>
		<p>更多的讨论间<a href="https://www.zhihu.com/question/24414899" target="_blank">知乎话题</a>。</p>
		<hr>
		<h1 id="browserify">Browserify</h1>
		<h3 id="brow_intro_usage">简介与使用</h3>
		<p>如在Bower中提到的，浏览器端的文件并没有CommonJS这样的构建规范。因此，在使用npm管理时显得不伦不类。Browserify是node的一个插件，允许使用<code>require</code>的句法书写浏览器端的文件。通过<code>browserify</code>命令将入口文件打包输出，即可建立一个统一的依赖环境，且可以在html中只使用一条script或link等引入。</p>
		<p>假设我们项目需要<a href="http://backbonejs.org/" target="_blank">backbone.js</a>和<a href="https://jquery.com/" target="_blank">jQuery</a>两个模块。首先，通过<code>npm install –g browserify</code>全局安装它。之后新建<span class="i">main.js</span>文件，将服务器端backbone模块转为客户端（即浏览器端）模块。先安装backbone和jquery模块，在main.js中写下如下内容：</p>
		<pre><code>// main.js
var Backbone = require('backbone');
var $ = Backbone.$ = require('jquery/dist/jquery')(window);

var AppView = Backbone.View.extend({
  render: function(){
    $('main').append('&lt;h1>Browserify is a great tool.&lt;/h1>');
  }
});
var appView = new AppView();
appView.render();
</code></pre>
		<p>之后使用browserify将main.js转为app.js:<code>browserify main.js –o app.js</code>。就可以通过<pre><code>&lt;script src=app.js>&lt;/script></code></pre>完成插入。</p>
		<h3 id="brow_manage_generate">管理与生成</h3>
		<p>使用browserify可以将CommonJS转为浏览器可以调用的格式(如上文)，同时，它也可以对纯粹的前端模块打包，然后再html中通过一行命令完成调用。使用<code>browserify-shim</code>支持jQuery等的CDN加载。使用<code>parcelify</code>模块可以对插件自带的css文件进行打包。</p>
		<p>Browserify指定<code>-r</code>参数，还可以在打包模块的同时，为浏览器提供require方法。Browserify还支持实时生成脚本文件，通过browserify的bundle方法写在js文件里。</p>
		<p>更多内容请参考<a href="http://javascript.ruanyifeng.com/tool/browserify.html" target="_blank">阮一峰的Javascript参考教程。</a></p>
		<hr>
		<h1 id="webpack">Webpack</h1>
		<p>类似于Browserify，Webpack也是前端资源管理和打包工具，不过适用范围更广。它可以将松散的有依赖关系的前端资源打包成单一文件，根据loader的不同，它可以将CommonJS, AMD, ES6, CSS, 图片, JSON等视作模块。</p>
		<h3 id="webpack_why">Why</h3>
		<p>现有的模块管理和打包工具(包括commonJS，CMD等)不能很好地对模块进行无缝整合生成适合浏览器端请求的的静态资源。在以下方面发挥不良：<ul>
			<li>拆分依赖树为按需加载的模块</li>
			<li>减少初始化加载时间</li>
			<li>将各种静态资源视为模块</li>
			<li>自定义打包逻辑</li>
		</ul>
		从而，webpack有着以下特点：<ul>
			<li>webpack支持同步和异步两种组织模块依赖的方法</li>
			<li>webpack只能处理原生js模块，但是loader转换器可以将其他资源转换成js模块</li>
			<li>webpack几乎可以处理所有第三方库，甚至运行使用动态表达式加载依赖</li>
			<li>webpack有丰富的插件和高速的运行效率</li>
		</ul>
		</p>
		<h3 id="webpack_usage">安装使用</h3>
		<p>通过npm全局安装<code>npm install webpack –g</code>或安装到项目依赖<code>npm install webpack –save-dev</code>。在全局安装下，我们可以通过webpack命令打包文件。根据官方样例，若有<span class="i">module.js</span>和<span class="i">entry.js</span>如下：</p>
		<pre><code>// module.js
module.exports = 'It works from module.js.'
// entry.js
document.write('It works.')
document.write(require('./module.js')) // add module
</code></pre>
		<p>通过<code>webpack entry.js bundle.js</code>命令将文件打包，并在html文件中引入。在页面启动后，会先启动<span class="i">entry.js</span>中的代码，其他的模块会在运行到require时再执行。</p>
		<p>借助<span class="i">loader</span>，webpack可以处理非javascript资源，从而通过require命令引入其他类型的模块或文件。<span class="i">loader</span>本身是一个函数，它以管道的方式调用，将资源转换格式再传递给下一个<span class="i">loader</span>，但是最后一个<span class="i">loader</span>必须返回js。<span class="i">loader</span>可以接受参数，且作为模块运行在nodejs环境中。因此我们可以通过npm来管理<span class="i">loader</span>或在项目中自己写<span class="i">loader</span>模块。</p>
		<p>如导入css文件时，指定<code>css-loader</code>来读取它，再用<code>style-loader</code>将它插入到页面中，通过命令<code>require("!style!css!./style.css")</code>即可，或在webpack命令后使用参数<code>--module-bind css=style!css</code>。</p>
		<h3 id="webpack_config">配置文件</h3>
		<p>Webpack在执行时，除了命令行参数，默认会搜索当前目录下的<span class="i">webpack.config.js</span>文件。这个问价有着类似于<span class="i">package.json</span>的功能。也可以通过<code>—config</code>手动指定配置文件位置。例如，我们可以创建以下配置文件，替代上文的做法：</p>
		<pre><code>var webpack = require('webpack')

module.exports = {
    entry: './entry.js',
    output: {
        path: __dirname,
        filename: 'bundle.js'
    },
    module: {
        loaders: [
            {test: /\.css$/, loader: 'style!css'}
        ]
    }
}		</code></pre>
		<p>此外，借助插件可以完成更多<span class="i">loader</span>之外的功能，在配置文件中指定<code>plugins</code>属性即可。实际上除了上面介绍的，配置选项还有很多（上面介绍的更常用），如<code>watch, debug</code>等等，参见<a href="http://webpack.github.io/docs/configuration.html" target="_blank">官方文档</a>对配置文件的讲解。</p>
		<h3 id="webpack_more">更多</h3>
		<p>在开发环境下，还有<code>webpack-dev-server</code>辅助浏览项目中的页面和资源输出，并可以在浏览器中的<a href="http://localhost:8080/webpack-dev-server/" target="_blank">localhost:8080/webpack-dev-server/</a>位置下查看进度。详情可以查看<a href="https://webpack.github.io/" target="_blank">官网</a>。</p>
		<p>本节内容大多参考官网和<a href="http://zhaoda.net/webpack-handbook/index.html" target="_blank">Webpack中文指南</a>。个人认为这种工具型的技术实操学习起来更快。</p>
		<hr>
		<h1 id="grunt">Grunt</h1>
		<h3 id="grunt_tutorial">入门</h3>
		<p>在JS开发的过程中，经常会遇到一些重复性工作，如压缩代码，检查语法错误，将Sass文件转成CSS文件等。Grunt就是便于我们自动管理和运行任务的自动任务运行器。它会按照预定顺序执行它们，简化重复性工作的负担。</p>
		<p>使用grunt前，需要使用npm命令将<code>grunt-cli</code>全局安装。需要注意的是，<code>grunt-cli</code>是通过组织安排其他grunt组件起到组建作用的。使用grunt时，需要在工程目录下添加<span class="i">package.json</span>和<span class="i">Gruntfile</span>两份文件，它们分别用来便于将项目发布为npm模块和配置和定义任务并加载Grunt插件。通常，最好在<span class="i">package.json</span>中间添加grunt插件的依赖。</p>
		<h3 id="gruntfile">Gruntfile</h3>
		<p><span class="i">Gruntfile</span>由<code>wrapper</code>函数、项目于任务配置、加载grunt插件和任务、自定义任务及部分构成。下面就是一个<span class="i">Gruntfile</span>的文件案例，加载<code>grunt-contrib-uglify</code>压缩资源文件。</p>
		<pre><code>module.exports = function(grunt) {

    // Project configuration.
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        uglify: {
            options: {
                banner: '/*! <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> */\n'
            },
            build: {
                src: 'src/<%= pkg.name %>.js',
                dest: 'build/<%= pkg.name %>.min.js'
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-uglify');

    grunt.registerTask('default', ['uglify']);

};		</code></pre>
		<p><ul>
			<li><code>Wrapper</code>函数：上文中的<code>module.export = function(grunt){}</code>部分。每一个<span class="i">Gruntfile</span>都遵循此格式，所写的grunt代码必须放在此函数的代码块内。</li>
			<li>项目和任务配置：通过<code>grunt.initConfig()</code>将grunt任务所需要的配置对象写在输入参数里面。理论上，这个对象可以存储任意的数据。在上面的案例里，通过<code>grunt.file.readJSON</code>将<span class="i">package.json</span>中的元数据引入到<code>grunt config</code>。并通过制定<span class="i">uglify</span>的属性，配置<span class="i">uglify</span>任务。</li>
			<li>加载grunt插件与任务：通过<code>grunt.loadNpmTasks({{plugin_name}})</code>使用已用npm安装的grunt插件。<code>grunt –help</code>将列出所有可用的任务。</li>
			<li>自定义任务：即上文中的<code>grunt.registerTask()</code>，指定grunt的默认任务，在grunt命令后没有任务时，默认执行<span class="i">uglify</span>任务。实际上，还可以通过<code>grunt.loadTasks</code>加载定义好的外部任务。</li>
		</ul></p>
		<h3 id="grunt_config">任务配置</h3>
		<p>当运行一个任务时，grunt会自动查找配置对象中的同名属性。在同名属性下甚至可以定义不同的target针对不同任务环境，通过grunt {{task_name}}:target的形式访问。在普通环境下grunt会默认执行所有target。同时，在任务配置中，任务的<code>options</code>属性可以覆盖默认值，在不需要的时候可以忽略。</p>
		<p>在文件操作中，grunt通过src-dest的形式定义文件映射，并提供了不同程度的描述和控制。在简洁格式下，通过为target至此那个src和dest属性完成src-dest映射。这种格式支持个每个映射指定额外属性。文件对象格式下，则是用目标文件名做属性名，源文件列表做它的值，这种方式可以指定多个映射，但是不能给每个映射指定附加属性。文件数组格式支持对应多个映射，且允许每个映射拥有额外属性。下面是它们的一些样例。</p>
		<pre><code>grunt.initConfig({
    jshint: {
        foo: {
            src: ['src/aa.js', 'src/aaa.js']
        },
    },
    concat: {
        foo: {
            files: {
                'dest/a.js': ['src/aa.js', 'src/aaa.js'],
                'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'],
            },
        },
        bar: {
            files: [
                {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true},
                {src: ['tmp/**/*'], dest: 'dest/tmp/', filter: 'isFile'},
            ],
        }
    }
});		</code></pre>
		<p>上面concat的<code>bar</code>目标中，使用了<code>filter</code>过滤函数找到<span class="i">tmp</span>目录下的所有文件还可以创建自己的过滤函数。Grunt支持在<code>src</code>中通过通配符指定源文件路径，关于通配符模式的语法，可以参见grunt中文文档。当源文件数目很多，难以一一列出时，可以通过<code>dynamic_mappings</code>动态指定文件映射关系。</p>
		<p>使用<code><% %></code>分隔符指定的模板会从配置文件中读取响应数据来填充。因此，在其中写入grunt命令甚至也是可行的。之前案例里，也是通过<code>grunt.file.readJSON</code>读入外部文件导入配置的。</p>
		<h3 id="grunt_example">配置实例</h3>
		<p>假设我们的某个项目需要<a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank">grunt-contrib-uglify</a>, <a href="https://github.com/gruntjs/grunt-contrib-qunit" target="_blank">grunt-contrib-qunit</a>, <a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank">grunt-contrib-concat</a>, <a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank">grunt-contrib-jshint</a>, <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank">grunt-contrib-watch</a>这5个插件。首先，我们写好<code>wrapper</code>函数和初始化<code>configuration</code>对象。并通过<pre><code>pkg: grunt.file.readJSON(package.json)</code></pre>将<span class="i">package.json</span>中的项目配置信息读进来。接着，我们需要逐一配置上面各插件。</p>
		<p>Concat插件功能是将依赖的所有资源文件打包，通过指定o<code>ptions</code>中的<code>separator</code>属性可以更改默认的合并输出文件间的分隔符，指定<code>dist</code>属性，确定将要合并的文件和合并后文件的存放位置。例如我们可以如下配置，将所有文件合并为与项目名同名的输出文件。</p>
		<pre><code>concat: {
    dist: {
        src: ['src/**/*.js'],
        dest: 'dist/<%= pkg.name %>.js'
    }
}		</code></pre>
		<p>Uglify插件用来压缩JS文件。我们可以指定<code>options</code>中的<code>banner</code>给出压缩文件的注释。可以简单地用文件对象的格式确定输入输出。这里我们将concat插件链接的这些文件压缩成一个<code>.min.js</code>文件。示例如下：</p>
		<pre><code>uglify: {
    options: {
        banner: '/*! <%= pkg.name %> <%= grunt.template.today("dd-mm-yyyy") %> */\n'
    },
    dist: {
        files: {
            'dist/<%= pkg.name %>.min.js': ['<%= concat.dist.dest %>']
        }
    }
}		</code></pre>
		<p>QUnit插件用来进行单元测试，只需为它指定用于测试的文件位置即可。示例如下：</p>
		<pre><code>qunit: {
    file: [‘test/**/*.html’]
}		</code></pre>
		<p>JSHint插件可以检查代码中的潜在错误(即<code>lint</code>)。<code>Files</code>属性里是<code>lint</code>的对象。实例如下：</p>
		<pre><code>jshint: {
    // define the files to lint
    files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
    // configure JSHint (documented at http://www.jshint.com/docs/)
    options: {
            // more options here if you want to override JSHint defaults
        globals: {
            jQuery: true,
            console: true,
            module: true
        }
    }
}		</code></pre>
		<p>Watch插件用于检测指定文件的变化，在它们变化时执行指定的任务。只需指定<code>files</code>属性和<code>tasks</code>属性即可。</p>
		<p>最后的最后，通过<code>grunt.loadNpmTasks()</code>将插件导入，并<code>registerTask</code>注册所需的任务，尤其是<code>default</code>任务（当然也可以注册其他可选任务）。</p>
		<h3 id="grunt_task">任务与插件</h3>
		<p>启动grunt时，默认附带要执行的任务，当不跟参数时，执行<code>default</code>任务。通过<code>registerTask</code>确定任务名和任务列表。如上面的一些例子。</p>
		<p>使用<code>grunt.registerMultiTask()</code>还可以创建多任务，它通过输入的属性名和目标名执行任务，并在未指定目标时执行所有目标。在自定义任务时，可以通过<code>grunt.task.run</code>执行其他任务，还可以访问自身的参数如名称、输入参数做相应处理。通过<code>grunt.task.require()</code>检查依赖任务执行成功与否或配置属性是否存在。</p>
		<p>在grunt 0.4的版本下，<code>grunt-init</code>被拆分成独立的模块，可以通过npm安装。通过grunt插件模板可以创建自己的grunt插件，用类似于npm的形式部署和发布。在发布时，注意命名空间。</p>
		<p><strong>Grunt cli</strong>是grunt的命令行工具。全局安装后，通过<code>grunt –h</code>即可查看grunt的所有命令。</p>
		<h3 id="grunt_more">更多</h3>
		<p><a href="http://www.gruntjs.net/getting-started" target="_blank">Grunt的中文文档</a>介绍得很好，可用作入门。</p>
		<hr>
		<h1 id="gulp">Gulp</h1>
		<h3 id="gulp_tutorial">入门</h3>
		<p>Gulp是个grunt功能类似的自动化构建工具。它利用Node.js的流概念，在管道中传输数据流，从而完成项目构建。同样使用<code>npm install –global</code> glup全局安装gulp组件，或作为项目开发依赖使用<code>--save-dev glup</code>安装。接着在项目的根目录下新建<span class="i">gulpfile.js</span>的文件，写入<code>glup.task(default, function(){})</code>来定义任务，并通过glup命令执行。还可以通过<code>glup &lt;task1> &lt;task2></code>执行系列任务</p>
		<h3 id="gulp_api">常用API</h3>
		<p>为了简化用户的使用难度，gulp的API用法很简洁，数目也很少。</p>
		<p><code><strong>gulp.src(globs[, options])</strong></code>。输出符合glob匹配模式或匹配模式数组的文件，并返回一个stream可以被pipe方法传递到别的插件中。Glob的写法和Grunt类似。Options中可以选择<code>buffer, read, base</code>等属性，更改读取格式等。以下是样例。</p>
		<pre><code>gulp.src('client/templates/*.jade')
    .pipe(jade())
    .pipe(minify())
    .pipe(gulp.dest('build/minified_templates'));
</code></pre>
		<p><code><strong>gulp.dest(path[, options])</strong></code>。可以被<i>pipe</i>进来，将会写入文件，且重新输出所有数据。因此可以继续将它<i>pipe</i>到多个文件。若文件夹不存在将会自动创建。样例如下：</p>
		<pre><code>gulp.src('./client/templates/*.jade')
    .pipe(jade())
    .pipe(gulp.dest('./build/templates'))
    .pipe(minify())
    .pipe(gulp.dest('./build/minified_templates'));
</code></pre>
		<p><code><strong>gulp.task(name[, deps], fn)</strong></code>用来定义一个使用<i>orchestrator</i>实现的任务。<code>name</code>指定任务名，<code>deps</code>指定任务列表数组，这些任务会在当前任务之前完成。<code>fn</code>表示任务要执行的一些操作。在<code>fn</code>接受一个<code>callback</code>，返回一个<code>stream</code>或返回一个<code>promise</code>时，允许任务异步执行。默认下，gulp会一次性运行所有<code>task</code>且不做等待。因此，若想创建一个序列化<code>task</code>队列，需要1）给出提示告知<code>task</code>依赖另一个<code>task</code>完成。样例如下:</p>
		<pre><code>var gulp = require('gulp');

gulp.task('one', function(cb) {
	//do something
    cb(err);
});

gulp.task('two', ['one'], function() {
    // 'one' finshed
});

gulp.task('default', ['one', 'two']);
</code></pre>
		<p><code><strong>gulp.watch(glob[, opts], tasks)</strong></code>或<code><strong>gulp.watch(glob[, opts, cb])</strong></code>。监视文件，并在文件改动时做一些事情。它会返回一个<code>EventEmitter</code>释放<code>change</code>事件。其中<code>tasks</code>为在文件变动后执行的一个或多个<code>gulp.task()</code>名字。用法如：</p>
		<pre><code>var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);
watcher.on('change', function(event) {
    console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});		</code></pre>
		<p>后者的用法则是，在<code>cb</code>中指定每次变动需要执行的<code>callback</code>。这个<code>callback</code>会被传入一个<code>event</code>对象描述监控到的变动。有如<code>path, type</code>这样的属性。其中<code>type</code>表示变动类型，有<code>added, changed, deleted</code>等。</p>
		<p><code>gulp.run</code>可以最大并行化执行系列的任务列表。</p>
		<h3 id="gulp_cli">CLI使用</h3>
		<p>常用的gulp参数很有限。<code>-v</code>显示gulp版本，<code>--require &lt;path></code>在执行前require一个模块，可以多次使用，<code>--gulpfile &lt;path></code>手动指定<span class="i">gulpfile</span>路径，<code>--cwd</code>指定<span class="i">gulpfile</span>开始查找的位置，<code>--tasks</code>显示task依赖树。<code>--color</code>强制显示颜色，<code>--no-color</code>强制不显示颜色，<code>--silent</code>禁止所有日志输出。</p>
		<p>task通过<code>gulp &lt;task name></code>来执行。只执行gulp，则会执行注册名为<code>default</code>的task.</p>
		<h3 id="gulp_more">更多</h3>
		<p>Gulp是基于流的自动构建系统。相对grunt结构简单，学习成本低。文件里存放代码而非配置。<a href="http://slides.com/contra/gulp" target="_blank">作者的幻灯片</a>里做了简明扼要地解释。想要更深入的学习，可以参加中文版的<a href="https://github.com/jabez128/stream-handbook" target="_blank">stream-book</a>对nodeJS流的介绍。在杂项里的<a href="stream">"Nodejs中的Stream"</a>也有做的笔记。</p>
		<hr>
		<h1 id="commonjs">CommonJS</h1>
		<h3 id="common_brief">简介</h3>
		<p>CommonJS的目标是在浏览器环境外构建JS生态系统，出现于2009年。官方的JS标准API是为了构建基于浏览器的应用程序，这限制了JS的更广泛应用。CommonJS定义了更多普通应用的API，它的终极目标是进行JS模块化，把JS提升到类似于Python、Ruby、Java的地位。只要环境兼容，使用CommonJS API编写的应用程序就可以通用。</p>
		<p>而实际上，NodeJS就是CommonJS模块化规范的一种实现。规范还在不断的发展中。以下展示部分内容</p>
		<h3 id="common_feature">特点</h3>
		<p><ul>
			<li>一个文件就是一个独立的作用域，只能通过global共享（不推荐）</li>
			<li>通过<code>exports</code>定义对外接口，通过<code>require</code>加载此接口</li>
			<li>模块可以多次加载，但只在第一次加载时运行并缓存。</li>
			<li>模块加载的顺序和代码中出现顺序一致。</li>
		</ul></p>
		<h3 id="common_module">Module</h3>
		<p>每个模块内部都有一个<code>module</code>对象，对象有<code>id, filename, loaded, parent, children, exports</code>等属性。这些在nodeJS中都有实现。</p>
		<p><code>module.export</code>用于向外导出模块信息。Node中为每个模块提供了一个<code>exports</code>变量预绑定到<code>module.export</code>上，通过<code>exports.xxx</code>的形式导出。破坏这个绑定关系的操作都将使<code>exports</code>变量无效。</p>
		<h3 id="require">Require</h3>
		<p><code>require</code>用于加载模块文件，它会读入并执行一个Javascript文件，然后返回<code>exports</code>对象，如果未发现指定模块会报错。同时，加载的模块的输入时被输出值的拷贝。</p>
		<p><code>require</code>加载模块时，默认为js文件。若路径以<code>/</code>开头表示绝对路径，以<code>./</code>开头表示相对路径，否则node会去<span class="i">node_modules</span>目录下查找。使用<code>require.resolve</code>可以看到确切结果。在找到目录后，会将<span class="i">package.json</span>中的<code>main</code>对应的值作为入口文件。</p>
		<p><code>require</code>进来的模块会放在缓存中，不会多次加载。若想多次执行同一模块，可以用<code>module.exports</code>导出函数，或<code>delete require.cache[moduleName]</code></p>
		<p>模块循环加载时，会先加载不完整的版本，在都<code>require</code>进来后，通过缓存读取<code>exports</code>避免不全的问题。</p>
		<h3 id="amd">AMD and more?</h3>
		<p>CommonJS主要是为JS在后端表现定制的，而浏览器和服务器端的特点是不一样的。<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)" target="_blank">AMD</a>的规范主要为前端JS表现定制。前者加载模块是同步的，后者是异步的。</p>
		<p>AMD规范使用<code>define</code>方法闭包定义模块，格式类似于<pre><code>define(id?: String, dependencies?: String[], factory: Function|Object);</code></pre></p>
		<p><code>id</code>是模块名，可选。<code>dependencies</code>是依赖模块列表。<code>function</code>是模块的具体实现，它的返回值就是模块的输出接口或值。范例如下：</p>
		<pre><code>define('myModule', ['jquery'], function($) {
    return $('body').text('hello world');
});
define(['myModule'], function(myModule) {});
</code></pre>
		<p>其中<code>function</code>的输入参数即为依赖模块的输出。通常将没有id的匿名模块作为应用的启动函数。</p>
		<p>AMD规范允许输出模块兼容CommonJS规范。</p>
		<p><a href="http://requirejs.org/" target="_blank">RequireJS</a>就是采用了AMD规范的用于模块以来的工具，使用方式同上面的范例。正如AMD名字中提到的那样，它异步引入所有的依赖模块，减少的导入的时间。同时也会因此出现隐式的难以发现的错误。与之并列的还有基于CMD规范的<a href="http://seajs.org/docs/" target="_blank">SeaJS</a>，主旨所限，从略。</p>
		<h3 id="common_more">更多</h3>
		<p>CommonJS实际上是JS模块化的一种体现。这也是JS发展的趋势。关于JS模块化编程的介绍见<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">模块的写法</a>，<a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank">AMD规范</a>，<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html?bsh_bid=230697246">require.js用法</a>。这三篇博客系统地讲解了模块化的思路和应用。另外还有<a href="http://www.cnblogs.com/skylar/p/4065455.html" target="_blank">CommonJS,AMD,CMD对比</a>，<a href="http://zhaoda.net/webpack-handbook/amd.html" target="_blank" 
		>AMD使用样例</a>，<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank">Node中CommonJS的部分实现</a>可以参考。</p>
		<hr>
		<h1 id="backbone">Backbone.js</h1>
		<h3 id="backbone_brief">概述</h3>
		<p>MVC框架是代码组织的经典模式，便于团队协作进行开发。M、V、C分别代表Model，View和Controller。同样在Javascript的社区中，也有着许多MVC和MVC变体框架MV*（下面介绍的AngularJS等）。框架的优点在于便于分工和和代码维护，缺点在于限制了代码的写法，且学习成本一般较高。</p>
		<p><a href="http://backbonejs.org/" target="_blank">Backbone.js</a>提出于2010年，它严格来说并不算是MV*框架，而是借助一些功能模块的帮助快速构建一个单页面Web应用。因此它给用户了很大的自由在<code>Model</code>和<code>View</code>的连接上。从它的API结构就能看出，<code>Model</code>和<code>View</code>部分是较重的，<code>Controller</code>部分则只由<code>router</code>和<code>router</code>对应的<code>controller</code>处理函数构成。相对来说，backbone.js的体积很小，且学习成本较低。</p>
		<p>根据官网介绍，<a href="http://underscorejs.org/" target="_blank">underscores.js</a>（一个功能型js函数库）是backbone.js的强依赖，jquery和<a href="https://www.npmjs.com/package/json2js" target="_blank">json2.js</a>是backbone用于Backbone.View的依赖，但是有类似<a href="http://zeptojs.com/" target="_blank">Zepto</a>等替代方案。因此在使用backbone.js时，通常要引入这四个文件。</p>
		<h3 id="backbone_structure">项目组成</h3>
		<p>一般来说，一个backbone.js的应用，由<code>models, views, collections, controllers</code>四部分组成。其中<code>models</code>用来描述数据的一个基本单位。如下：</p>
		<pre><code>App.Models.Person = Backbone.Model.extend({
    defaults: {
        "name": "foo",
        "value": "bar"
    }
});		</code></pre>
		<p><code>Colletions</code>是同一种<code>model</code>的集合，可以方便地表示列表等展示方式，如下：</p>
		<pre><code>App.Collections.Grade = Backbone.collection.extend({
    model: App.Models.Person
});		</code></pre>
		<p>上面的代码表示，<code>Grade</code>这个集合由<code>Person</code>单元组成。View部分用来在页面上呈现数据，呈现中涉及到绑定DOM的工作大多由jquery完成，View部分必须有<code>el</code>属性，指定绑定的DOM节点，<code>events</code>指定监听事件和对应方法，<code>initialize</code>和<code>render</code>方法分别完成初始化和渲染两个步骤。</p>
		<pre><code>App.Views.Medals = Backbone.View.extend({
    el: "#list",

    initialize: function() {
        this.listenTo(Person, 'change', this.render);
        this.listenTo(Person, 'destroy', this.remove);
        this.render();
    },

    render: function() {
        var template = _.template($('item-template').html());
        this.$el.html(template(Person.Medals.toJSON()));
    },

    events: {
        "click .toggle"     : "toggle",
        "dbclick .view"     : "edit",
        "click a.destroy"   : "clear",
        "blur .edit"        : "close"
    }
})		</code></pre>
		<p>控制器一般用来相应路由的结果，定义比较自由，例如下面的形式：</p>
		<pre><code>App.Controllers.show = function(id) {
    var p = new App.Models.Person({id: id});
    p.updateTime(Date.now());
    p.fetch(function(model,response,options){
        var view = new App.Views.Medals({medal: p});
    });
};		</code></pre>
		<p>最后路由方面。通过继承backbone的<code>router</code>模块实现：</p>
		<pre><code>var paths = Backbone.Router.extend({
    routes: {
        ""                  : "wholeApp",
        "users/:id"         : "usershow",
        "users/:id/p:order" : "ordersIndex"
    },

    wholeApp    : App.Controller.default,
    usershow    : App.Controller.show,
    ordersIndex : App.Controller.orderBy
});
new paths();
Backbone.history.start({pushState: true});
</code></pre>
		<p>在定义好路由部分后，通过backbone的<code>history</code>模块的<code>start</code>方法启动路由即可。一个基于Backbone.js构造的项目结构大抵如此，它们可以位于同一个文件下（一般案例完全可以这么做）甚至位于html的script标签内。诚然这便于中小型项目，尤其是单页面逻辑内容丰富的Web应用开发使用，不也和当前流行的组件化、模块化的js开发风格有所不同。目前backbone.js仍然在1.x版本，可能会在2.0版本后采用ES6的原生模块化方案等新js特性吧。</p>
		<h3 id="backbone_api">API介绍（v1.3.3）</h3>
		<p>Backbone官网对它的API有着详细的介绍，且页面风格与Zepto、underscore一致，非常便于阅读和检索。</p>
		<h4 id="backbone_view">View</h4>
		<p><code>Backbone.View</code>的方法用来定义视图类，其中最根本的方法extend拓展定义一个视图类，类的内部通常由<code>render</code>方法渲染界面，渲染时使用类jquery的语法，插入一些html比群标签或计算后的内容。定义好视图类后，通过新建视图实例的形式运行，得到结果，新建时，<strong>有时需要指定<code>Model</code></strong>。</p>
		<p>在需要用到<strong>模板</strong>时，可以先通过underscore(简写符为'<code>_</code>')的<code>template</code>方法导入模板为函数。模板通常建议用<code>&lt;script></code>并指定<code>type=text/template</code>的定义在html文档中，并用jquery的语句获取。导入模板后，可以把数据的json格式输入到函数中。</p>
		<p><ul>
			<li><code><strong>extend(properties[, class properties])</strong></code>：用来创建视图类，有时不在配置中指定<code>el</code>，而通过<code>tagName</code>或是<code>className</code>指定列表中的各元素</li>
			<li><code><strong>initialize([options])</strong></code>：在实例化视图类的时候调用，可以写入<code>el</code>的属性。</li>
			<li><code><strong>el</strong></code>属性：指定视图所绑定的网页元素（通常用在<strong>单例视图类</strong>中），<code>$el</code>则表示<code>el</code>所对应的jquery对象。</li>
			<li><code><strong>tagName, className</strong></code>属性：见上面介绍</li>
			<li><code><strong>template</strong></code>方法：通过_.template(xxx)指定网页模板生成模板函数，在<code>render</code>中渲染。</li>
			<li><code><strong>events</strong></code>属性：指定视图中的事件及其对应的处理函数</li>
		</ul></p>
		<p>另外，还有<code>setElement</code>更改<code>el</code>，<code>remove</code>移除<code>el</code>和jquery自带的一些方法可以使用。</p>
		<h4 id="backbone_event">Events</h4>
		<p><code>Backbone.Events</code>是一个事件对象，任何继承这个对象的对象，都具有<code>Backbone.Events</code>接口，可以使用<code>on</code>和<code>trigger</code>等方法，发布和订阅消息。</p>
		<pre><code>// use extends
var EventListener = _.extend({}, Backbone.Events);
//use clone
var Dispatch = _.extend(Backbone.Events);
</code></pre>
		<ul>
			<li><code><strong>on(event, callback, [context])</strong></code>方法。可以将回调函数绑定在对象的一些事件上，并可以通过<code>off</code>方法取消绑定。<code>once</code>方法绑定的事件只触发一次回调函数。</li>
			<li><code><strong>trigger(event, [*args])</strong>可以触发特定事件。</code></li>
			<li><code><strong>listenTo(other, event, callback)</strong></code>可以把对象绑定在其他对象的事件上，经常用在View视图类中。如<code>view.listenTo(model, 'change', view.render);</code></li>
		</ul>
		<p>Backbone提供了许多内建的事件，如<code>add, remove, update, change, reset, change:[attr], destroy</code>等，更多的参加<a href="http://backbonejs.org/#Events-catalog" target="_blank">官方文档</a>。</p>
		<h4 id="backbone_router">Router</h4>
		<p><code>Router</code>是backbone提供的路由对象，用于将用户请求的url和后台函数一一对应。同样，它也通过<code>extend</code>方法定义。</p>
		<ul>
			<li><code><strong>routes</strong></code>属性：通过键值对形式指定路径和函数名。空字符串代表根路径，<code>*</code>代表任意路径，同时也可以通过":"设置路径参数，这些参数会被捕获并传入处理函数。同样可以用<code>route</code>函数一条条定义路由。</li>
			<li><code><strong>navigate(fragment, [options])</strong></code>：调转到新页面，这是<code>trigger</code>和<code>replace</code>属性可以保留url和浏览器记录。</li>
			<li><code><strong>execute(callback, args, name)</strong></code>：在每次路由时都会调用，通过<code>callback</code>的返回值是否为真，判断是否调用处理函数，如下：</li>
		</ul>
		<pre><code>var Router = Backbone.Router.extend({
    execute: function(callback, args, name) {
        if (!loggedIn) {
            goToLogin();
            return false;
        }
        args.push(parseQueryString(args.pop()));
        if (callback) callback.apply(this, args);
    }
});		</code></pre>
		<p>路由类设置好后，实例化之，并通过<code>Backbone.history.start()</code>启动。通常需要指定<code>pushState</code>为<code>true</code>。如果应用程序不在根目录，还需要设置<code>root</code>值。</p>
		<h4 id="backbone_model">Model</h4>
		<p><code>Model</code>代表单一的对象。和<code>Collection</code>一起组成Model层。Backbone.js并不要求Model的数据位于本地，在使用<code>fetch()</code>等操作时，backbone的sync方法默认会用jquery的<code>get</code>方法等去获取。所以，很多本地存储数据的应用会重写<code>Backbone.sync</code>函数。</p>
		<p>Model依旧使用<code>extend</code>方法生成类，和view类似使用<code>new</code>创建实例，可以在<code>defaults</code>属性中设置默认属性。在生成实例时，需要提供各属性的具体值，且需要有主键字段，便于和MangoDB等数据库互动。</p>
		<ul>
			<li><code><strong>get(attr)，set(attr,[options])</strong></code>分别用来获取和设置该实例的值。在有特殊字符防止xss时，推荐使用<code><strong>escape</strong></code>方法代替<code>get</code>方法。</li>
			<li><code><strong>has(attr), unset(attr,[options]), clear([options])</strong></code>：分别检测是否有某属性，删除某属性和删除所有除id外的属性，<code>options</code>中可以指定<code>silent</code>，不触发<code>change</code>事件。另外，属性可以直接通过<code>attributes</code>访问。</li>
			<li><code><strong>idAttribute</strong></code>属性：指定作为主键的字段。可通过<strong>id</strong>访问。</li>
			<li><code><strong>toJSON([options])</strong></code>：将该实例json化，常和<code>View.template</code>配合使用。</li>
			<li><code><strong>fetch([options])</strong></code>：通过jquery发起XHR请求，获取model数据。在<code>options</code>中可以分别指定<code>success</code>和<code>error</code>的回调，回调分别接受<code>model, response, options</code>。使用方法如下：</li>
			<pre><code>var user = new User ({id: 1});
user.fetch({
    success: function (user){
        console.log(user.toJSON());
    }
})</code></pre>
			<li><code><strong>save([attr], [options])</strong></code>：通知服务器新建或更新Model，如果Model实例不含id属性，将使用<code>POST</code>新建，如果Model带有id属性，<code>save</code>方法将使用<code>PUT</code>更新实例。<code>options</code>和<code>fetch</code>用法类似。</li>
			<li><code><strong>validate(attr, [options])</strong></code>检测属性是否合法会，触发<strong>invalid</strong>事件。<code>isValid()</code>方法会执行validate返回是否合法的结果。</li>
		</ul>
		<p>另外<code>destroy</code>方法清除一个实例，<code>clone</code>拷贝一个实例，<code>hasChanged</code>检测属性是否已更新。Underscore关于对象的如<code>keys</code>，<code>pick</code>等方法也可使用。</p>
		<h4 id="backbone_collection">Collection</h4>
		<p>Colletcion是<strong>同一类</strong>Model的集合，如Model是学生，Collection就是班级；Model是歌，Collection就是专辑。如下面代码所示：</p>
		<pre><code>var Song = Backbone.Model.extend({});
var Album = Backbone.Collection.extend({
    model: Song
});		</code></pre>
		<ul>
			<li><code><strong>add(models, [options]), remove(models, [options])</strong></code>：将new出来的实例直接放入Collection的实例，或通过<code>id</code>字段值移除Model实例。</li>
			<li><code><strong>get(id), set(model, [options])</strong></code>获取collection中的某个model，或重设整个collection。在重设时通过融合的方式完成。</li>
			<li><code><strong>model([attrs], [options])</strong></code>指定collections所包括的Model。<strong>modelId</strong>属性指定Collection标记Model的方法，函数接受<code>attrs</code>。多用在不同<code>idAttribute</code>的情况。</li>
			<li><code><strong>comparator</strong></code>指定排序Model的标准字段。<code>sort([options])</code>方法会跟这个属性来排列Models。</li>
			<li><code><strong>pluck(attr), where(attr)</strong></code>取出所有Models的某一列，返回满足<code>where</code>条件的所有Model。<code>findWhere(attr)</code>返回第一个满足条件的结果。</li>
			<li><code><strong>fetch([options])</strong></code>类似Model中的用法，获取整个Collection。</li>
			<li><code><strong>create(attr, [options])</strong></code>通过Collection创建一个Model。</li>
		</ul>
		<p>此外，underscore和原生用于数组的方法如<code>push, pop, shift, unshift, forEach, every</code>等等函数也可以使用。</p>
		<h3 id="backbone_demo">Demos</h3>
		<p>由于Backbone.js并非使用模块来构建Web应用，且自由度很高，结合上面介绍的API，可以方便地构建很多单页面应用。官网也提供了许多demos，便于初学者上手掌握。</p>
		<p>可以先从<a href="http://arturadib.com/hello-backbonejs/" target="_blank">Hello-backbonejs</a>上手，感受backbone的基本使用。之后学习<a href="http://backbonejs.org/examples/todos/index.html" target="_blank">Todos</a>（系列的<a href="https://github.com/tastejs/todomvc" target="_blank">TodoMVC</a>也是很不错的学习<a href="https://angularjs.org/" target="_blank">Angular</a>，<a href="http://emberjs.com/" target="_blank">Ember.js</a>等的demo），就可以开始自己捣鼓点小东西了。个人认为对比下面介绍的框架，已经好上手很多了。</p>
		<h3 id="backbone_more">更多</h3>
		<p><strong>Backbone.locaStorage</strong>也是很常用的backbone的插件，用于将Model和Collection的数据插入到本地存储中，根据介绍，使用很简单：</p>
		<pre><code>window.SomeCollection = Backbone.Collection.extend({

    localStorage: new Backbone.LocalStorage("SomeCollection"), // Unique name within your app.

    // ... everything else is normal.

});		</code></pre>
		<p>另外很喜欢官网的style，和underscore以及zepto的一样，简约而便于检索。本文的样式也参考自此。</p>
		<hr>
		<h1 id="express">Express JS</h1>
		<h3 id="express_brief">概述</h3>
		<p>Express是基于Node.js的流行Web开放框架，没有对NodeJS进行二次抽象。可以快速搭建一个完整功能的网站。后面我们将用一个例子简单展示express的特点。</p>
		<p>新建一个项目目录，进入该目录新建<span class="i">package.json</span>文件，填写项目的一些配置信息。包括<span class="i">name, description, version, dependencies</span>等等。其中<code>dependencies</code>，/中可指定express的版本范围，如<code>4.x</code>. 执行<code>npm install</code>指令安装环境。</p>
		<p>新建<span class="i">index.js</span>，写入如下样例：</p>
		<pre><code>var express = require('express');
var app = express();

app.get('/',function(req, res){
	res.send('Hello, world!');
});

app.listen(8888);
</code></pre>
		<p>即可在浏览器看到页面效果。其中<code>app.get</code>对路由的处理还可以拓展到其他路径，封装成路由模块。</p>
		<h3 id="express_basic">基本原理</h3>
		<p>Express框架建立在nodeJS内置的<code>http</code>模块上。上面的<code>app</code>实际上就是由<code>http</code>的<code>createServer</code>方法生成的。而express只是做了一层包装。</p>
		<p>中间件是处理http请求的函数。多个中间件按照流水线的形式处理请求，单个中间件处理完成后，通过调用<code>next</code>方法交给下个中间件处理。<code>next</code>方法所带参数表示抛出错误。可以通过<code>use</code>方法注册中间件。样例如下：</p>
		<pre><code>var express = require('express')
var http = require('http');
var app = express();

app.use('/home', function(req, res, next){
	res.writeHead(200, {"Content-Type": "text/plain"});
	res.end("Welcome!");
});

app.use('/about', function(req, res, next){
	res.writeHead(200, {"Content-Type": "text/plain"});
	res.end("About.");
});

app.use(function(req, res){
	res.writeHead(404, {"Content-Type": "text/plain"});
	res.end("404 error!\n");
});

app.listen(8888);
</code></pre>
		<h3 id="express_methods">常用方法</h3>
		<p>除了上文中用到的<code>use</code>,/，对于一些特殊的<code>use</code>使用，还有别名的方法。如<code>all</code>方法表示所有满足第一个条件的请求都必须通过该中间件，<code>*</code>则表示所有请求都必须通过。<code>get</code>方法和<code>post, put, delete</code>等方法也类似，它们没有<code>next</code>方法，只要一个中间件被调用，后面的中间件就不再调用。注意，<code>app.get(name)</code>意为获取全局变量值。</p>
		<p>这些方法的第一个参数都是请求的路径。Express允许模式匹配，即可以在路径中匹配并捕获模式字段，字段后加上<code>?</code>表示模式可选。范例如下：</p>
		<pre><code>app.get('/hello/:who?', function(req, res){
	if(req.params.who) res.end("Hello " + req.parmas.who + "!"); 
	else res.send("Hello guest.");
});		</code></pre>
		<p>url匹配还支持正则匹配。范例略。同时，<code>set</code>方法可以为系统变量指定新值。</p>
		<p><code>response</code>对象也有一些常用方法。<code>redirect</code>方法用于网页重定向，<code>sendFile</code>用于发送文件，<code>render</code>用于渲染网页模板，向模板中传递数据。<code>Request</code>也有着许多常用对象，<code>ip</code>用于获得请求的ip地址，<code>files</code>用于获取上传的文件。</p>
		<p>搭建https服务器的方法略。更多API见<a href="http://expressjs.com/zh-cn/api.html" target="_blank">官方文档</a>。</p>
		<h3 id="express_template">网页模板</h3>
		<p>通常，对于大部分请求，返回的结果都为较复杂的网页，此时使用<code>send</code>方法就不再方便。展示静态网页模板时，使用<code>response</code>对象的<code>sendFile</code>方法可以解决此问题。渲染动态网页可以使用<code>render</code>方法，也可以利用一些模板引擎完成。</p>
		<p>在模板中通过{{}}(因模板而异)加载动态数据。模板后缀，视图模板存放的路径，渲染引擎入口等可以在入口js处统一声明。</p>
		<p>静态文件通过<code>express.static</code>方法指定路径，在浏览器发出非HTML文件请求时，去指定的目录寻找。</p>
		<h3 id="express_router">路由</h3>
		<p>在4.0后，express将路由功能封装成了一个单独的组件<code>Express.Router</code>。同样拥有<code>use, get, param, route</code>方法。用法和<code>app</code>极为相似。方便通过<code>app.use(xxx, router)</code>的形式挂载不同的根目录。<code>route</code>方法以路径作为输入参数，之后跟<code>post</code>或其他方法绑定到该路径上。注意，<code>router</code>中的<code>use</code>中间件须放在HTTP动词方法之前，否则不会执行。</p>
		<p><code>app</code>同样有<code>route</code>属性，<code>app.route</code>是<code>express.router()</code>的等价形式。</p>
		<h3 id="express_modules">常用模块</h3>
		<p>使用Express快速开发网络应用的时候，会用到许多现成的模块辅助开发。它们能在express的组织下方便地完成各种功能。</p>
		<h4 id="body-parser"></h4>
		<p>body-parser是express的处理请求体的中间件。它接受stream格式的<code>request</code>体，并以用户需要的格式友好地返回。以下是一些body-parser提供的API。</p>
		<p><code>bodyParser.json(options)</code>解析json格式的请求体，接受Unicode编码的请求提，支持gzip和deflate格式。<code>req.body</code>会被解析后的<code>body</code>替代。</p>
		<p><code>bodyParser.raw(options)</code>将请求题以Buffer类型解析。返回的解析器将请求体解析为<code>buffe</code>r格式。<code>bodyParser.text(options)</code>类似，解析为<code>string</code>格式。</p>
		<p><code>bodyParser.urlencoded(options)</code>只解析urlencoded请求体，接受UTF-8编码。生成的新的请求体是键值对的格式。</p>
		<p>这些API可以按顺序多次列写，依次尝试解析直到body体被成功解析为止。更多信息见<a href="https://github.com/expressjs/body-parser" target="_blank">官方解释</a>。</p>
		<h4 id="cookie-parser"></h4>
		<p>cookie是用来解决HTTP协议无状态的问题的。Cookie通过服务器发往客户端浏览器，在浏览器每次发起请求时附带，有<code>path, expire, maxAge, secure, httpOnly</code>等参数。</p>
		<h4 id="express-session">Express-session</h4>
		<p>为了保证cookie的安全性，session因此诞生。Session通过<code>sid</code>标识，通常储存在cookie中，服务器每次接收到请求，将session id对应的<code>data</code>关联，进行相应操作。Session可以存放在1) 内存2) cookie 3) redis, memcached缓存 4)数据库中。</p>
		<p>Express中操作session用来这个模块主要通过<code>session(options)</code>初始化并作为处理回话(session)的中间件。Options中的主要参数有<code>name</code>，用来指定cookie中保存session的字段名，<code>store</code>指定session的存储方式，<code>secret</code>指定hash加密cookie的方式，<code>cookie</code>指定存放sid的cookie的相关选项，<code>genid</code>指定生成新sid时用到的函数，<code>rolling</code>指定每个请求是否重新设置一个cookie，<code>resave</code>指定session未更改时，是否保存session值。</p>
		<h4 id="connect-mongo">Connect-mongo</h4>
		<p>这个组件是用来方便地将用户session存储在mongodb中的。通过<code>require(xxx)(session)</code>引入后，如<code>session(new MongoStore(opts))</code>这样使用。<code>opts</code>里可以通过Mangoose或其他驱动器或url指定MondoDB服务器。详情见<a href="https://github.com/kcbanner/connect-mongo" target="_blank">github api解释</a></p>
		<h4 id="ejs">Ejs</h4>
		<p>实际上ejs严格来说是一个模板引擎，负责将模板文件替换成html文件再发回到客户端。ejs有三种标签。<code><% code %> <%= code %> <%- code %></code>分别对应JS代码，可以通过使用for循环显示列表内容。ejs还可以使用<code><%- include a %></code>引入其他模板从而实现页面布局的效果。</p>
		<p>个人认为jade模板引擎Markdown式的写法更简洁。</p>
		<h4 id="express-mongo">Mongodb</h4>
		<p>Node开发经常使用的MongoDB做数据库。MongoDB是Mongo在node.js中的驱动。在2.x版本的mongodb中，通过<code>MongoClient.connect(url, opts, callback)</code>创建和数据库的连接，其中<code>callback</code>可以读取<code>err</code>和<code>db</code>对象，从而对数据库操作。通过<code>db.collection(name)</code>获取指定集合，使用得到的collection的<code>insert, insertMany, find(quert), sort, limit, update, delete</code>完成增删改查。使用<code>toArray</code>可以把查询的数据转成数组格式。</p>
		<p>更多Mongodb使用参见<a href="http://mongodb.github.io/node-mongodb-native/2.1/api/" target="_blank">node-mongodb API文档</a>.</p>
		<h4 id="express-flash">Connect-flash</h4>
		<p>flash使用session的特殊区域。信息在展示前被写入<code>flash</code>，展示给用户后即被擦除。Flash常用于跳转页面，保证信息能够正确传递到下一个被渲染的界面。</p>
		<p>使用时，在初始化session后，创建<code>flash</code>中间件即可。在页面即将跳转时，写入信息到<code>req.flash</code>中，在跳转的页面里，即可通过<code>req.flash</code>获取到。</p>
		<h3 id="express_more">更多</h3>
		<p>在实际开发中，通常综合了许多的模块。惯例下，在<span class="i">bin</span>目录下放置可执行文件，<span class="i">models</span>目录下放置模型定义和与数据库沟通的文件充当Model部分，<span class="i">node_modules</span>放置依赖包，<span class="i">public</span>放置静态文件包括css文件等，<span class="i">routes</span>放置路由文件充当Controller部分，<span class="i">views</span>放置视图模板作为View部分。父目录下还有<span class="i">app.js</span>作为入口文件，<span class="i">package.json</span>作为项目配置文件，<span class="i">settings.js</span>储存常用设置参数如数据库端口等。</p>
		<p>Express有着丰富的模块可供选择，模块文档可以在npm和github上找到，这些模块可以帮助你轻松完成复杂功能，让开发者专注于工程结构和代码逻辑。以上的笔记来自<a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank">阮一峰博客</a>和<a href="https://github.com/nswbmw/N-blog/wiki/%E7%AC%AC1%E7%AB%A0--%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%9A%E5%AE%A2" target="_blank">开发简单博客的实例</a>。</p>
		<hr>
	</div>
</body>
</html>