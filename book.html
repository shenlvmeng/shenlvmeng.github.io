<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="utf-8">
	<meta name="keywords" content="javascript,js,front-end,book,tutorial,shenlvmeng">
	<meta name="description" content="前端技术学习笔记">
	<meta name="author" content="shenlvmeng">
	<title>Front-end tools book(1)</title>
	<link rel="stylesheet" type="text/css" href="./css/book.css">
	<link rel="stylesheet" href="./css/atom-one-dark.css">
	<script src="./highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
	<aside>
		<a href="#" class="title">前端技术学习笔记</a>
		<ul>
			<li><a href="#introduction">前言</a></li>
			<li><a href="#tail">尾注</a></li>
		</ul>
		<hr>
		<a href="#nodejs">nodeJS</a>
		<ul>
			<li><a href="#node_what_why">What and Why</a></li>
			<li><a href="#node_install">安装</a></li>
			<li><a href="#node_modules">模块</a></li>
			<li><a href="#node_require">代码组织</a></li>
			<li><a href="#node_file">文件操作</a></li>
			<li><a href="#node_network">网络操作</a></li>
			<li><a href="#node_thread">进程管理</a></li>
			<li><a href="#node_features">特点</a></li>
			<li><a href="#node_examples">使用示例</a></li>
			<li><a href="#node_more">更多</a></li>
		</ul>
		<a href="#npm">npm</a>
		<ul>
			<li><a href="#npm_introduction">简介</a></li>
			<li><a href="#npm_install">安装</a></li>
			<li><a href="#npm_commands">常用命令</a></li>
			<li><a href="#npm_download">下载第三方包</a></li>
			<li><a href="#npm_install_cmd">安装命令行程序</a></li>
			<li><a href="#npm_release">发布自己的包</a></li>
			<li><a href="#npm_version">版本号控制</a></li>
			<li><a href="#npm_sum_up">小结</a></li>
			<li><a href="#npm_more">更多</a></li>
		</ul>
		<a href="#bower">Bower</a>
		<ul>
			<li><a href="#bower_introduction">简介</a></li>
			<li><a href="#bower_usage">使用</a></li>
			<li><a href="#bower_question">Bower or npm?</a></li>
		</ul>
		<a href="#browserify">Browserify</a>
		<ul>
			<li><a href="#brow_intro_usage">简介与使用</a></li>
			<li><a href="#brow_manage_generate">管理与生成</a></li>
		</ul>
		<a href="#webpack">Webpack</a>
		<ul>
			<li><a href="#webpack_why">Why</a></li>
			<li><a href="#webpack_usage">安装使用</a></li>
			<li><a href="#webpack_config">配置文件</a></li>
			<li><a href="#webpack_more">更多</a></li>
		</ul>
		<a href="#grunt">Grunt</a>
		<ul>
			<li><a href="#grunt_tutorial">入门</a></li>
			<li><a href="#gruntfile">Gruntfile</a></li>
			<li><a href="#grunt_config">任务配置</a></li>
			<li><a href="#grunt_example">配置实例</a></li>
			<li><a href="#grunt_task">任务与插件</a></li>
			<li><a href="#grunt_more">更多</a></li>
		</ul>
		<a href="#gulp">Gulp</a>
		<ul>
			<li><a href="#gulp_tutorial">入门</a></li>
			<li><a href="#gulp_api">常用API</a></li>
			<li><a href="#gulp_cli">CLI使用</a></li>
			<li><a href="#gulp_more">更多</a></li>
		</ul>
		<a href="#commonjs">CommonJS</a>
		<ul>
			<li><a href="#common_brief">简介</a></li>
			<li><a href="#common_feature">特点</a></li>
			<li><a href="#common_module">Module</a></li>
			<li><a href="#require">Require</a></li>
			<li><a href="#amd">AMD and more?</li>
			<li><a href="#common_more">更多</a></li>
		</ul>
		<a href="#backbone">Backbone.js</a>
		<ul>
			<li><a href="#backbone_brief">概述</a></li>
			<li><a href="#backbone_structure">项目组成</a></li>
			<li>
				<a href="#backbone_api">API介绍(v1.3.3)</a>
				<ul>
					<li><a href="#backbone_view">View</a></li>
					<li><a href="#backbone_event">Events</a></li>
					<li><a href="#backbone_router">Router</a></li>
					<li><a href="#backbone_model">Model</a></li>
					<li><a href="#backbone_collection">Collection</a></li>
				</ul>
			</li>
			<li><a href="#backbone_demo">Demos</a></li>
			<li><a href="#backbone_more">更多</a></li>
		</ul>
		<a href="#express">Express JS</a>
		<ul>
			<li><a href="#express_brief">概述</a></li>
			<li><a href="#express_basic">基本原理</a></li>
			<li><a href="#express_methods">常用方法</a></li>
			<li><a href="#express_template">网页模板</a></li>
			<li><a href="#express_router">路由</a></li>
			<li><a href="#express_modules">常用模块</a></li>
			<ul>
				<li><a href="#body-parser">body-parser</a></li>
				<li><a href="#cookie-parser">cookie-parser</a></li>
				<li><a href="#express-session">Express-session</a></li>
				<li><a href="#connect-mongo">Connect-mongo</a></li>
				<li><a href="#ejs">Ejs</a></li>
				<li><a href="#express-mongo">Mongodb</a></li>
				<li><a href="#express-flash">Connect-flash</a></li>
			</ul>
			<a href="#express_more">更多</a>
		</ul>
		<a href="#react">React JS</a>
		<ul>
			<li><a href="#react_what_why">What and Why</a></li>
			<li><a href="#thinking_in_react_way">Thinking in React Way</a></li>
			<li><a href="#react_data">数据呈现</a></li>
			<ul>
				<li><a href="#jsx">JSX</a></li>
				<li><a href="#jsx_html">JSX属性扩散与HTML</a></li>
			</ul>
			<li><a href="#react_interact">添加交互</a></li>
			<li><a href="#react_component">组合组件</a></li>
			<li><a href="#react_form">表单组件</a></li>
			<li><a href="#react_component_life">组件说明与生命周期</a></li>
			<li><a href="#refs">Refs</a></li>
			<li><a href="#react_api">API</a></li>
			<ul>
				<li><a href="#react_reactapi">React</a></li>
				<li><a href="#reactdomapi">ReactDOM</a></li>
				<li><a href="#reactdomserverapi">ReactDOMServer</a></li>
				<li><a href="#reactcomponentapi">Component</a></li>
			</ul>
			<li><a href="#react_others">标签/属性/事件</a></li>
			<li><a href="#flux">Flux/Redux</a></li>
			<li><a href="#react_more">更多</a></li>
		</ul>
		<a href="#angular">Angular JS</a>
		<ul>
			<li><a href="#angular_brief">简介与安装</a></li>
			<li><a href="#angular_usage">使用</a></li>
			<ul>
				<li><a href="#angular_app">应用/控制器</a></li>
				<li><a href="#angular_expression">表达式</a></li>
				<li><a href="#angular_model">数据模型</a></li>
				<li><a href="#angular_filter">过滤器</a></li>
				<li><a href="#angular_service">服务</a></li>
				<li><a href="#angular_sql">Sql</a></li>
				<li><a href="#angular_dom">DOM/事件</a></li>
				<li><a href="#angular_form">表单验证</a></li>
				<li><a href="#angular_router">路由</a></li>
				<li><a href="#angular_api">通用API函数</a></li>
			</ul>
			<li><a href="#dependency_injection">依赖注入</a></li>
			<li><a href="#angular_extend_command">基础拓展指令</a></li>
			<li><a href="#angular_services">常用服务</a></li>
			<li><a href="#angular2">Angular 2</a></li>
			<ul>
				<li><a href="#componency">组件化</a></li>
				<li><a href="#angular2_extend_commonds">拓展命令</a></li>
			</ul>
			<li><a href="#angular_more">更多</a></li>
		</ul>
		<a href="#vuejs">Vue.js</a>
		<ul>
			<li id=""><a href="#vuejs_start">第一印象</a></li>
			<li><a href="#vuejs_base">基础</a></li>
			<li><a href="#vuejs_usage">使用</a></li>
			<ul>
				<li>
					<a href="#vuejs_template">模板</a>
					<ul>
						<li><a href="#vuejs_text">文本</a></li>
						<li><a href="#vuejs_dire">指令</a></li>
						<li><a href="#vuejs_abbr">缩写</a></li>
					</ul>
				</li>
				<li>
					<a href="#vuejs_fields">复杂属性</a>
					<ul>
						<li><a href="#vuejs_computed">计算属性</a></li>
						<li><a href="#vuejs_watch">Watcher</a></li>
					</ul>
				</li>
				<li>
					<a href="#vuejs_style">样式</a>
					<ul>
						<li><a href="#vuejs_class">Class</a></li>
						<li><a href="#vuejs_inlinestyle">内联样式</a></li>
						<li><a href="#vuejs_transition">Transition</a></li>
					</ul>
				</li>
				<li>
					<a href="#vuejs_control">流程控制</a>
					<ul>
						<li><a href="#vuejs_if">v-if/v-else</a></li>
						<li><a href="#vuejs_show">v-show</a></li>
						<li><a href="#vuejs_for">v-for</a></li>
					</ul>
				</li>
				<li>
					<a href="#vuejs_response">响应</a>
					<ul>
						<li><a href="#vuejs_event">监听事件</a></li>
						<li><a href="#vuejs_form">表单控件</a></li>
					</ul>
				</li>
				<li>
					<a href="#vuejs_component">组件</a>
					<ul>
						<li><a href="#vuejs_comp_usage">使用</a></li>
						<li><a href="#vuejs_prop">Prop</a></li>
						<li><a href="#vuejs_custom">自定义事件</a></li>
						<li><a href="#vuejs_dispatch">内容分发</a></li>
						<li><a href="#vuejs_dynamic">动态组件</a></li>
						<li><a href="#vuejs_hint">注意事项</a></li>
					</ul>
				</li>
			</ul>
			<li><a href="#vuejs_more">更多</a></li>
			<li>
				<a href="#vuejs_reference">附录</a>
				<ul>
					<li><a href="#vuejs_reserve">内置组件</a></li>
					<li><a href="#vuejs_options">实例配置选项</a></li>
					<li><a href="#vuejs_obj_fields">实例常用属性</a></li>
					<li><a href="#vuejs_hooks">生命周期钩子</a></li>
				</ul>
			</li>
		</ul>
		<a href="#mangodb">Mangodb</a>
		<ul>
			<li><a href="#mango_brief">简介</a></li>
			<li><a href="#mango_unit">基本单位</a></li>
			<li><a href="#mango_database">连接/创建/删除数据库</a></li>
			<li><a href="#mango_crud">CRUD操作</a></li>
			<li><a href="#mango_index">索引与聚合</a></li>
			<li><a href="#mango_others">其他</a></li>
		</ul>
		<a href="#socketio">Socket.io</a>
			<ul>
				<li><a href="#socketio_brief">简介</a></li>
				<li><a href="#WebSocket">WebSocket</a></li>
				<li><a href="#socketio_install">安装与使用</a></li>
				<li><a href="#socketio_api">部分API
				</a></li>
			</ul>
		<a href="#jade">Jade</a>
		<ul>
			<li><a href="#jade_brief">简介</a></li>
			<li><a href="#jade_lang">语法</a></li>
		</ul>
		<a href="#d3">D3.js</a>
		<ul>
			<li><a href="#d3_brief">简介</a></li>
			<li><a href="#svg">SVG介绍</a></li>
			<ul>
				<li><a href="#svg_axis">坐标</a></li>
				<li><a href="#svg_shape_path">形状与路径</a></li>
				<li><a href="#svg_fill_stroke">填充与边框</a></li>
				<li><a href="#svg_pattern_text">模式与文字</a></li>
				<li><a href="#svg_transform_distord">渐变与变形</a></li>
				<li><a href="#svg_cut">剪切与遮罩</a></li>
				<li><a href="#svg_filter">滤镜</a></li>
				<li><a href="#svg_others">其他</a></li>
			</ul>
			<li><a href="#d3_dom">DOM操作API</a></li>
			<li><a href="#d3_scale">比例尺API</a></li>
			<li><a href="#d3_axis">坐标轴API</a></li>
			<li><a href="#d3_transition">渐变API</a></li>
			<li><a href="#d3_layout">布局API & 形状API</a></li>
			<ul>
				<li><a href="#d3_pie">饼状图</a></li>
				<li><a href="#d3_force">力导向图</a></li>
				<li><a href="#d3_chord">弦图</a></li>
				<li><a href="#d3_cluster">集群图/树状图/矩阵树图</a></li>
				<li><a href="#d3_bundle">捆图</a></li>
				<li><a href="#d3_pack">打包图</a></li>
				<li><a href="#d3_partition">分区图</a></li>
				<li><a href="#d3_geo">地理图</a></li>
				<li><a href="#d3_histogram">直方图</a></li>
				<li><a href="#d3_stack">堆栈图</a></li>
			</ul>
			<li><a href="#d3_xhr">请求API</a></li>
			<li><a href="#d3_random">随机数API</a></li>
			<li><a href="#d3_behavior">行为API</a></li>
			<li><a href="#d3_color">颜色API</a></li>
			<li><a href="#d3_more">更多</a></li>
		</ul>
		<a href="#sass">Sass</a>
		<ul>
			<li><a href="#sass_rule">约定</a></li>
			<li><a href="#compass">Compass</a></li>
		</ul>
		<a href="#es2015">ES6新特性</a>
		<a href="#groccery">杂项</a>
		<ul>
			<li><a href="#markdown">Markdown</a></li>
			<li><a href="#jsonp">JSONP & CORS</a></li>
			<li><a href="#dependency_infection_intro">依赖注入</a></li>
			<li><a href="#candy">语法糖</a></li>
			<li><a href="#function_language">函数式编程</a></li>
			<li><a href="#iife">IIFE</a></li>
			<li><a href="#stream">Nodejs中的Stream</a></li>
			<li><a href="#crypto">Crypto</a></li>
		</ul>
		<p>&copy; shenlvmeng</p>
	</aside>
	<div class="container">
		<h3 id="introduction">前言</h3>
		<p>此文源于6月初的一个知乎问题“<a href="http://www.zhihu.com/question/29875948" target="_blank">为什么市场上优秀的前端这么少，国外也是这样吗?</a>”，简单阅览了答案后才发现，有那么多的web技术自己还闻所未闻。于是开始从javascript(js)开始，广度优先地学习起一些新技术（当然有些列举的已经不算新了）。在学习的过程中，也发现了作为一名前端工程师的不易：</p>
		<ul>
			<li>科技树太广，需要广泛的知识面</li>
			<li>随着js的发展，前端技术已渗透到各个方面，做前端≈做全栈</li>
			<li>新技术出现太快，需要保持open mind</li>
		</ul>
		<p>这里整理了对一些技术的学习笔记，几乎都是与js相关的技术，按照分类列举在下面（有些未做学习）:</p>
		<ul>
			<li><strong>框架</strong>：AngularJS, EmbedJS, ReactJS, ExpressJS, Backbone.JS</li>
			<li><strong>环境</strong>：NodeJS</li>
			<li><strong>包管理</strong>：Bower, npm</li>
			<li><strong>包构建</strong>：Browserify, Webpack</li>
			<li><strong>任务自动化</strong>：Grunt, Gulp</li>
			<li><strong>模块化规范</strong>：RequireJS, CommonJS, AMD, CMD</li>
			<li><strong>DOM操作</strong>：jQuery, Zepto</li>
			<li><strong>数据库</strong>：MongoDB</li>
			<li><strong>可视化</strong>：D3</li>
			<li><strong>测试工具</strong>：Protractor, Selenium, PhantomJS, mocha</li>
			<li><strong>其他</strong>：Jade, Markdown, Socket.io等</li>
		</ul>
		<p>关于本文，还有一些想说的。首先，前端技术发展很快，文中提到的用法等内容是有一定时效性的，请谨慎；其次，写本文的时候是奔着信息充分，便于日后检索去的，所以当作工具书更为适合；最后，水平有限，纰漏还望指正。</p>
		<hr>
		<h1 id="nodejs">NodeJS</h2>
		<h3 id="node_what_why">What and Why</h3>
		<p>NodeJS是以下介绍的许多技术的出发点和基础。它让JS从前端技术走到后台开发。对于独立运行的JS来说，NodeJS就是一个解析器，就像PHP。但是和PHP不同的是，NodeJS在实现应用的同时，还实现了整个HTTP服务器，不像PHP需要Apache等的帮助。</p>
		<p>NodeJS具有很好的事件机制和异步IO模型。类似于浏览器，NodeJS提供了内置对象给用户操作。</p>
		<h3 id="node_install">安装</h3>
		<p>Windows下和Mac OS X系统下，分别去<a href="http://nodejs.org" target="_blank">nodejs.org</a>下载.msi和.pkg后缀的安装文件。Linux下需要下载.tar.gz包编译安装。</p>
		<p>Windows环境下安装后可以在命令行中使用<code>node –v</code>, <code>npm –v</code>查看是否成功。另外终端下直接输入node命令可进入命令交互模式.</p>
		<h3 id="node_modules">模块</h3>
		<p>运行简单的web应用程序时，可以直接通过命令或是<code>node example.js</code>的形式启动。在程序稍大时，通常会将代码模块化。文件即模块，通过<code>require</code>、<code>exports</code>、<code>module</code>命令导入、导出、声明模块。范例：</p>
		<pre><code>var foo = require("./foo");
exports.hello = function(){
    console.log("Hello World!");
}
module.exports = function(){
    console.log("Hello World!");
}		</code></pre>
		<p><code>require</code>函数用于在当前模块中加载和使用别的模块，返回一个模块导出对象。模块名可以以相对或是绝对路径。模块后缀名可省略。<code>exports</code>对象用于导出模块共有方法和属性，导出的内容由别的模块使用<code>require</code>获取。<code>module</code>对象可以访问当前模块的一些相关信息，包括导出对象。</p>
		<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。通过命令行传递给NodeJS启动的模块称为主模块。</p>
		<p>最后，NodeJS支持使用C/C++编写二进制模块，使用方法和JS模块相同，它可以使用操作系统提供的所有功能，潜能很大，但是难以跨平台。这里从略。</p>
		<h3 id="node_require">代码组织</h3>
		<p><code>require</code>函数支持绝对、相对路径，可以通过<span class="i">node_modules</span>目录，<span class="i">NODE_PATH</span>定制。</p>
		<p>当模块较复杂时，可以使用包结构将多个子模块。将这些子模块放在同一目录下，使用<code>index.js</code>作为入口模块。这样路径只需写到文件夹即可。范例：</p>
		<pre><code>var head = require('./head');
var body = require('./body');

exports.create = function (name) {
    return {
        name: name,
        head: head.create(),
        body: body.create()
    };
};		</code></pre>
		<p>另外，使用<code>package.json</code>可以自定义入口模块的文件名和存放位置。使用name,main即可</p>
		<p>标准的工程目录应该包括<span class="i">bin/</span>, <span class="i">doc/</span>, <span class="i">lib/</span>, <span class="i">node_modules/</span>, <span class="i">tests/</span>, <span class="i">package.json</span>, <span class="i">README.md</span>等部分，分别存放命令相关代码、文档、API相关代码、第三方包、测试用例、元数据文件、说明文件。nodeJS有许多内置的模块可供使用，下面分几个部分分别介绍之。</p>
		<h3 id="node_file">文件操作</h3>
		<p>NodeJS作为后台解析环境，可以完成很多文件操作。使用NodeJS内置的<code>fs</code>模块的API可以完成如拷贝等功能。拷贝小文件时，使用<code>writeFileSync</code>, <code>readFileSync</code>即可完成，大文件拷贝时，使用<code>createReadStream</code>, <code>pipe</code>, <code>createWriteStream</code>可以完成。</p>
		<p>同时NodeJS还提供了<code>Buffer</code>，<code>Stream</code>，<code>Path</code>用于完成更完善的文件操作功能。</p>
		<p><a href="https://nodejs.org/api/buffer.html" target="_blank"><code>Buffer</code></a>对象是与<code>String</code>对等的二进制数据类型，可以用<code>to_string</code>和<code>string</code>相互转换。不同的是，<code>buffer</code>对象是可写的，这点和C很像。因此，<code>buffer</code>更像是指针操作的C语言数组，如使用<code>slice</code>命令更像是将指针赋予了新值，对新值做的修改对原值有直接影响。因此，拷贝<code>buffer</code>时，需要先创建一个新的<code>buffer</code>才能复制新数据。</p>
		<p><a href="https://nodejs.org/api/stream.html" target="_blank"><code>Stream</code></a>对象在内存无法一次装下大文件的数据时，或需要一边读取一边处理时提供对数据流的操作，例如可用<code>createReadStream</code>创建一个只读数据流<code>rs</code>，<code>rs</code>有<span class="i">on, pause, resume, end</span>等功能。<code>Stream</code>对象都是事件驱动的，上文提到的rs即可监听<span class="i">data, end, drain</span>等事件。<code>pipe</code>方法提供了防爆仓控制，用于大文件拷贝。</p>
		<p><a href="https://nodejs.org/api/fs.html" target="_blank"><code>fs</code></a>模块提供了许多有用的API，包括文件属性读写，文件内容读写，底层文件操作。这些API大多为异步，不过都有同步版本，并在函数名后添加Sync。</p>
		<p><a href="http://nodejs.org/api/path.html" target="_blank"><code>Path</code></a>模块用于文件路径的操作。<code>Normalize</code>方法将传入的路径转换为标准路径，<code>join</code>方法将传入的多个路径拼接成标准路径。</p>
		<p>下面是一个遍历目录的同步例子，用到了以上介绍的内容：</p>
		<pre><code>function travel(dir, callback) {
    fs.readdirSync(dir).forEach(function (file) {
        var pathname = path.join(dir, file);

        if (fs.statSync(pathname).isDirectory()) {
            travel(pathname, callback);
        } else {
            callback(pathname);
        }
    });
}		</code></pre>
		<p>除了以上介绍的文件操作外，一些其他需求也经常出现，如去文件BOM头，GBK转换UTF-8编码，单字节编码。</p>
		<p>NodeJS提供的这些文件操作功能对于变现前端工具是很有帮助的。</p>
		<h3 id="node_network">网络操作</h3>
		<p>由于NodeJS的用途是实现高性能的Web服务器，给独立运行的JS提供解释环境，它所提供的网络操作可以完成相对底层的网络操作，如Socket和HTTP协议相关。NodeJS提供了<code>http, https, url, querystring, zlib, net</code>等库帮助开发者实现网络编程。</p>
		<p><a href="https://nodejs.org/api/http.html" target="_blank"><code>http</code></a>模块提供了两种使用方式: 作为服务端使用和作为客户端使用。如测试第1例中所写，<code>createServer</code>方法创建一个服务器（这也是最常用的一种用法），然后抵用listen方法监听端口。客户端每请求一次，创建时输入的回调函数就调用一次。函数中的<code>request</code>和<code>response</code>实际上也是数据流的格式，所以可以用文件操作函数来读取，如<code>request.on</code>, <code>request.write</code>等方法.</p>
		<p>在作为客户端使用时，有<code>get</code>, <code>post</code>等方法，同样地，可以使用<code>response</code>对象访问响应头数据，还能把<code>response</code>对象当作一个只读数据流访问响应体数据。用法范例如下：</p>
		<pre><code>http.get('http://www.example.com/', function (response) {
    var body = [];

    console.log(response.statusCode);
    console.log(response.headers);

    response.on('data', function (chunk) {
        body.push(chunk);
    });

    response.on('end', function () {
        body = Buffer.concat(body);
        console.log(body.toString());
    });
});		</code></pre>
		<p><a href="https://nodejs.org/api/https.html" target="_blank"><code>https</code></a>模块和<code>http</code>模块很类似，区别在于<code>https</code>模块需要额外的SSL证书处理，在<code>createServer</code>时，将公钥和私钥放在<code>option</code>里作为输入参数。同时<code>https</code>的<code>addContext</code>方法还可以使用多个域名提供服务。在客户端模式下，<code>https</code>模块默认拒绝连接未从颁发机构购买SSL证书的服务器。在<code>options</code>中添加<code>rejectUnauthorized: false</code>即可在开发条件下允许自制证书。</p>
		<p><a href="https://nodejs.org/api/url.html" target="_blank"><code>url</code></a>模块允许生成、解析、拼接url。url分为<span class="i">protocol, auth, hostname, port, pathname, search(query) hash/host, path, href</span>等部分。<code>parse</code>方法可以将url解析成以上部分，且不要求url完整。<code>parse</code>的第二和第三个参数分别可以将query部分转换成对象和解析不带协议头的URL。相反地，<code>format</code>方法允许将URL对象转换为URL字符串。<code>resolve</code>方法支持URL的拼接。</p>
		<p><a href="https://nodejs.org/api/querystring.html" target="_blank"><code>querystring</code></a>实现了query字符串和参数对象之间的转换，类似于PHP的<code>$_GET，$_POST</code>。同样适用<code>parse</code>方法和<code>stringify</code>方法完成两个方向的转换。</p>
		<p><a href="https://nodejs.org/api/zlib.html" target="_blank"><code>zlib</code></a>函数支持压缩和解压到功能，在对HTTP响应体数据压缩时，可能需要用到这个模块。下面的范例是官网文档使用的判断用户端是否支持gzip，并在支持时返回gzip之后的响应体数据：</p>
		<pre><code>http.createServer(function (request, response) {
    var i = 1024,
        data = '';

    while (i--) {
        data += '.';
    }

    if ((request.headers['accept-encoding'] || '').indexOf('gzip') !== -1) {
        zlib.gzip(data, function (err, data) {
            response.writeHead(200, {
                'Content-Type': 'text/plain',
                'Content-Encoding': 'gzip'
            });
            response.end(data);
        });
    } else {
        response.writeHead(200, {
            'Content-Type': 'text/plain'
        });
        response.end(data);
    }
}).listen(80);</code></pre>
		<p>同理，<code>zlib</code>可以使用<code>gunzip</code>解压缩文件。</p>
		<p><a href="https://nodejs.org/api/net.html" target="_blank"><code>net</code></a>模块可以创建底层的socket服务器或是客户端，但是在前端领域使用范围并不广。它可以在socket层面实现HTTP请求和响应。需要有网络编程的底层认识和HTTP协议的熟悉。</p>
		<p>最后还需要注意的几点是，<code>http</code>模块创建的服务器返回响应时默认使用<code>chunked</code>传输模式，因为<code>writeHead</code>方法后的响应体数据长度未知，设置<code>header</code>中的<code>Content-Length</code>字段后，NodeJS就不会自动添加<code>Transfer-Encoding</code>字段。<code>http</code>模块提供一个全局客户端<code>http.globalAgent</code>，允许直接使用<code>request</code>方法和<code>get</code>方法，但是最多只允许5个并发连接，通过<code>http.globalAgent.maxSockets</code>可以修改这个值。</p>
		<h3 id="node_thread">进程管理</h3>
		<p>NodeJS可以可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。与之相关的API有<code>process, child_process, cluster</code>等等。</p>
		<p>其中<code>process</code>对象可以感知和控制NodeJS自身进程的方方面面，它是一个全局对象，可以在任何地方使用。通过<code>process</code>可以感知nodeJS进程的各种状态，如<code>process.argv</code>获取命令行参数。它也继承<code>eventEmitter</code>。有<code>exit</code>等事件可以监听，同时有<code>exit, stdin, stdout, env</code>等对程序的精细控制。</p>
		<p><a href="https://nodejs.org/api/child_process.html" target="_blank"><code>child_process</code></a>可以创建和控制子进程，利用<code>spawn, fork</code>方法创建新的进程，使用<code>exec, execFile</code>方法执行命令、文件。<code>Spawn</code>方法还被其他API做进一步的封装，以适应不同场景。<code>cluster</code>模块是对<code>child_process</code>的进一步封装，用于解决单进程NodeJS Web服务器不能充分利用多核CPU的问题。</p>
		<p>这里以进程降权和子进程间通过信号通讯为例，熟悉简单API的一些使用：</p>
		<pre><code>http.createServer(callback).listen(80, function () {
    var env = process.env,
        uid = parseInt(env['SUDO_UID'] || process.getuid(), 10),
        gid = parseInt(env['SUDO_GID'] || process.getgid(), 10);

    process.setgid(gid);
    process.setuid(uid);
});
/* parent.js */
var child = child_process.spawn('node', [ 'child.js' ]);

child.kill('SIGTERM');

/* child.js */
process.on('SIGTERM', function () {
    cleanUp();
    process.exit(0);
});		</code></pre>
		<p>实际上父子进程都为NodeJS进程时，可以通过IPC通讯双向传递数据，双方通过<code>on</code>和<code>send</code>方法在IPC上双向传递数据。具体范例见官网对<code>child.send()</code>的范例。这种情况下，子进程通常使用<code>process.fork</code>方法创建。</p>
		<h3 id="node_features">特点</h3>
		<p>正如<a href="#node_what_why">What and Why</a>中所说，NodeJS最大的特点就是事件机制和异步调用。JS是单线程运行的，但是setTimeout，setInterval这样的函数可以通过创建平行进程的形式实现异步的效果。因此实际运行时，JS主进程会顺序向下执行除回调函数以外的代码，这也意味着，回调函数的执行在JS主线程后。例子见<a href="https://nqdeng.github.io/7-days-nodejs/#4.2.2" target="_blank">参考</a>。</p>
		<p>因此，虽然NodeJS提供了很多异步函数的同步版本，但是为了利用它的优势，熟悉回调和异步的编码思路还是很必要的。如，在同步中以返回值的形式嵌套调用，异步里采用回调函数套回调函数。在遍历等步骤时要更为复杂。</p>
		<p>异常处理也是如此，由于异步调用的形式会打断错误冒泡的路径，使之不会被try语句catch住，因此NodeJS提供的try catch语句只能在同步形式下使用。异步API通常采用向回调函数中传入<code>err</code>参数实现。从以上可以看到，NodeJS最大的特点会增大代码的复杂度，尤其在有异常处理的情况下。对此，NodeJS提供了一些解决方法。</p>
		<p><a href="https://nodejs.org/api/domain.html" target="_blank"><code>domain</code></a>模块可以简化异步代码的异常处理。对于全局异常，可以直接通过<code>process</code>的<code>uncaughtException</code>事件捕获。对于普通异常，我们为每个请求创建一个子域，子域内运行的代码可以随意抛出异常，这些异常可以通过子域对象统一捕获，会使得代码简介很多。范例如下：</p>
		<pre><code>function async(request, callback) {
    // Do something.
    asyncA(request, function (data) {
        // Do something
        asyncB(request, function (data) {
            // Do something
            asyncC(request, function (data) {
                // Do something
                callback(data);
            });
        });
    });
}

http.createServer(function (request, response) {
    var d = domain.create();

    d.on('error', function () {
        response.writeHead(500);
        response.end();
    });

    d.run(function () {
        async(request, function (data) {
            response.writeHead(200);
            response.end(data);
        });
    });
});		</code></pre>
		<p>根据NodeJS官方文档的说法，无论怎么捕获到异常，都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。这是由于NodeJS的部分API内部是用C/C++实现的，代码在执行过程中穿梭在JS引擎内部和外部，因此JS的异常抛出机制可能会打断正常的代码执行，导致C/C++部分代码表现异常。而使用JS语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上述问题。</p>
		<h3 id="node_examples">使用示例</h3>
		<p>这一部分主要展示了一个完整的应用实例。</p>
		<p>1. 为了展示NodeJS的最基本的使用和简单的调试方式。我们创建一个用于启动应用的主文件，起名为<code>server.js</code>，写入如下代码。</p>
		<pre><code>var http = require("http");

http.createServer(function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello, World!");
    response.end();
}).listen(8888);</code></pre>
		<p>将文件放在NodeJS目录下（其他目录亦可），接着用NodeJS执行这段脚本。打开浏览器访问<a href="http://localhost:8888" target="_blank">http://localhost:8888</a>，可看到此网页。对比PHP还是看出很大不同的。</p>
		<p>回调函数很好地反映了使用JS做服务器的特点：事件驱动、异步。在请求到达后交给<code>onRequest()</code>函数处理，函数接受两个参数<code>request</code>和<code>response</code>。</p>
		<p>2. 上文的<code>server.js</code>是启动服务器基本代码，需要交给主文件<code>index.js</code>使用。因此，采用模块一节介绍的方法，使用<code>exports</code>对象。新建<code>index.js</code>，使用<code>require</code>导入。</p>
		<pre><code>var http = require("http");

function start(){
    http.createServer(function(request, response){
        console.log("Request Received");
        response.writeHead(200, {"Content-Type": "text/plain"});
        response.write("Hello, World!");
        response.end();
    }).listen(8888);
    console.log("Server has started.");
}

exports.start = start;

var server = require("./server");
server.start();</code></pre>
		<p>这次同样使用<code>node index.js</code>启动脚本，可以实现同样的效果。</p>
		<p>3. 路由也是一个Web应用开发的关键一块。利用<code>url</code>模块可以完成这一功能。同时在<code>server.js</code>中，将<code>route</code>作为参数传入<code>start</code>函数中。在<code>index.js</code>中，导入<code>router</code>模块。<code>router.js</code>代码如下。</p>
		<pre><code>function route(handler, pathname){
    console.log("Handle a request to " + pathname);
    if(typeof(handler[pathname]) === "function")
        handler[pathname]();
    else
        console.log("Handler for "+ pathname+ " not found.");
}

exports.route = route;</code></pre>
		<p>4. 在start路径下允许用户输入数据，并在upload目录下获得POST数据，需要用到<code>stream</code>和<code>querystring</code>的内容。<span class="i">Server.js</span>和<span class="i">requestHandler.js</span>关键部分定义如下：</p>
		<pre><code>function start(router, handler){
    http.createServer(function(request, response){
	var pathname = url.parse(request.url).pathname;
	var postData = "";
	console.log("Request for "+pathname+" received");

	request.setEncoding("utf-8");
	request.on("data", function(chunk){
		postData += chunk;
		console.log("Receive POST data chunk "+chunk+".");
	});

	request.on("end", function(){
		router(handler,pathname,response,postData);
	});
		
    }).listen(8888);
    console.log("Server has started.");
}
var querystring = require("querystring")

/* requestHandler.js */
function start(response, data){
    console.log('Handler \'start\' was called.');
    var body = '&lt;html>'+
        '&lt;head>'+
        '&lt;meta http-equiv="Content-Type" content="text/html; '+
        'charset=UTF-8" />'+
        '&lt;/head>'+
        '&lt;body>'+
        '&lt;form action="/upload" method="post">'+
        '&lt;textarea name="text" rows="20" cols="60">'+
        '&lt;textarea>'+
        '&lt;input type="submit" value="Submit text" />'+
        '&lt;/form>'+
        '&lt;/body>'+
        '&lt;/html>';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, data){
    console.log('Handler \'upload\' was called.');
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("You have sent "+ querystring.parse(data).text);
    response.end();
}
</code></pre>
		<p>5. 利用NodeJS的异步特点和子进程模块，可以将<code>start</code>和<code>upload</code>函数中的耗时操作设为异步进行，将异步运行的结果交给回调函数处理。在<span class="i">requestHandler.js</span>中添加<code>exec</code>语句即可。同时，允许用户上传文件，并将图片在浏览器中显示出来。可以用第三方插件完成大部分功能。这里从略。可以见更多中的Node入门。</p>
		<h3 id="node_more">更多</h3>
		<p><a href="https://nqdeng.github.io/7-days-nodejs/" target="_blank">七天学会NodeJS</a>，<a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank">Node入门</a></p>
		<hr>
		<h1 id="npm">npm</h1>
		<h3 id="npm_introduction">简介</h3>
		<p>npm是NodeJS随同安装的包管理工具。由于NodeJS使用模块组织工程的特点，npm能解决NodeJS部署上的很多问题。它允许用户从npm服务器下载别人编写的三方包到本地使用、允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用、允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</p>
		<p>同时，NPM还是NodeJS的开放式模块登记和管理系统。它构建了一个NodeJS模块平台，发挥了类似github的功能。</p>
		<h3 id="npm_install">安装</h3>
		<p>npm一般随NodeJS一起安装。安装后，可以通过<code>npm intall npm@latest –g</code>进行更新。<code>npm help</code>和<code>npm –l</code>可以查看npm的帮助信息。</p>
		<h3 id="npm_commands">常用命令</h3>
		<p><code><strong>npm init</strong></code>: 在项目文件根目录下，需要有<span class="i">package.json</span>来完成模块的开发说明。该命令可以初始化新的<span class="i">package.json</span>文件，通过询问的方式完成。使用参数<code>-f</code>和<code>-y</code>可以跳过询问。</p>
		<p><code><strong>npm set</strong></code>: 用来设置npm的环境变量，类似于<code>git config –global</code>。有<code>init-author-name</code> <code>init-author-email</code> <code>init-author-urllicense</code>等选项可供选择。针对某个项目有特殊设置时，可以另行<code>npm config</code>。</p>
		<p><code><strong>npm info</strong></code>: 查看模块具体信息。类似于查看<span class="i">package.json</span>。还可以查看字段信息。如，<code>npm info {{module_name}} description</code>。</p>
		<p><code><strong>npm search</strong></code>: 按照模块名搜索具体模块。npm的包名必须唯一。</p>
		<p><code><strong>npm list</strong></code>: 树形结构列出当前项目安装的模块和其依赖模块。可以跟<code>-global</code></p>
		<p><code><strong>npm install</strong></code>: 最常用的一个命令。安装可以选择本地（当前文件夹的<span class="i">node_modules</span>下）或全局。全局安装只适用于工具模块。该命令甚至支持通过github代码库地址安装。参数<code>-f</code>可以强制重新安装一个模块。删除<span class="i">node_modules</span>目录，执行该命令可以强制安装所有模块。</p>
		<p>在模块后，可以用<code>@</code>后接版本号安装特定版本，<code>latest</code>表示最新版，<code>beta</code>表示测试版。后接<code>--save</code>会添加<code>dependencies</code>到<span class="i">package.json</span>中。<code>--save-exact</code>可以添加确切版本。<code>--save-dev</code>添加到<code>devDependencies</code>中。可以简化为<code>-S</code>或<code>-D</code>。<code>--production</code>会安装<code>dependencies</code>中的依赖而不考虑<code>devDependencies。</code></p>
		<p><code><strong>npm update</strong></code>: 升级已安装的本地或者全局模块。<code>--depth</code>可以指定迭代的深度，升级依赖的依赖。</p>
		<p><code><strong>npm uninstall</strong></code>: 卸载已安装模块。</p>
		<p><code><strong>bpm run</strong></code>: 执行<span class="i">package.json</span>中的<code>scripts</code>字段对应的脚本。其中<code>npm run test</code>和<code>npm run start</code>可以简写成<code>npm test</code>和<code>npm start</code>。可以将脚本存成文件，在<code>scripts</code>字段中写上文件路径。同时，<code>npm run</code>执行的命令可以跟命令行参数。（实际上，<a href="http://gruntjs.com/" target="_blank">grunt</a>和<a href="http://gulpjs.com/" target="_blank">gulp</a>这样的工具就是完成此类工作）</p>
		<p><code>npm run</code>的每个命令都有两个钩子pre和post。在执行命令command之前，npm会检查是否有precommand，执行之后会检查是否有postcommand。同时<code>npm run</code>可以使用一些内部变量，如<span class="i">package.json</span>中的<code>name</code>字段可以用<code>$npm_package_name</code>代表。<code>config</code>字段里可以设置内部字段。</p>
		<p><code><strong>npm link</strong></code>: 将开发中的模块链接中本地的<span class="i">node_modules</span>中，方便边开发边使用。<code>npm unlink</code>可以删除符号链接。</p>
		<p><code><strong>npm bin</strong></code>: 执行本地<span class="i">node_modules/.bin</span>目录下的命令。</p>
		<p><code><strong>npm adduser</strong></code>: 在npmjs.com中添加一个用户。</p>
		<p><code><strong>npm publish</strong></code>: 发布模块，在拥有npm账户后。使用<code>npm login</code>登录，接着在本地目录下输入命令即可发布模块。<code>--tag</code>可以为发布模块添加标记</p>
		<p><code><strong>npm deprecate</strong></code>:  废弃某个版本或某个版本范围的模块，后面可以跟警告文本。如<code>npm deprecate mymodule@"&lt;0.2" "fix critical bugs"</code></p>
		<p><code><strong>npm owner</strong></code>: 管理模块的维护者。有<code>ls, add, rm</code>命令可以选择。</p>
		<p>其他的命令还有<code>npm install . –g</code>可用于发布包前的本地测试；<code>npm update cache clear</code>可以清空缓存；<code>npm unpublish {{package}}@{{version}}</code>可以撤销自己发布过的某个版本代码等。更多详细介绍见<a href="https://docs.npmjs.com/cli/" target="_blank">官网文档</a></p>
		<h3 id="npm_download">下载第三方包</h3>
		<p>使用命令<code>npm install {{module_name}}</code>，将包下载到node_modules后，直接使用<code>require({{module_name}})</code>即可加载第三方模块。同时，修改<span class="i">package.json</span>，添加<code>dependencies</code>项，即可批量加载第三方包，这样做的好处在他人加载你的模块时是非常明显的。用户只需关心自己直接使用的第三方包，而不需要自己解决依赖问题。</p>
		<h3 id="npm_install_cmd">安装命令行程序</h3>
		<p>方法和上面类似，如<code>npm install pug –g</code>(<code>-g</code>表示全局安装)，全局安装时，pug默认会安装到<span class="i"><strong>/usr/local(for Linux)</strong></span>或 <span class="i"><strong>%APPDATA%\npm(for Windows)</strong></span>下。npm会自动创建Linux下的软链和Windows下的<code>.cmd</code>文件。</p>
		<h3 id="npm_release">发布自己的包</h3>
		<p>需要在npm注册自己的账号，之后运行<code>npm adduser</code>。账号配置完成后，编辑<span class="i">package.json</span>文件，包括<span class="i">name, version, dependencies, main, bin, man</span>等内容，之后就可以在<span class="i">package.json</span>目录下运行<code>npm publish</code>发布代码了。<span class="i">package.json</span>下字段的更多解释参见<a href="https://docs.npmjs.com/files/package.json" target="_blank">官网文档。下面是一个<span class="i">package.json</span>的样例</a></p>
		<pre><code>{
    "name": "my_package",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "keywords": [],
    "author": "ag_dubs",
    "license": "ISC",
    "repository": {
        "type": "git",
        "url": "https://github.com/ashleygwilliams/my_package.git"
    },
    "bugs": {
        "url": "https://github.com/ashleygwilliams/my_package/issues"
    },
    "homepage": "https://github.com/ashleygwilliams/my_package"
}</code></pre>
		<h3 id="npm_version">版本号控制</h3>
		<p>npm使用语义版本号进行版本号控制。分<code>X.Y.Z</code>三位，分别代表主版本号，副版本号，补丁版本号。其中主版本号对下不兼容，有大变动，次版本号只是新增功能向下兼容，补丁版本号只是修复bug。</p>
		<p>在这个保证下，<code>dependencies</code>可以指定一定范围的版本码。包括>, >=, <, <=, ~, 0.0.x, *, -等等。</p>
		<h3 id="npm_sum_up">小结</h3>
		<p>npm是NodeJS自带的包管理工具。在复杂的工程背景下，通常需要使用许多的第三方包，在第三方框架下搭出可靠好用的应用。尤其在新技术层出不穷的web应用中，包管理成了很重要的一个环节。对于使用模块构建工程的NodeJS，NPM这样的包管理工具将更有利于它的发展和开发者的使用。</p>
		<h3 id="npm_more">更多</h3>
		<p><a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank">npm模块管理器</a></p>
		<hr>
		<h1 id="bower">Bower</h1>
		<h3 id="bower_introduction">简介</h3>
		<p><a href="https://bower.io/" target="_blank">Bower</a>由<a href="https://twitter.com/" target="_blank">twitter</a>推出，是一个和<a href="https://www.npmjs.com/" target="_blank">npm</a>功能十分类似的包依赖管理软件。不同的是，npm管理整个工程项目的包依赖，而Bower专注于前端各网络资源的管理。它可以帮助快速搭建起前端以来环境，并管理各组件的版本状态。</p>
		<p>和npm类似，Bower使用<span class="i">bower.json</span>作为项目配置文件中。使用<code>bower install</code>命令时，后面可以跟包名、github路径、git仓库路径、url或者干脆不要参数。Bower本身的配置文件为项目根目录下的<span class="i">.bowerrc</span>，通过<code>directory, json, endpoint, searchpoint, shorthand_resolver</code>指定了存放库文件的目录、描述库的json文件名，搜索库文件的路径，备选路径，库名称简写形式。下面是一个<span class="i">bower.json</span>的样例: </p>
		<pre><code>{
    "name": "app-name",
    "version": "0.0.1",
    "dependencies": {
        "sass-bootstrap": "~3.0.0",
        "modernizr": "~2.6.2",
        "jquery": "~1.10.2"
    },
    "private": true
}		</code></pre>
		<h3 id="bower_usage">使用</h3>
		<p>通过<code>npm intall bower –g</code>全局安装bower，以便可以使用bower命令。通过<code>bower help</code>可以查看所有的bower命令。bower命令和npm命令是很类似的。有<code>init, install, cache, search, list, info, uninstall</code>等命令。Bower在下载依赖包时，会保存一份到缓存中，通过<code>bower cache list</code>查看。</p>
		<h3 id="bower_question">Bower or npm?</h3>
		<p>由于前后端资源特点的不同，npm基于CommonJS的规范开发，是利于后端模块的依赖管理的，通过<span class="i">package.json</span>管理树形的依赖结构，模块间用require、export沟通。而这在带宽紧张的前端是不完全适合的，前端更需要扁平和松散的依赖关系，减少文件的传输次数。因此，使用简单的Bower在推出后，收到了很大欢迎。但是Bower的缺陷也很明显，bower管理松散、缺乏统一的构建机制。包的格式并没有限制，只通过<span class="i">bower.json</span>沟通。同时，bower缺少npm那样的registry，而直接取用github。</p>
		<p>在Browserify, Webpack这样的工具出现后，使用npm管理前端时，不会出现CommonJS的规范下加上其他规范模块的不伦不类感。未来前后端包依赖统一管理的趋势是必然的，在node良好的生态环境下，使用npm统一管理似乎是更受欢迎的。</p>
		<p>更多的讨论间<a href="https://www.zhihu.com/question/24414899" target="_blank">知乎话题</a>。</p>
		<hr>
		<h1 id="browserify">Browserify</h1>
		<h3 id="brow_intro_usage">简介与使用</h3>
		<p>如在Bower中提到的，浏览器端的文件并没有CommonJS这样的构建规范。因此，在使用npm管理时显得不伦不类。Browserify是node的一个插件，允许使用<code>require</code>的句法书写浏览器端的文件。通过<code>browserify</code>命令将入口文件打包输出，即可建立一个统一的依赖环境，且可以在html中只使用一条script或link等引入。</p>
		<p>假设我们项目需要<a href="http://backbonejs.org/" target="_blank">backbone.js</a>和<a href="https://jquery.com/" target="_blank">jQuery</a>两个模块。首先，通过<code>npm install –g browserify</code>全局安装它。之后新建<span class="i">main.js</span>文件，将服务器端backbone模块转为客户端（即浏览器端）模块。先安装backbone和jquery模块，在main.js中写下如下内容：</p>
		<pre><code>// main.js
var Backbone = require('backbone');
var $ = Backbone.$ = require('jquery/dist/jquery')(window);

var AppView = Backbone.View.extend({
  render: function(){
    $('main').append('&lt;h1>Browserify is a great tool.&lt;/h1>');
  }
});
var appView = new AppView();
appView.render();
</code></pre>
		<p>之后使用browserify将main.js转为app.js:<code>browserify main.js –o app.js</code>。就可以通过<pre><code>&lt;script src=app.js>&lt;/script></code></pre>完成插入。</p>
		<h3 id="brow_manage_generate">管理与生成</h3>
		<p>使用browserify可以将CommonJS转为浏览器可以调用的格式(如上文)，同时，它也可以对纯粹的前端模块打包，然后再html中通过一行命令完成调用。使用<code>browserify-shim</code>支持jQuery等的CDN加载。使用<code>parcelify</code>模块可以对插件自带的css文件进行打包。</p>
		<p>Browserify指定<code>-r</code>参数，还可以在打包模块的同时，为浏览器提供require方法。Browserify还支持实时生成脚本文件，通过browserify的bundle方法写在js文件里。</p>
		<p>更多内容请参考<a href="http://javascript.ruanyifeng.com/tool/browserify.html" target="_blank">阮一峰的Javascript参考教程。</a></p>
		<hr>
		<h1 id="webpack">Webpack</h1>
		<p>类似于Browserify，Webpack也是前端资源管理和打包工具，不过适用范围更广。它可以将松散的有依赖关系的前端资源打包成单一文件，根据loader的不同，它可以将CommonJS, AMD, ES6, CSS, 图片, JSON等视作模块。</p>
		<h3 id="webpack_why">Why</h3>
		<p>现有的模块管理和打包工具(包括commonJS，CMD等)不能很好地对模块进行无缝整合生成适合浏览器端请求的的静态资源。在以下方面发挥不良：<ul>
			<li>拆分依赖树为按需加载的模块</li>
			<li>减少初始化加载时间</li>
			<li>将各种静态资源视为模块</li>
			<li>自定义打包逻辑</li>
		</ul>
		从而，webpack有着以下特点：<ul>
			<li>webpack支持同步和异步两种组织模块依赖的方法</li>
			<li>webpack只能处理原生js模块，但是loader转换器可以将其他资源转换成js模块</li>
			<li>webpack几乎可以处理所有第三方库，甚至运行使用动态表达式加载依赖</li>
			<li>webpack有丰富的插件和高速的运行效率</li>
		</ul>
		</p>
		<h3 id="webpack_usage">安装使用</h3>
		<p>通过npm全局安装<code>npm install webpack –g</code>或安装到项目依赖<code>npm install webpack –save-dev</code>。在全局安装下，我们可以通过webpack命令打包文件。根据官方样例，若有<span class="i">module.js</span>和<span class="i">entry.js</span>如下：</p>
		<pre><code>// module.js
module.exports = 'It works from module.js.'
// entry.js
document.write('It works.')
document.write(require('./module.js')) // add module
</code></pre>
		<p>通过<code>webpack entry.js bundle.js</code>命令将文件打包，并在html文件中引入。在页面启动后，会先启动<span class="i">entry.js</span>中的代码，其他的模块会在运行到require时再执行。</p>
		<p>借助<span class="i">loader</span>，webpack可以处理非javascript资源，从而通过require命令引入其他类型的模块或文件。<span class="i">loader</span>本身是一个函数，它以管道的方式调用，将资源转换格式再传递给下一个<span class="i">loader</span>，但是最后一个<span class="i">loader</span>必须返回js。<span class="i">loader</span>可以接受参数，且作为模块运行在nodejs环境中。因此我们可以通过npm来管理<span class="i">loader</span>或在项目中自己写<span class="i">loader</span>模块。</p>
		<p>如导入css文件时，指定<code>css-loader</code>来读取它，再用<code>style-loader</code>将它插入到页面中，通过命令<code>require("!style!css!./style.css")</code>即可，或在webpack命令后使用参数<code>--module-bind css=style!css</code>。</p>
		<h3 id="webpack_config">配置文件</h3>
		<p>Webpack在执行时，除了命令行参数，默认会搜索当前目录下的<span class="i">webpack.config.js</span>文件。这个问价有着类似于<span class="i">package.json</span>的功能。也可以通过<code>—config</code>手动指定配置文件位置。例如，我们可以创建以下配置文件，替代上文的做法：</p>
		<pre><code>var webpack = require('webpack')

module.exports = {
    entry: './entry.js',
    output: {
        path: __dirname,
        filename: 'bundle.js'
    },
    module: {
        loaders: [
            {test: /\.css$/, loader: 'style!css'}
        ]
    }
}		</code></pre>
		<p>此外，借助插件可以完成更多<span class="i">loader</span>之外的功能，在配置文件中指定<code>plugins</code>属性即可。实际上除了上面介绍的，配置选项还有很多（上面介绍的更常用），如<code>watch, debug</code>等等，参见<a href="http://webpack.github.io/docs/configuration.html" target="_blank">官方文档</a>对配置文件的讲解。</p>
		<h3 id="webpack_more">更多</h3>
		<p>在开发环境下，还有<code>webpack-dev-server</code>辅助浏览项目中的页面和资源输出，并可以在浏览器中的<a href="http://localhost:8080/webpack-dev-server/" target="_blank">localhost:8080/webpack-dev-server/</a>位置下查看进度。详情可以查看<a href="https://webpack.github.io/" target="_blank">官网</a>。</p>
		<p>本节内容大多参考官网和<a href="http://zhaoda.net/webpack-handbook/index.html" target="_blank">Webpack中文指南</a>。个人认为这种工具型的技术实操学习起来更快。</p>
		<hr>
		<h1 id="grunt">Grunt</h1>
		<h3 id="grunt_tutorial">入门</h3>
		<p>在JS开发的过程中，经常会遇到一些重复性工作，如压缩代码，检查语法错误，将Sass文件转成CSS文件等。Grunt就是便于我们自动管理和运行任务的自动任务运行器。它会按照预定顺序执行它们，简化重复性工作的负担。</p>
		<p>使用grunt前，需要使用npm命令将<code>grunt-cli</code>全局安装。需要注意的是，<code>grunt-cli</code>是通过组织安排其他grunt组件起到组建作用的。使用grunt时，需要在工程目录下添加<span class="i">package.json</span>和<span class="i">Gruntfile</span>两份文件，它们分别用来便于将项目发布为npm模块和配置和定义任务并加载Grunt插件。通常，最好在<span class="i">package.json</span>中间添加grunt插件的依赖。</p>
		<h3 id="gruntfile">Gruntfile</h3>
		<p><span class="i">Gruntfile</span>由<code>wrapper</code>函数、项目于任务配置、加载grunt插件和任务、自定义任务及部分构成。下面就是一个<span class="i">Gruntfile</span>的文件案例，加载<code>grunt-contrib-uglify</code>压缩资源文件。</p>
		<pre><code>module.exports = function(grunt) {

    // Project configuration.
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        uglify: {
            options: {
                banner: '/*! <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> */\n'
            },
            build: {
                src: 'src/<%= pkg.name %>.js',
                dest: 'build/<%= pkg.name %>.min.js'
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-uglify');

    grunt.registerTask('default', ['uglify']);

};		</code></pre>
		<p><ul>
			<li><code>Wrapper</code>函数：上文中的<code>module.export = function(grunt){}</code>部分。每一个<span class="i">Gruntfile</span>都遵循此格式，所写的grunt代码必须放在此函数的代码块内。</li>
			<li>项目和任务配置：通过<code>grunt.initConfig()</code>将grunt任务所需要的配置对象写在输入参数里面。理论上，这个对象可以存储任意的数据。在上面的案例里，通过<code>grunt.file.readJSON</code>将<span class="i">package.json</span>中的元数据引入到<code>grunt config</code>。并通过制定<span class="i">uglify</span>的属性，配置<span class="i">uglify</span>任务。</li>
			<li>加载grunt插件与任务：通过<code>grunt.loadNpmTasks({{plugin_name}})</code>使用已用npm安装的grunt插件。<code>grunt –help</code>将列出所有可用的任务。</li>
			<li>自定义任务：即上文中的<code>grunt.registerTask()</code>，指定grunt的默认任务，在grunt命令后没有任务时，默认执行<span class="i">uglify</span>任务。实际上，还可以通过<code>grunt.loadTasks</code>加载定义好的外部任务。</li>
		</ul></p>
		<h3 id="grunt_config">任务配置</h3>
		<p>当运行一个任务时，grunt会自动查找配置对象中的同名属性。在同名属性下甚至可以定义不同的target针对不同任务环境，通过grunt {{task_name}}:target的形式访问。在普通环境下grunt会默认执行所有target。同时，在任务配置中，任务的<code>options</code>属性可以覆盖默认值，在不需要的时候可以忽略。</p>
		<p>在文件操作中，grunt通过src-dest的形式定义文件映射，并提供了不同程度的描述和控制。在简洁格式下，通过为target至此那个src和dest属性完成src-dest映射。这种格式支持个每个映射指定额外属性。文件对象格式下，则是用目标文件名做属性名，源文件列表做它的值，这种方式可以指定多个映射，但是不能给每个映射指定附加属性。文件数组格式支持对应多个映射，且允许每个映射拥有额外属性。下面是它们的一些样例。</p>
		<pre><code>grunt.initConfig({
    jshint: {
        foo: {
            src: ['src/aa.js', 'src/aaa.js']
        },
    },
    concat: {
        foo: {
            files: {
                'dest/a.js': ['src/aa.js', 'src/aaa.js'],
                'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'],
            },
        },
        bar: {
            files: [
                {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true},
                {src: ['tmp/**/*'], dest: 'dest/tmp/', filter: 'isFile'},
            ],
        }
    }
});		</code></pre>
		<p>上面concat的<code>bar</code>目标中，使用了<code>filter</code>过滤函数找到<span class="i">tmp</span>目录下的所有文件还可以创建自己的过滤函数。Grunt支持在<code>src</code>中通过通配符指定源文件路径，关于通配符模式的语法，可以参见grunt中文文档。当源文件数目很多，难以一一列出时，可以通过<code>dynamic_mappings</code>动态指定文件映射关系。</p>
		<p>使用<code><% %></code>分隔符指定的模板会从配置文件中读取响应数据来填充。因此，在其中写入grunt命令甚至也是可行的。之前案例里，也是通过<code>grunt.file.readJSON</code>读入外部文件导入配置的。</p>
		<h3 id="grunt_example">配置实例</h3>
		<p>假设我们的某个项目需要<a href="https://github.com/gruntjs/grunt-contrib-uglify" target="_blank">grunt-contrib-uglify</a>, <a href="https://github.com/gruntjs/grunt-contrib-qunit" target="_blank">grunt-contrib-qunit</a>, <a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank">grunt-contrib-concat</a>, <a href="https://github.com/gruntjs/grunt-contrib-jshint" target="_blank">grunt-contrib-jshint</a>, <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank">grunt-contrib-watch</a>这5个插件。首先，我们写好<code>wrapper</code>函数和初始化<code>configuration</code>对象。并通过<pre><code>pkg: grunt.file.readJSON(package.json)</code></pre>将<span class="i">package.json</span>中的项目配置信息读进来。接着，我们需要逐一配置上面各插件。</p>
		<p>Concat插件功能是将依赖的所有资源文件打包，通过指定o<code>ptions</code>中的<code>separator</code>属性可以更改默认的合并输出文件间的分隔符，指定<code>dist</code>属性，确定将要合并的文件和合并后文件的存放位置。例如我们可以如下配置，将所有文件合并为与项目名同名的输出文件。</p>
		<pre><code>concat: {
    dist: {
        src: ['src/**/*.js'],
        dest: 'dist/<%= pkg.name %>.js'
    }
}		</code></pre>
		<p>Uglify插件用来压缩JS文件。我们可以指定<code>options</code>中的<code>banner</code>给出压缩文件的注释。可以简单地用文件对象的格式确定输入输出。这里我们将concat插件链接的这些文件压缩成一个<code>.min.js</code>文件。示例如下：</p>
		<pre><code>uglify: {
    options: {
        banner: '/*! <%= pkg.name %> <%= grunt.template.today("dd-mm-yyyy") %> */\n'
    },
    dist: {
        files: {
            'dist/<%= pkg.name %>.min.js': ['<%= concat.dist.dest %>']
        }
    }
}		</code></pre>
		<p>QUnit插件用来进行单元测试，只需为它指定用于测试的文件位置即可。示例如下：</p>
		<pre><code>qunit: {
    file: ['test/**/*.html']
}		</code></pre>
		<p>JSHint插件可以检查代码中的潜在错误(即<code>lint</code>)。<code>Files</code>属性里是<code>lint</code>的对象。实例如下：</p>
		<pre><code>jshint: {
    // define the files to lint
    files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
    // configure JSHint (documented at http://www.jshint.com/docs/)
    options: {
            // more options here if you want to override JSHint defaults
        globals: {
            jQuery: true,
            console: true,
            module: true
        }
    }
}		</code></pre>
		<p>Watch插件用于检测指定文件的变化，在它们变化时执行指定的任务。只需指定<code>files</code>属性和<code>tasks</code>属性即可。</p>
		<p>最后的最后，通过<code>grunt.loadNpmTasks()</code>将插件导入，并<code>registerTask</code>注册所需的任务，尤其是<code>default</code>任务（当然也可以注册其他可选任务）。</p>
		<h3 id="grunt_task">任务与插件</h3>
		<p>启动grunt时，默认附带要执行的任务，当不跟参数时，执行<code>default</code>任务。通过<code>registerTask</code>确定任务名和任务列表。如上面的一些例子。</p>
		<p>使用<code>grunt.registerMultiTask()</code>还可以创建多任务，它通过输入的属性名和目标名执行任务，并在未指定目标时执行所有目标。在自定义任务时，可以通过<code>grunt.task.run</code>执行其他任务，还可以访问自身的参数如名称、输入参数做相应处理。通过<code>grunt.task.require()</code>检查依赖任务执行成功与否或配置属性是否存在。</p>
		<p>在grunt 0.4的版本下，<code>grunt-init</code>被拆分成独立的模块，可以通过npm安装。通过grunt插件模板可以创建自己的grunt插件，用类似于npm的形式部署和发布。在发布时，注意命名空间。</p>
		<p><strong>Grunt cli</strong>是grunt的命令行工具。全局安装后，通过<code>grunt –h</code>即可查看grunt的所有命令。</p>
		<h3 id="grunt_more">更多</h3>
		<p><a href="http://www.gruntjs.net/getting-started" target="_blank">Grunt的中文文档</a>介绍得很好，可用作入门。</p>
		<hr>
		<h1 id="gulp">Gulp</h1>
		<h3 id="gulp_tutorial">入门</h3>
		<p>Gulp是个grunt功能类似的自动化构建工具。它利用Node.js的流概念，在管道中传输数据流，从而完成项目构建。同样使用<code>npm install –global</code> glup全局安装gulp组件，或作为项目开发依赖使用<code>--save-dev glup</code>安装。接着在项目的根目录下新建<span class="i">gulpfile.js</span>的文件，写入<code>glup.task(default, function(){})</code>来定义任务，并通过glup命令执行。还可以通过<code>glup &lt;task1> &lt;task2></code>执行系列任务</p>
		<h3 id="gulp_api">常用API</h3>
		<p>为了简化用户的使用难度，gulp的API用法很简洁，数目也很少。</p>
		<p><code><strong>gulp.src(globs[, options])</strong></code>。输出符合glob匹配模式或匹配模式数组的文件，并返回一个stream可以被pipe方法传递到别的插件中。Glob的写法和Grunt类似。Options中可以选择<code>buffer, read, base</code>等属性，更改读取格式等。以下是样例。</p>
		<pre><code>gulp.src('client/templates/*.jade')
    .pipe(jade())
    .pipe(minify())
    .pipe(gulp.dest('build/minified_templates'));
</code></pre>
		<p><code><strong>gulp.dest(path[, options])</strong></code>。可以被<i>pipe</i>进来，将会写入文件，且重新输出所有数据。因此可以继续将它<i>pipe</i>到多个文件。若文件夹不存在将会自动创建。样例如下：</p>
		<pre><code>gulp.src('./client/templates/*.jade')
    .pipe(jade())
    .pipe(gulp.dest('./build/templates'))
    .pipe(minify())
    .pipe(gulp.dest('./build/minified_templates'));
</code></pre>
		<p><code><strong>gulp.task(name[, deps], fn)</strong></code>用来定义一个使用<i>orchestrator</i>实现的任务。<code>name</code>指定任务名，<code>deps</code>指定任务列表数组，这些任务会在当前任务之前完成。<code>fn</code>表示任务要执行的一些操作。在<code>fn</code>接受一个<code>callback</code>，返回一个<code>stream</code>或返回一个<code>promise</code>时，允许任务异步执行。默认下，gulp会一次性运行所有<code>task</code>且不做等待。因此，若想创建一个序列化<code>task</code>队列，需要1）给出提示告知<code>task</code>依赖另一个<code>task</code>完成。样例如下:</p>
		<pre><code>var gulp = require('gulp');

gulp.task('one', function(cb) {
	//do something
    cb(err);
});

gulp.task('two', ['one'], function() {
    // 'one' finshed
});

gulp.task('default', ['one', 'two']);
</code></pre>
		<p><code><strong>gulp.watch(glob[, opts], tasks)</strong></code>或<code><strong>gulp.watch(glob[, opts, cb])</strong></code>。监视文件，并在文件改动时做一些事情。它会返回一个<code>EventEmitter</code>释放<code>change</code>事件。其中<code>tasks</code>为在文件变动后执行的一个或多个<code>gulp.task()</code>名字。用法如：</p>
		<pre><code>var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);
watcher.on('change', function(event) {
    console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});		</code></pre>
		<p>后者的用法则是，在<code>cb</code>中指定每次变动需要执行的<code>callback</code>。这个<code>callback</code>会被传入一个<code>event</code>对象描述监控到的变动。有如<code>path, type</code>这样的属性。其中<code>type</code>表示变动类型，有<code>added, changed, deleted</code>等。</p>
		<p><code>gulp.run</code>可以最大并行化执行系列的任务列表。</p>
		<h3 id="gulp_cli">CLI使用</h3>
		<p>常用的gulp参数很有限。<code>-v</code>显示gulp版本，<code>--require &lt;path></code>在执行前require一个模块，可以多次使用，<code>--gulpfile &lt;path></code>手动指定<span class="i">gulpfile</span>路径，<code>--cwd</code>指定<span class="i">gulpfile</span>开始查找的位置，<code>--tasks</code>显示task依赖树。<code>--color</code>强制显示颜色，<code>--no-color</code>强制不显示颜色，<code>--silent</code>禁止所有日志输出。</p>
		<p>task通过<code>gulp &lt;task name></code>来执行。只执行gulp，则会执行注册名为<code>default</code>的task.</p>
		<h3 id="gulp_more">更多</h3>
		<p>Gulp是基于流的自动构建系统。相对grunt结构简单，学习成本低。文件里存放代码而非配置。<a href="http://slides.com/contra/gulp" target="_blank">作者的幻灯片</a>里做了简明扼要地解释。想要更深入的学习，可以参加中文版的<a href="https://github.com/jabez128/stream-handbook" target="_blank">stream-book</a>对nodeJS流的介绍。在杂项里的<a href="stream">"Nodejs中的Stream"</a>也有做的笔记。</p>
		<hr>
		<h1 id="commonjs">CommonJS</h1>
		<h3 id="common_brief">简介</h3>
		<p>CommonJS的目标是在浏览器环境外构建JS生态系统，出现于2009年。官方的JS标准API是为了构建基于浏览器的应用程序，这限制了JS的更广泛应用。CommonJS定义了更多普通应用的API，它的终极目标是进行JS模块化，把JS提升到类似于Python、Ruby、Java的地位。只要环境兼容，使用CommonJS API编写的应用程序就可以通用。</p>
		<p>而实际上，NodeJS就是CommonJS模块化规范的一种实现。规范还在不断的发展中。以下展示部分内容</p>
		<h3 id="common_feature">特点</h3>
		<p><ul>
			<li>一个文件就是一个独立的作用域，只能通过global共享（不推荐）</li>
			<li>通过<code>exports</code>定义对外接口，通过<code>require</code>加载此接口</li>
			<li>模块可以多次加载，但只在第一次加载时运行并缓存。</li>
			<li>模块加载的顺序和代码中出现顺序一致。</li>
		</ul></p>
		<h3 id="common_module">Module</h3>
		<p>每个模块内部都有一个<code>module</code>对象，对象有<code>id, filename, loaded, parent, children, exports</code>等属性。这些在nodeJS中都有实现。</p>
		<p><code>module.export</code>用于向外导出模块信息。Node中为每个模块提供了一个<code>exports</code>变量预绑定到<code>module.export</code>上，通过<code>exports.xxx</code>的形式导出。破坏这个绑定关系的操作都将使<code>exports</code>变量无效。</p>
		<h3 id="require">Require</h3>
		<p><code>require</code>用于加载模块文件，它会读入并执行一个Javascript文件，然后返回<code>exports</code>对象，如果未发现指定模块会报错。同时，加载的模块的输入时被输出值的拷贝。</p>
		<p><code>require</code>加载模块时，默认为js文件。若路径以<code>/</code>开头表示绝对路径，以<code>./</code>开头表示相对路径，否则node会去<span class="i">node_modules</span>目录下查找。使用<code>require.resolve</code>可以看到确切结果。在找到目录后，会将<span class="i">package.json</span>中的<code>main</code>对应的值作为入口文件。</p>
		<p><code>require</code>进来的模块会放在缓存中，不会多次加载。若想多次执行同一模块，可以用<code>module.exports</code>导出函数，或<code>delete require.cache[moduleName]</code></p>
		<p>模块循环加载时，会先加载不完整的版本，在都<code>require</code>进来后，通过缓存读取<code>exports</code>避免不全的问题。</p>
		<h3 id="amd">AMD and more?</h3>
		<p>CommonJS主要是为JS在后端表现定制的，而浏览器和服务器端的特点是不一样的。<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)" target="_blank">AMD</a>的规范主要为前端JS表现定制。前者加载模块是同步的，后者是异步的。</p>
		<p>AMD规范使用<code>define</code>方法闭包定义模块，格式类似于<pre><code>define(id?: String, dependencies?: String[], factory: Function|Object);</code></pre></p>
		<p><code>id</code>是模块名，可选。<code>dependencies</code>是依赖模块列表。<code>function</code>是模块的具体实现，它的返回值就是模块的输出接口或值。范例如下：</p>
		<pre><code>define('myModule', ['jquery'], function($) {
    return $('body').text('hello world');
});
define(['myModule'], function(myModule) {});
</code></pre>
		<p>其中<code>function</code>的输入参数即为依赖模块的输出。通常将没有id的匿名模块作为应用的启动函数。</p>
		<p>AMD规范允许输出模块兼容CommonJS规范。</p>
		<p><a href="http://requirejs.org/" target="_blank">RequireJS</a>就是采用了AMD规范的用于模块以来的工具，使用方式同上面的范例。正如AMD名字中提到的那样，它异步引入所有的依赖模块，减少的导入的时间。同时也会因此出现隐式的难以发现的错误。与之并列的还有基于CMD规范的<a href="http://seajs.org/docs/" target="_blank">SeaJS</a>，主旨所限，从略。</p>
		<h3 id="common_more">更多</h3>
		<p>CommonJS实际上是JS模块化的一种体现。这也是JS发展的趋势。关于JS模块化编程的介绍见<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">模块的写法</a>，<a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank">AMD规范</a>，<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html?bsh_bid=230697246">require.js用法</a>。这三篇博客系统地讲解了模块化的思路和应用。另外还有<a href="http://www.cnblogs.com/skylar/p/4065455.html" target="_blank">CommonJS,AMD,CMD对比</a>，<a href="http://zhaoda.net/webpack-handbook/amd.html" target="_blank" 
		>AMD使用样例</a>，<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank">Node中CommonJS的部分实现</a>可以参考。</p>
		<hr>
		<h1 id="backbone">Backbone.js</h1>
		<h3 id="backbone_brief">概述</h3>
		<p>MVC框架是代码组织的经典模式，便于团队协作进行开发。M、V、C分别代表Model，View和Controller。同样在Javascript的社区中，也有着许多MVC和MVC变体框架MV*（下面介绍的AngularJS等）。框架的优点在于便于分工和和代码维护，缺点在于限制了代码的写法，且学习成本一般较高。</p>
		<p><a href="http://backbonejs.org/" target="_blank">Backbone.js</a>提出于2010年，它严格来说并不算是MV*框架，而是借助一些功能模块的帮助快速构建一个单页面Web应用。因此它给用户了很大的自由在<code>Model</code>和<code>View</code>的连接上。从它的API结构就能看出，<code>Model</code>和<code>View</code>部分是较重的，<code>Controller</code>部分则只由<code>router</code>和<code>router</code>对应的<code>controller</code>处理函数构成。相对来说，backbone.js的体积很小，且学习成本较低。</p>
		<p>根据官网介绍，<a href="http://underscorejs.org/" target="_blank">underscores.js</a>（一个功能型js函数库）是backbone.js的强依赖，jquery和<a href="https://www.npmjs.com/package/json2js" target="_blank">json2.js</a>是backbone用于Backbone.View的依赖，但是有类似<a href="http://zeptojs.com/" target="_blank">Zepto</a>等替代方案。因此在使用backbone.js时，通常要引入这四个文件。</p>
		<h3 id="backbone_structure">项目组成</h3>
		<p>一般来说，一个backbone.js的应用，由<code>models, views, collections, controllers</code>四部分组成。其中<code>models</code>用来描述数据的一个基本单位。如下：</p>
		<pre><code>App.Models.Person = Backbone.Model.extend({
    defaults: {
        "name": "foo",
        "value": "bar"
    }
});		</code></pre>
		<p><code>Colletions</code>是同一种<code>model</code>的集合，可以方便地表示列表等展示方式，如下：</p>
		<pre><code>App.Collections.Grade = Backbone.collection.extend({
    model: App.Models.Person
});		</code></pre>
		<p>上面的代码表示，<code>Grade</code>这个集合由<code>Person</code>单元组成。View部分用来在页面上呈现数据，呈现中涉及到绑定DOM的工作大多由jquery完成，View部分必须有<code>el</code>属性，指定绑定的DOM节点，<code>events</code>指定监听事件和对应方法，<code>initialize</code>和<code>render</code>方法分别完成初始化和渲染两个步骤。</p>
		<pre><code>App.Views.Medals = Backbone.View.extend({
    el: "#list",

    initialize: function() {
        this.listenTo(Person, 'change', this.render);
        this.listenTo(Person, 'destroy', this.remove);
        this.render();
    },

    render: function() {
        var template = _.template($('item-template').html());
        this.$el.html(template(Person.Medals.toJSON()));
    },

    events: {
        "click .toggle"     : "toggle",
        "dbclick .view"     : "edit",
        "click a.destroy"   : "clear",
        "blur .edit"        : "close"
    }
})		</code></pre>
		<p>控制器一般用来相应路由的结果，定义比较自由，例如下面的形式：</p>
		<pre><code>App.Controllers.show = function(id) {
    var p = new App.Models.Person({id: id});
    p.updateTime(Date.now());
    p.fetch(function(model,response,options){
        var view = new App.Views.Medals({medal: p});
    });
};		</code></pre>
		<p>最后路由方面。通过继承backbone的<code>router</code>模块实现：</p>
		<pre><code>var paths = Backbone.Router.extend({
    routes: {
        ""                  : "wholeApp",
        "users/:id"         : "usershow",
        "users/:id/p:order" : "ordersIndex"
    },

    wholeApp    : App.Controller.default,
    usershow    : App.Controller.show,
    ordersIndex : App.Controller.orderBy
});
new paths();
Backbone.history.start({pushState: true});
</code></pre>
		<p>在定义好路由部分后，通过backbone的<code>history</code>模块的<code>start</code>方法启动路由即可。一个基于Backbone.js构造的项目结构大抵如此，它们可以位于同一个文件下（一般案例完全可以这么做）甚至位于html的script标签内。诚然这便于中小型项目，尤其是单页面逻辑内容丰富的Web应用开发使用，不也和当前流行的组件化、模块化的js开发风格有所不同。目前backbone.js仍然在1.x版本，可能会在2.0版本后采用ES6的原生模块化方案等新js特性吧。</p>
		<h3 id="backbone_api">API介绍（v1.3.3）</h3>
		<p>Backbone官网对它的API有着详细的介绍，且页面风格与Zepto、underscore一致，非常便于阅读和检索。</p>
		<h4 id="backbone_view">View</h4>
		<p><code>Backbone.View</code>的方法用来定义视图类，其中最根本的方法extend拓展定义一个视图类，类的内部通常由<code>render</code>方法渲染界面，渲染时使用类jquery的语法，插入一些html比群标签或计算后的内容。定义好视图类后，通过新建视图实例的形式运行，得到结果，新建时，<strong>有时需要指定<code>Model</code></strong>。</p>
		<p>在需要用到<strong>模板</strong>时，可以先通过underscore(简写符为'<code>_</code>')的<code>template</code>方法导入模板为函数。模板通常建议用<code>&lt;script></code>并指定<code>type=text/template</code>的定义在html文档中，并用jquery的语句获取。导入模板后，可以把数据的json格式输入到函数中。</p>
		<p><ul>
			<li><code><strong>extend(properties[, class properties])</strong></code>：用来创建视图类，有时不在配置中指定<code>el</code>，而通过<code>tagName</code>或是<code>className</code>指定列表中的各元素</li>
			<li><code><strong>initialize([options])</strong></code>：在实例化视图类的时候调用，可以写入<code>el</code>的属性。</li>
			<li><code><strong>el</strong></code>属性：指定视图所绑定的网页元素（通常用在<strong>单例视图类</strong>中），<code>$el</code>则表示<code>el</code>所对应的jquery对象。</li>
			<li><code><strong>tagName, className</strong></code>属性：见上面介绍</li>
			<li><code><strong>template</strong></code>方法：通过_.template(xxx)指定网页模板生成模板函数，在<code>render</code>中渲染。</li>
			<li><code><strong>events</strong></code>属性：指定视图中的事件及其对应的处理函数</li>
		</ul></p>
		<p>另外，还有<code>setElement</code>更改<code>el</code>，<code>remove</code>移除<code>el</code>和jquery自带的一些方法可以使用。</p>
		<h4 id="backbone_event">Events</h4>
		<p><code>Backbone.Events</code>是一个事件对象，任何继承这个对象的对象，都具有<code>Backbone.Events</code>接口，可以使用<code>on</code>和<code>trigger</code>等方法，发布和订阅消息。</p>
		<pre><code>// use extends
var EventListener = _.extend({}, Backbone.Events);
//use clone
var Dispatch = _.extend(Backbone.Events);
</code></pre>
		<ul>
			<li><code><strong>on(event, callback, [context])</strong></code>方法。可以将回调函数绑定在对象的一些事件上，并可以通过<code>off</code>方法取消绑定。<code>once</code>方法绑定的事件只触发一次回调函数。</li>
			<li><code><strong>trigger(event, [*args])</strong>可以触发特定事件。</code></li>
			<li><code><strong>listenTo(other, event, callback)</strong></code>可以把对象绑定在其他对象的事件上，经常用在View视图类中。如<code>view.listenTo(model, 'change', view.render);</code></li>
		</ul>
		<p>Backbone提供了许多内建的事件，如<code>add, remove, update, change, reset, change:[attr], destroy</code>等，更多的参加<a href="http://backbonejs.org/#Events-catalog" target="_blank">官方文档</a>。</p>
		<h4 id="backbone_router">Router</h4>
		<p><code>Router</code>是backbone提供的路由对象，用于将用户请求的url和后台函数一一对应。同样，它也通过<code>extend</code>方法定义。</p>
		<ul>
			<li><code><strong>routes</strong></code>属性：通过键值对形式指定路径和函数名。空字符串代表根路径，<code>*</code>代表任意路径，同时也可以通过":"设置路径参数，这些参数会被捕获并传入处理函数。同样可以用<code>route</code>函数一条条定义路由。</li>
			<li><code><strong>navigate(fragment, [options])</strong></code>：调转到新页面，这是<code>trigger</code>和<code>replace</code>属性可以保留url和浏览器记录。</li>
			<li><code><strong>execute(callback, args, name)</strong></code>：在每次路由时都会调用，通过<code>callback</code>的返回值是否为真，判断是否调用处理函数，如下：</li>
		</ul>
		<pre><code>var Router = Backbone.Router.extend({
    execute: function(callback, args, name) {
        if (!loggedIn) {
            goToLogin();
            return false;
        }
        args.push(parseQueryString(args.pop()));
        if (callback) callback.apply(this, args);
    }
});		</code></pre>
		<p>路由类设置好后，实例化之，并通过<code>Backbone.history.start()</code>启动。通常需要指定<code>pushState</code>为<code>true</code>。如果应用程序不在根目录，还需要设置<code>root</code>值。</p>
		<h4 id="backbone_model">Model</h4>
		<p><code>Model</code>代表单一的对象。和<code>Collection</code>一起组成Model层。Backbone.js并不要求Model的数据位于本地，在使用<code>fetch()</code>等操作时，backbone的sync方法默认会用jquery的<code>get</code>方法等去获取。所以，很多本地存储数据的应用会重写<code>Backbone.sync</code>函数。</p>
		<p>Model依旧使用<code>extend</code>方法生成类，和view类似使用<code>new</code>创建实例，可以在<code>defaults</code>属性中设置默认属性。在生成实例时，需要提供各属性的具体值，且需要有主键字段，便于和MangoDB等数据库互动。</p>
		<ul>
			<li><code><strong>get(attr)，set(attr,[options])</strong></code>分别用来获取和设置该实例的值。在有特殊字符防止xss时，推荐使用<code><strong>escape</strong></code>方法代替<code>get</code>方法。</li>
			<li><code><strong>has(attr), unset(attr,[options]), clear([options])</strong></code>：分别检测是否有某属性，删除某属性和删除所有除id外的属性，<code>options</code>中可以指定<code>silent</code>，不触发<code>change</code>事件。另外，属性可以直接通过<code>attributes</code>访问。</li>
			<li><code><strong>idAttribute</strong></code>属性：指定作为主键的字段。可通过<strong>id</strong>访问。</li>
			<li><code><strong>toJSON([options])</strong></code>：将该实例json化，常和<code>View.template</code>配合使用。</li>
			<li><code><strong>fetch([options])</strong></code>：通过jquery发起XHR请求，获取model数据。在<code>options</code>中可以分别指定<code>success</code>和<code>error</code>的回调，回调分别接受<code>model, response, options</code>。使用方法如下：</li>
			<pre><code>var user = new User ({id: 1});
user.fetch({
    success: function (user){
        console.log(user.toJSON());
    }
})</code></pre>
			<li><code><strong>save([attr], [options])</strong></code>：通知服务器新建或更新Model，如果Model实例不含id属性，将使用<code>POST</code>新建，如果Model带有id属性，<code>save</code>方法将使用<code>PUT</code>更新实例。<code>options</code>和<code>fetch</code>用法类似。</li>
			<li><code><strong>validate(attr, [options])</strong></code>检测属性是否合法会，触发<strong>invalid</strong>事件。<code>isValid()</code>方法会执行validate返回是否合法的结果。</li>
		</ul>
		<p>另外<code>destroy</code>方法清除一个实例，<code>clone</code>拷贝一个实例，<code>hasChanged</code>检测属性是否已更新。Underscore关于对象的如<code>keys</code>，<code>pick</code>等方法也可使用。</p>
		<h4 id="backbone_collection">Collection</h4>
		<p>Colletcion是<strong>同一类</strong>Model的集合，如Model是学生，Collection就是班级；Model是歌，Collection就是专辑。如下面代码所示：</p>
		<pre><code>var Song = Backbone.Model.extend({});
var Album = Backbone.Collection.extend({
    model: Song
});		</code></pre>
		<ul>
			<li><code><strong>add(models, [options]), remove(models, [options])</strong></code>：将new出来的实例直接放入Collection的实例，或通过<code>id</code>字段值移除Model实例。</li>
			<li><code><strong>get(id), set(model, [options])</strong></code>获取collection中的某个model，或重设整个collection。在重设时通过融合的方式完成。</li>
			<li><code><strong>model([attrs], [options])</strong></code>指定collections所包括的Model。<strong>modelId</strong>属性指定Collection标记Model的方法，函数接受<code>attrs</code>。多用在不同<code>idAttribute</code>的情况。</li>
			<li><code><strong>comparator</strong></code>指定排序Model的标准字段。<code>sort([options])</code>方法会跟这个属性来排列Models。</li>
			<li><code><strong>pluck(attr), where(attr)</strong></code>取出所有Models的某一列，返回满足<code>where</code>条件的所有Model。<code>findWhere(attr)</code>返回第一个满足条件的结果。</li>
			<li><code><strong>fetch([options])</strong></code>类似Model中的用法，获取整个Collection。</li>
			<li><code><strong>create(attr, [options])</strong></code>通过Collection创建一个Model。</li>
		</ul>
		<p>此外，underscore和原生用于数组的方法如<code>push, pop, shift, unshift, forEach, every</code>等等函数也可以使用。</p>
		<h3 id="backbone_demo">Demos</h3>
		<p>由于Backbone.js并非使用模块来构建Web应用，且自由度很高，结合上面介绍的API，可以方便地构建很多单页面应用。官网也提供了许多demos，便于初学者上手掌握。</p>
		<p>可以先从<a href="http://arturadib.com/hello-backbonejs/" target="_blank">Hello-backbonejs</a>上手，感受backbone的基本使用。之后学习<a href="http://backbonejs.org/examples/todos/index.html" target="_blank">Todos</a>（系列的<a href="https://github.com/tastejs/todomvc" target="_blank">TodoMVC</a>也是很不错的学习<a href="https://angularjs.org/" target="_blank">Angular</a>，<a href="http://emberjs.com/" target="_blank">Ember.js</a>等的demo），就可以开始自己捣鼓点小东西了。个人认为对比下面介绍的框架，已经好上手很多了。</p>
		<h3 id="backbone_more">更多</h3>
		<p><strong>Backbone.locaStorage</strong>也是很常用的backbone的插件，用于将Model和Collection的数据插入到本地存储中，根据介绍，使用很简单：</p>
		<pre><code>window.SomeCollection = Backbone.Collection.extend({

    localStorage: new Backbone.LocalStorage("SomeCollection"), // Unique name within your app.

    // ... everything else is normal.

});		</code></pre>
		<p>另外很喜欢官网的style，和underscore以及zepto的一样，简约而便于检索。本文的样式也参考自此。</p>
		<hr>
		<h1 id="express">Express JS</h1>
		<h3 id="express_brief">概述</h3>
		<p>Express是基于Node.js的流行Web开放框架，没有对NodeJS进行二次抽象。可以快速搭建一个完整功能的网站。后面我们将用一个例子简单展示express的特点。</p>
		<p>新建一个项目目录，进入该目录新建<span class="i">package.json</span>文件，填写项目的一些配置信息。包括<span class="i">name, description, version, dependencies</span>等等。其中<code>dependencies</code>，/中可指定express的版本范围，如<code>4.x</code>. 执行<code>npm install</code>指令安装环境。</p>
		<p>新建<span class="i">index.js</span>，写入如下样例：</p>
		<pre><code>var express = require('express');
var app = express();

app.get('/',function(req, res){
	res.send('Hello, world!');
});

app.listen(8888);
</code></pre>
		<p>即可在浏览器看到页面效果。其中<code>app.get</code>对路由的处理还可以拓展到其他路径，封装成路由模块。</p>
		<h3 id="express_basic">基本原理</h3>
		<p>Express框架建立在nodeJS内置的<code>http</code>模块上。上面的<code>app</code>实际上就是由<code>http</code>的<code>createServer</code>方法生成的。而express只是做了一层包装。</p>
		<p>中间件是处理http请求的函数。多个中间件按照流水线的形式处理请求，单个中间件处理完成后，通过调用<code>next</code>方法交给下个中间件处理。<code>next</code>方法所带参数表示抛出错误。可以通过<code>use</code>方法注册中间件。样例如下：</p>
		<pre><code>var express = require('express')
var http = require('http');
var app = express();

app.use('/home', function(req, res, next){
	res.writeHead(200, {"Content-Type": "text/plain"});
	res.end("Welcome!");
});

app.use('/about', function(req, res, next){
	res.writeHead(200, {"Content-Type": "text/plain"});
	res.end("About.");
});

app.use(function(req, res){
	res.writeHead(404, {"Content-Type": "text/plain"});
	res.end("404 error!\n");
});

app.listen(8888);
</code></pre>
		<h3 id="express_methods">常用方法</h3>
		<p>除了上文中用到的<code>use</code>,/，对于一些特殊的<code>use</code>使用，还有别名的方法。如<code>all</code>方法表示所有满足第一个条件的请求都必须通过该中间件，<code>*</code>则表示所有请求都必须通过。<code>get</code>方法和<code>post, put, delete</code>等方法也类似，它们没有<code>next</code>方法，只要一个中间件被调用，后面的中间件就不再调用。注意，<code>app.get(name)</code>意为获取全局变量值。</p>
		<p>这些方法的第一个参数都是请求的路径。Express允许模式匹配，即可以在路径中匹配并捕获模式字段，字段后加上<code>?</code>表示模式可选。范例如下：</p>
		<pre><code>app.get('/hello/:who?', function(req, res){
	if(req.params.who) res.end("Hello " + req.parmas.who + "!"); 
	else res.send("Hello guest.");
});		</code></pre>
		<p>url匹配还支持正则匹配。范例略。同时，<code>set</code>方法可以为系统变量指定新值。</p>
		<p><code>response</code>对象也有一些常用方法。<code>redirect</code>方法用于网页重定向，<code>sendFile</code>用于发送文件，<code>render</code>用于渲染网页模板，向模板中传递数据。<code>Request</code>也有着许多常用对象，<code>ip</code>用于获得请求的ip地址，<code>files</code>用于获取上传的文件。</p>
		<p>搭建https服务器的方法略。更多API见<a href="http://expressjs.com/zh-cn/api.html" target="_blank">官方文档</a>。</p>
		<h3 id="express_template">网页模板</h3>
		<p>通常，对于大部分请求，返回的结果都为较复杂的网页，此时使用<code>send</code>方法就不再方便。展示静态网页模板时，使用<code>response</code>对象的<code>sendFile</code>方法可以解决此问题。渲染动态网页可以使用<code>render</code>方法，也可以利用一些模板引擎完成。</p>
		<p>在模板中通过{{}}(因模板而异)加载动态数据。模板后缀，视图模板存放的路径，渲染引擎入口等可以在入口js处统一声明。</p>
		<p>静态文件通过<code>express.static</code>方法指定路径，在浏览器发出非HTML文件请求时，去指定的目录寻找。</p>
		<h3 id="express_router">路由</h3>
		<p>在4.0后，express将路由功能封装成了一个单独的组件<code>Express.Router</code>。同样拥有<code>use, get, param, route</code>方法。用法和<code>app</code>极为相似。方便通过<code>app.use(xxx, router)</code>的形式挂载不同的根目录。<code>route</code>方法以路径作为输入参数，之后跟<code>post</code>或其他方法绑定到该路径上。注意，<code>router</code>中的<code>use</code>中间件须放在HTTP动词方法之前，否则不会执行。</p>
		<p><code>app</code>同样有<code>route</code>属性，<code>app.route</code>是<code>express.router()</code>的等价形式。</p>
		<h3 id="express_modules">常用模块</h3>
		<p>使用Express快速开发网络应用的时候，会用到许多现成的模块辅助开发。它们能在express的组织下方便地完成各种功能。</p>
		<h4 id="body-parser"></h4>
		<p>body-parser是express的处理请求体的中间件。它接受stream格式的<code>request</code>体，并以用户需要的格式友好地返回。以下是一些body-parser提供的API。</p>
		<p><code>bodyParser.json(options)</code>解析json格式的请求体，接受Unicode编码的请求提，支持gzip和deflate格式。<code>req.body</code>会被解析后的<code>body</code>替代。</p>
		<p><code>bodyParser.raw(options)</code>将请求题以Buffer类型解析。返回的解析器将请求体解析为<code>buffe</code>r格式。<code>bodyParser.text(options)</code>类似，解析为<code>string</code>格式。</p>
		<p><code>bodyParser.urlencoded(options)</code>只解析urlencoded请求体，接受UTF-8编码。生成的新的请求体是键值对的格式。</p>
		<p>这些API可以按顺序多次列写，依次尝试解析直到body体被成功解析为止。更多信息见<a href="https://github.com/expressjs/body-parser" target="_blank">官方解释</a>。</p>
		<h4 id="cookie-parser"></h4>
		<p>cookie是用来解决HTTP协议无状态的问题的。Cookie通过服务器发往客户端浏览器，在浏览器每次发起请求时附带，有<code>path, expire, maxAge, secure, httpOnly</code>等参数。</p>
		<h4 id="express-session">Express-session</h4>
		<p>为了保证cookie的安全性，session因此诞生。Session通过<code>sid</code>标识，通常储存在cookie中，服务器每次接收到请求，将session id对应的<code>data</code>关联，进行相应操作。Session可以存放在1) 内存2) cookie 3) redis, memcached缓存 4)数据库中。</p>
		<p>Express中操作session用来这个模块主要通过<code>session(options)</code>初始化并作为处理回话(session)的中间件。Options中的主要参数有<code>name</code>，用来指定cookie中保存session的字段名，<code>store</code>指定session的存储方式，<code>secret</code>指定hash加密cookie的方式，<code>cookie</code>指定存放sid的cookie的相关选项，<code>genid</code>指定生成新sid时用到的函数，<code>rolling</code>指定每个请求是否重新设置一个cookie，<code>resave</code>指定session未更改时，是否保存session值。</p>
		<h4 id="connect-mongo">Connect-mongo</h4>
		<p>这个组件是用来方便地将用户session存储在mongodb中的。通过<code>require(xxx)(session)</code>引入后，如<code>session(new MongoStore(opts))</code>这样使用。<code>opts</code>里可以通过Mangoose或其他驱动器或url指定MondoDB服务器。详情见<a href="https://github.com/kcbanner/connect-mongo" target="_blank">github api解释</a></p>
		<h4 id="ejs">Ejs</h4>
		<p>实际上ejs严格来说是一个模板引擎，负责将模板文件替换成html文件再发回到客户端。ejs有三种标签。<code><% code %> <%= code %> <%- code %></code>分别对应JS代码，可以通过使用for循环显示列表内容。ejs还可以使用<code><%- include a %></code>引入其他模板从而实现页面布局的效果。</p>
		<p>个人认为jade模板引擎Markdown式的写法更简洁。</p>
		<h4 id="express-mongo">Mongodb</h4>
		<p>Node开发经常使用的MongoDB做数据库。MongoDB是Mongo在node.js中的驱动。在2.x版本的mongodb中，通过<code>MongoClient.connect(url, opts, callback)</code>创建和数据库的连接，其中<code>callback</code>可以读取<code>err</code>和<code>db</code>对象，从而对数据库操作。通过<code>db.collection(name)</code>获取指定集合，使用得到的collection的<code>insert, insertMany, find(quert), sort, limit, update, delete</code>完成增删改查。使用<code>toArray</code>可以把查询的数据转成数组格式。</p>
		<p>更多Mongodb使用参见<a href="http://mongodb.github.io/node-mongodb-native/2.1/api/" target="_blank">node-mongodb API文档</a>.</p>
		<h4 id="express-flash">Connect-flash</h4>
		<p>flash使用session的特殊区域。信息在展示前被写入<code>flash</code>，展示给用户后即被擦除。Flash常用于跳转页面，保证信息能够正确传递到下一个被渲染的界面。</p>
		<p>使用时，在初始化session后，创建<code>flash</code>中间件即可。在页面即将跳转时，写入信息到<code>req.flash</code>中，在跳转的页面里，即可通过<code>req.flash</code>获取到。</p>
		<h3 id="express_more">更多</h3>
		<p>在实际开发中，通常综合了许多的模块。惯例下，在<span class="i">bin</span>目录下放置可执行文件，<span class="i">models</span>目录下放置模型定义和与数据库沟通的文件充当Model部分，<span class="i">node_modules</span>放置依赖包，<span class="i">public</span>放置静态文件包括css文件等，<span class="i">routes</span>放置路由文件充当Controller部分，<span class="i">views</span>放置视图模板作为View部分。父目录下还有<span class="i">app.js</span>作为入口文件，<span class="i">package.json</span>作为项目配置文件，<span class="i">settings.js</span>储存常用设置参数如数据库端口等。</p>
		<p>Express有着丰富的模块可供选择，模块文档可以在npm和github上找到，这些模块可以帮助你轻松完成复杂功能，让开发者专注于工程结构和代码逻辑。以上的笔记来自<a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank">阮一峰博客</a>和<a href="https://github.com/nswbmw/N-blog/wiki/%E7%AC%AC1%E7%AB%A0--%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%9A%E5%AE%A2" target="_blank">开发简单博客的实例</a>。</p>
		<hr>
		<h1 id="react">React JS</h1>
		<h3 id="react_what_why"><a href="https://facebook.github.io/react/blog/2013/06/05/why-react.html" target="_blank">What and Why</a></h3>
		<p>React起源于facebook的内部项目。起初用来搭建Instagram的UI界面，渐渐地发展为前后端都有的网络应用解决方案。React作为开发UI界面的库，特点十分明显。</p>
		<ul>
			<li>组件化，react允许将代码封装成一个个组件，然后像插入HTML标签一样，在网页中插入这个组件。在定义好组件后，要做的只是组建的复用和组合。</li>
			<li>组件就像台有限状态机，用户交互改变状态变化，自动触发重新渲染。组件的生命周期内，有特定处理函数去处理状态变化，并更新改变的部分。这在页面数据经常更新时，会非常方便。</li>
		</ul>
		<p>关于它还有些需要明确的东西。首先，React并不是一个完整的MVC框架，它和MVC中的V更像；react也并不是一种新的模板语言，没有<span class="i">JSX</span>的React也能正常工作，<span class="i">JSX</span>是为那些更偏好HTML写法的人准备的。React提供了服务器端的Render能力，但实际上这并不是它的核心出发点，事实上React官方教程是以浏览器端应用介绍为主的。</p>
		<h3 id="thinking_in_react_way"><a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank">Thinking in React Way</a></h3>
		<p>使用React可以快速构建Web应用程序组件。在使用React构建一个产品时，通常有如下几步：</p>
		<ul>
			<li><strong>拆分界面为一个组件树</strong>，理想状态下一个组件应该只做一件事，当功能较大时就需要拆分成更小的子组件。</li>
			<li><strong>利用React创建一个静态版本</strong>，不考虑交互功能，只将数据模型渲染在UI上。在这个过程中，将会构造一些组件，这些组件重用其他组件，并通过props传递数据。注意，这里不用到state，state用来实现交互功能。</li>
			<li><strong>为组件设计最小完整state</strong>，<code>state</code>使得交互触发底层数据模型的变化。考虑设计中的所有数据片段，从父级传入的，不随时间变化的，根据其他<code>props</code>和<code>state</code>算出的多半不适合做state。</li>
			<li><strong>确定state的生命周期</strong>，在上一步确定作为state的数据片段后，需要确定改变或拥有这些state数据的组件。因为React中数据沿着组件树从上向下单向流动，通常，选择基于state渲染节点的组件的共同祖先组件维护这个state。</li>
			<li><strong>添加反向数据流</strong>，在上面的步骤后，数据流已经基于<code>props</code>和<code>state</code>沿组件树从上到下单项渲染。层级较深的组件需要更新state时，需要祖先组件传递一个回调函数，在特定事件时触发。</li>
		</ul>
		<h3 id="react_data">数据呈现</h3>
		<p>用户界面做的最多的就是数据的呈现。React让呈现更简单，且数据变化时，用户界面自动更新。例子见<span class="i">reactjs-demo</span>的<span class="i">hello-react</span>。</p>
		<p>React并不会去操作真实DOM（除非必要），它用一个快速的内置虚拟DOM元素呈现改变来达到高效率。组件的数据输入称为<code>props</code>，通过JSX语法传递，且只读。React组件就像是函数，接受<code>props</code>和<code>state</code>做参数，渲染单个HTML节点。</p>
		<p>MVC模型中通常将模板显示和数据逻辑分离开，React开发者认为这样会产生过多代码。因此，React的解决方案是通过Javascript直接生成模板，允许在js中使用HTML语法，这种js和HTML混用的语法被称为JSX。JSX和HTML很像，在babel的帮助下，可以在多种环境下使用JSX。</p>
		<p><strong>React不强制使用JSX，完全可以使用React API（<code>React.createElement</code>）和原生Javascript创建React元素</strong>。方便起见，可以通过工厂方法<code>React.createFactory()</code>创建自定义组件。React已经为HTML标签设置了内置工厂方法。</p>
		<h4 id="jsx">JSX</h4>
		<p>JSX很像XML的Javascript的语法拓展，通过React可以做JSX的简单转换。虽然不强制，但是React建议使用JSX语法。XML标签的语法可以使组件关系更加清晰，比方法调用和字面量的形式可读性更好。</p>
		<p>React可以渲染HTML标签(string)和React组件(classes)，其中前者需要在JSX中使用小写字母开头的标签名，后者需要创建一个大写字母开头的本地变量（使用时是也是大写字母开头的标签名）。这是React约定俗称的。需要注意的是，<strong>JSX中的一些标识符如<code>class</code>和<code>for</code>替代为<code>className</code>和<code>htmlfor</code></strong>（它们是js的保留字）。</p>
		<p>React会将类XML语法的JSX转成纯粹的Javascript，XML元素，属性和子节点会被转换成<code>React.createElement</code>的参数。JSX同样允许类似XML的方式定义子节点。示例如下：</p>
		<pre><code>var Nav, Profile;
// React Input (JSX):
var app = &lt;Nav color="blue">&lt;Profile>click&lt;/Profile>&lt;/Nav>;
// React Output (JS):
var app = React.createElement(
    Nav,
    {color:"blue"},
    React.createElement(Profile, null, "click")
);		</code></pre>
		<p>上面代码中，Input和output的语句是等效的。JSX还将从变量名中设定组件的<code>displayName</code>，若使用<code>React.createClass</code>时没有指定<code>displayName</code>的属性。</p>
		<p>V0.11.0后，React支持命名空间组件，当构建一个有许多子节点的组件时，可以通过设置父组件的命名空间避免过多的变量定义。在定义时，使用类似于<code>FatherComponent.son = xxx</code>的形式定义。</p>
		<p>Javascript表达式在JSX中使用一对大括号{}包裹，不使用引号。组件中的提及的属性默认为<code>true</code>，未提及的属性默认为<code>false</code>。子组件也可以作为表达式使用。</p>
		<h4 id="jsx_html">JSX属性扩散与HTML</h4>
		<p>若事先知道组建的全部属性（<code>props</code>），JSX可以很轻松地定义组件。同时，如果不知道应该设置哪些props，最好不要设置它。JSX的新特性属性扩散支持通过<code>{…props}</code>的形式将属性传递进组件内。它可以多次使用，且可以和其他属性一起使用，后面的属性会覆盖前面的。语法类似下面：</p>
		<pre><code>var props = {};
props.foo = x;
props.bar = y;
var component = &lt;Component {...props} />;
</code></pre>
		<p><code>...</code>操作符实际上也是<a href="#es2015">ES6新规范</a>中的新特性。</p>
		<p>JSX中可以插入HTML实体，但JSX会对所有字符串做二次转义，避免XSS攻击。最简单的方法是直接使用Unicode字符，或者通过<code>\u00xx</code>的形式插入Unicode字符，万不得已，可以在div的<code>dangerouslySetInnerHTML</code>的属性里直接指定原始HTML。</p>
		<p>可以为原生HTML元素指定自定义属性，但需要在属性前加上<code>data-</code>的前缀，否则React不会渲染它们。然而自定义元素支持任意属性表示网络可达性的<code>aria</code>属性会被正确渲染。</p>
		<h3 id="react_interact">添加交互</h3>
		<p>React用<code>state</code>记录因用户交互改变的组件状态。把事件处理器以驼峰命名形式当作组件props传入即可，就像使用普通HTML一样。在背后，React把事件回调隐式绑定在它的组件实例上，减少了用户的代码量。实际上，React也并没有把事件处理器绑定在节点上，而是用一个最外层的唯一事件监听器处理和分发事件，分发时根据组件在内部映射的事件处理器做处理。</p>
		<p>如之前提到的，可以把用户界面的组件想象成状态机，React只需更新组件的<code>state</code>，然后根据<code>state</code>重新渲染界面，无需操作DOM。常用的通知React数据变化的方法是调用<code>setState(data, callback)</code>合并<code>data</code>到<code>this.state</code>中，触发重新渲染。</p>
		<p>实际上，大多数的组件完成的工作只是从<code>props</code>里读取数据并渲染，但是在需要响应用户操作、服务器请求或时间推移时，<code>state</code>是需要的。<strong>React建议将尽量多的组件无状态化</strong>，这样可以减少冗余，更好描述组件业务逻辑。因此，<strong>通常的模式是创建多个只负责渲染数据的无状态(stateless)组件，并在它们上层创建一个有状态(stateful)组件，这个组件封装了所有的用户交互逻辑，而它的无状态子组件负责声明式渲染数据</strong>。</p>
		<p>承接上文，由于React会根据<code>state</code>自动渲染，因此尽量只把组件的状态原子化，会避免经常性的手动保持数据同步。计算所得数据、React组件、基于props的重复数据不建议包括在state中。总结下来就是，<strong>state内储存的数据相互独立且和props的数据相互独立</strong>。</p>
		<h3 id="react_component">组合组件</h3>
		<p>上面的介绍都局限在但各组件内，React里能通过开发简单组件将程序的不同关注点分离，获得类似于使用函数和类的好处。官网提供的Avatar组件例子清晰易懂：</p>
		<pre><code>var Avatar = React.createClass({
  render: function() {
    return (
      &lt;div>
        &lt;ProfilePic username={this.props.username} />
        &lt;ProfileLink username={this.props.username} />
      &lt;/div>
    );
  }
});

var ProfilePic = React.createClass({
  render: function() {
    return (
      &lt;img src={'http://graph.facebook.com/' + this.props.username + '/picture'} />
    );
  }
});

var ProfileLink = React.createClass({
  render: function() {
    return (
      &lt;a href={'http://www.facebook.com/' + this.props.username}>
        {this.props.username}
      &lt;/a>
    );
  }
});

React.render(
  &lt;Avatar username="pwh" />,
  document.getElementById('example')
);		</code></pre>
		<p>从上面的例子看到，组件的拥有者为组件设置<code>props</code>，反之亦然。同样的道理，组件无法修改自己的<code>props</code>。React中，<strong>从属关系</strong>和<strong>父子关系</strong>是两个不同的概念。上一个例子中，<code>Avatar</code>是<code>div</code>、<code>ProfilePic</code>和<code>ProfileLink</code>的拥有者，<code>div</code>是<code>ProfilePic</code>和<code>ProfileLink</code>实例的父级。</p>
		<p>在React组件实例化时，可以在闭合标签内引用其他组件或javascript表达式。通过<strong><code>this.props.children</code></strong>这个<code>props</code>读取子级。每次render后，React会根据子级的渲染顺序校正子级。当状态化组件需要删除组件时，通常采用设置<code>display: none</code>来解决。React里，数据通过上面介绍的<code>props</code>从拥有着流向从属者，这就是React中的<strong>单向数据绑定</strong>。拥有者可以通过<code>props</code>和<code>state</code>计算出一些值，然后将结果绑定在从属组件的<code>props</code>上。结合ES7的实验特性，使用<code>var {x, y, …other}=this.props</code>（解构赋值）定义组件<code>props</code>，把未知属性批量提取出来，避免传递不必要的<code>props</code>给子组件。</p>
		<p>随着应用不断拓展，确保组件正确使用很重要。<strong><code>React.propTypes</code></strong>提供了很多验证其来验证传入数据的有效性，如<code>React.PropTypes.element</code>可以限定只能传入一个子级。当<code>props</code>接收到无效数据时，Javascript控制器会抛出警告。出于性能考虑，通常只在开发环境验证<code>propType</code>。官网教程给出了<code>propType</code>的各种用法，在使用时，<code>propTypes</code>需要写在组件的属性里。<code>getDefaultProps</code>属性支持用声明式的方式定义<code>props</code>的默认值。保证父级未传入<code>props</code>时，<code>this.props.value</code>有默认值。利用JSX的属性扩散语法，可以轻松传递<code>props</code>，就像下面这样：</p>
		<pre><code>var CheckLink = React.createClass({
    render: function() {
        return &lt;a {...this.props}>{'√ '}{this.props.children}</a>;
    }
});

React.render(
    &lt;CheckLink href="/checked.html">
        Click here!
    &lt;/CheckLink>,
    document.getElementById('example')
);		</code></pre>
		<p>组件间有时也需要共用一些功能，React使用mixins解决这类问题。在mixins定义好之后，通过指定组件的<code>mixins</code>属性，并用<code>[]</code>包裹引用mixin。另外，利用ES6的js新特性class定义，可以使用<code>class HelloMessage extends React.Component</code>定义组件。</p>
		<h3 id="react_form">表单组件</h3>
		<p>React的表单组件支持几个受交互影响的属性: <code>value, checked</code>和<code>selected</code>。组件可以通过<code>onChange</code>回调函数监听组建变化。设置了<code>value</code>的<code>&lt;input></code>是一个受限组件，渲染出来的HTML始终保持<code>value</code>属性的值。没有设置<code>value</code>的<code>&lt;input></code>组件是一个不受限的组件，渲染的元素直接反应用户输入，可以通过<code>defaultValu</code>e设置初始值。同样地，radio，checkbox的<code>&lt;input></code>支持<code>defaultChecked</code>属性，<code>&lt;select></code>支持<code>defaultValue</code>属性。</p>
		<p>设置受限组件和不受限组件是因为React的组件实际上反映了视图在任何时间点的状态。所以既然明确写出value=xxx，那么输入框的值在任何时间点被渲染都应该不变。另外，<code>textarea</code>和<code>select</code>标签也使用<code>value</code>和<code>defaultValue</code>方便进行组件控制。</p>
		<h3 id="react_component_life">组件说明与生命周期</h3>
		<p>组件通过<code>React.createClass</code>创建（ES6新特性下，继承<code>component</code>类亦可）。</p>
		<ul>
			<li><code>render</code>方法是必须的，它应该是纯粹的，不修改组件<code>state</code>，不涉及交互，每次调用返回相同信息。</li>
			<li><code>getInitialState</code>方法在组件挂载前调用，设置<code>this.state</code>的初值。</li>
			<li><code>getDefaultProps</code>在组件创建时调用一次，返回值被缓存下来，用于父组件遗漏props，这个方法不能依赖<code>this.props</code></li>
			<li><code>propType</code>对象允许验证传入组件的<code>props</code></li>
			<li><code>mixins</code>对象允许使用mixin来在组件间共享行为。</li>
			<li><code>statics</code>对象允许定义静态方法在组件类上调用</li>
			<li><code>displayName</code>字符串输出调试信息</li>
		</ul>
		<p>组件的生命周期分为三个阶段：挂载、更新、移除。React提供生命周期方法，其中<strong><code>will</code>方法</strong>在某些行为发生前调用，<strong><code>did</code>方法</strong>在某些行为发生后调用。</p>
		<p><strong>挂载</strong>：组件被插入到DOM中。<code>getInitialState()</code>方法在组件挂载前调用。状态化组件需要实现这个方法，返回初始的state数据。<code>componentWillMount()</code>在前，<code>componentDidMound</code>在后。</p>
		<p><strong>更新</strong>：组件被重新渲染，查明DOM是否应该刷新。</p>
		<ul>
			<li><code>componentWillReceive(obj nextProps)</code>当一个挂在组件接收到新的<code>props</code>时候被调用。该方法应该用于比较<code>this.props</code>和<code>nextProps</code>的不同来判断是否使用<code>this.setState()</code>来改变<code>state</code>。</li>
			<li><code>shouldComponentUpdate(o- bj nextProps, obj nextState): boolean</code>当组件作出是否要更新DOM决定时被调用，实现该函数优化<code>this.props</code>和<code>nexProps</code>以及<code>this.state</code>和<code>nextState</code>的比较，如果不需要更新，返回<code>false</code>。</li>
		</ul>
		<p><code>componentWillUpdate()</code>和<code>componentDidUpdate()</code>分别在更新发生前后调用。</p>
		<p><strong>移除</strong>：组件从DOM中移除。<code>componentWillUnmount()</code>在组件移除和销毁前被调用。</p>
		<h3 id="refs">Refs</h3>
		<p><strong>React从不直接操作DOM</strong>，它在内存中维护一个DOM描述，并通过描述快速计算差异然后更新浏览器中的DOM。另外，React实现了完备的虚拟事件系统，确保所有事件对象符合W3C标准。但是，React也提供了直接使用底层DOM API的途径。</p>
		<p>通过<code>React.findDOMNode</code>函数可以通过DOM节点获取挂载在之上的React组件。通过<code>his.refs.xxx</code>指向一个声明了<code>ref</code>属性的组件。</p>
		<p>另外，render方法返回UI结构时，有时会出现超出虚拟DOM限制的需求，在render返回的组件实例上调用某些方法。通常，这对于应用中的数据流是不必要的。因为这些数据流总是确保最新的props被传递到每一个从<code>render()</code>输出的子级上。React提供<code>refs</code>属性来满足一些特殊情况，如操作DOM表现形式，在非React环境下使用React等。</p>
		<p>ReactDOM库提供了<code>render()</code>方法（不要和组件类的render方法搞混），在绑定组件类的同时返回元素的支撑实例。一般在最外层使用。</p>
		<p>React支持非常特殊的<code>ref</code>属性，可以绑定到render()输出的任何组件上。这个属性允许引用render()返回的响应支撑实例。使用时通过<code>this.refs.xxx</code>来获取支撑实例。在最新的React版本中这种方式已经不推荐，而推荐使用下面的ref回调属性。</p>
		<p>React支持在组件上绑定ref回调函数属性，这个回调会在组件被挂载后立即执行。被引用的节点将被传入作为输入参数，回调函数可以立即使用这个节点或者将之保存下来<code>(this.xxx = input)</code>为以后使用做准备。ref使用在DOM组件上时，会返回DOM节点，使用在React组件上时会返回组建对象实例。</p>
		<p>React建议在通常情况下，使用props和state向子组件发送消息，在场景不那么reactive时，使用<code>refs</code>。Ref的优点在于1）可以通过它调用组件类中的公共方法； 2）方便可靠地管理DOM； 3）Ref被自动管理，会和实例同生共死，不用考虑内存问题。在使用时，要注意以下问题：1）不要在render()方法中访问refs； 2）尽量通过在父级使用state避免refs的过度使用。</p>
		<h3 id="react_api">API</h3>
		<p>React JSX语法所提供的完全可以由React的API调用所替代。下面是react一些API的reference（主要摘自官方文档）</p>
		<h4 id="react_reactapi">React</h4>
		<p><span class="i">React</span>是React库的入口。使用预编译包时，React是全局的；如果使用CommonJS的模块规范，则通过<code>require</code>引入。</p>
		<p><span class="i">Component</span>是定义React组件的基本类，通过ES6的新特性，可以通过<code>extends</code>定义自己的组件类。</p>
		<ul>
			<li><code>React.createClass(specification)</code>方法创建一个组件类，并给出定义。定义中必须给出render方法。组件定义和声明周期参见别节。</li>
			<li><code>React.createElement(type, [props], [children ...])</code>创建一个指定类型的ReactElement，<code>type</code>可以为DOM原型或ReactClass。</li>
			<li><code>React.createFactory(type)</code>返回一个可以生成指定类型ReactElement的函数。</li>
			<li><code>React.cloneElement(element, [props], [children ...])</code>克隆一个已有的元素，并融合进新的<code>props</code>，是新增特性</li>
		</ul>
		<p>除此之外，还有<code>isValidElement</code>判断是否是合法元素，DOM方法更方便地创建DOM元素，<code>PropTypes</code>方法方便表单检验。React的<code>Children</code>对象提供了对<code>props.children</code>数据结构处理的工具，有<code>map</code>和<code>forEach</code>（与array的同名方法类似），以及<code>count</code>计算总数、<code>only</code>返回children仅有的子级元素和<code>toArray</code>方法将children数据专转为数组结构。</p>
		<h4 id="reactdomapi">ReactDOM</h4>
		<p>ReactDOM包使用在React应用的最外层，用于进行网页原生DOM操作（虽然官方不推荐），其中render方法时最为常用的。<code>ReactDOM.render(element, DOM container, [function callback]) </code>React用于将组件绑定在DOM上，若已被绑定，则会更新。在绑定时，会将DOM原内容清除。React预计会在未来支持将多个组件类绑定在同一个DOM内。</p>
		<p><code>unmountComponentAtNode(DOM container)</code>方法和<code>findDOMNode(React component)</code>方法分别用于移除DOM上的组件和找到组件所对应的DOM。其中后者是ref的替代用法（官方不推荐），且不能在无状态组件内使用。</p>
		<h4 id="reactdomserverapi">ReactDOMServer</h4>
		<p><code>renderToString</code>和<code>renderToStaticMarkup</code>方法用于将React元素渲染成HTML内容。其中后者不会添加额外的DOM属性。另外，两个方法都只能在服务器环境下运行。</p>
		<h4 id="reactcomponentapi">Component</h4>
		<p>Component实例在渲染时创建，并在之后的渲染中重复使用。可以在组件方法中用<code>this</code>访问。唯一一种外部访问的方法是储存<code>ReactDOM.render</code>的返回值，在其他组件里还能通过refs来实现同一效果。</p>
		<ul>
			<li><code>setState(function/obj nextState, [function cb])</code>方法<strong>合并</strong>nextState和当前state，支持回调函数。<strong><i>绝不要</i></strong>直接改变<code>this.state</code>。另外，除非在<code>shouldComponentUpdate()</code>中实现条件渲染逻辑，否则，该方法触发一次重绘。</li>
			<li><code>replaceState</code>方法和<code>setState</code>方法类似，区别在于该方法会先<strong>删除</strong>现有<code>state</code>。</li>
			<li><code>forceUpdate([function cb])</code>用在<code>this.props</code>和<code>this.state</code>未改变而仍需要重绘时调用，在手动修改<code>this.stat</code>e时也是如此。在该方法触发重绘时，子组件也会重绘（官方不推荐使用该方法= =）。</li>
			<li><code>bool isMounted()</code>方法判断组件是否已被绑定在DOM中，该方法多用在异步场景下。</li>
		</ul>
		<p><code>setProps</code>和<code>replaceProps</code>方法在新版本中已被删去。</p>
		<h3 id="react_others">标签/属性/事件</h3>
		<p>React支持几乎所有的html和svg标签，同时也支持所有标准属性。React中的属性都用驼峰命名，<code>class</code>和<code>for</code>属性改为<code>className</code>和<code>htmlFor</code>。React还添加了特殊的非DOM属性：</p>
		<ul>
			<li><code>key</code>作为唯一标识器，用于在渲染和差异检测时将顺序打乱后，确保组件还存在。</li>
			<li><code>ref</code>，介绍略。</li>
			<li><code>dangerouslySetInnerHTML</code>提供插入纯HTML字符串功能</li>
		</ul>
		<p>React对浏览器本地事件也有封装，且保证了浏览器兼容性。需要时，通过<code>nativeEvent</code>属性获得底层浏览器事件。通过<code>e.preventDefault()</code>可以避免事件冒泡。React的事件处理器在事件冒泡阶段出发，通过在事件后添加<code>Capture</code>（如<code>onClickCapture</code>）可以在捕获阶段处理事件。包括剪贴板、键盘、鼠标、焦点、表单、选择、触摸、UI、鼠标滚轮、多媒体、图片、动画、渐变事件（html5标准后添加了许多）。具体参加<a href="https://facebook.github.io/react/docs/events.html" target="_blank">官方文档介绍</a>。</p>
		<h3 id="flux">Flux/Redux</h3>
		<p>React为开发者提供了状态化组件的前端开发方式，这仅仅完成了MVC的V部分。Flux是Facebook提出了用于M和C部分的解决方案（实际上并不能称为M和C）。Flux是一种架构约定和架构模式。根据<a href="http://facebook.github.io/flux/docs/overview.html" target="_blank">文章</a>介绍一个Flux应用主要包含四部分：dispatcher，stores，views，actions。数据流在它们之间单向流动。如下图所示：</p>
		<img src="./img/flux.png" />
		<ul>
			<li>首先定义一些action creator方法。根据需要提供给dispatcher来分发。</li>
			<li>View部分通过交互触发Action。</li>
			<li>Dispatcher会分发出发的Action给所有注册的Store的回调函数</li>
			<li>Store回调函数根据Action的payload的部分更新自身数据，并触发一个change事件</li>
			<li>View会监听该事件，通过Store的方法拿到新数据，调用<code>setState</code>更新组件UI</li>
		</ul>
		<p>数据流在整个过程都是单向移动的，通过dispatcher来组织，由Store来维护所有状态。各部分分工明确。Dispatcher分发动作给Store注册的回调函数，官方提供了<a href="https://github.com/facebook/flux/blob/master/src/Dispatcher.js" target="_blank">Dispatcher.js</a>这个demo，与<a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc/js" target="_blank">flux-todomvc</a>作为使用样例。在样例中可以学到flux的简单使用。</p>
		<p>Redux提出于2015年，充分利用函数式编程的特点，简化了flux的的用法。将flux中的action和dispatcher进一步解耦，且将dispatcher从store中解耦， store成为了stateless function（state,action）=> state。现在的store只<strong>管理</strong>状态，从而增强了其可拓展性。</p>
		<p>在Redux中，action只是包含type和payload的对象，需要通过<code>store.dispatch()</code>方法来发送，action creator可以返回一个事件。Reducer用来处理action触发的对state的修改，形式类似于(oldState, action)=>newState。Redux将store视为唯一可信数据源，整个状态由一个store储存，由一个<strong>root reducer</strong>管理，在root reducer下，可以定义pure function管理状态树的各子树。</p>
		<p>Redux的Store提供<code>getState</code>方法获取state，提供<code>dispatch</code>方法发送action修改state，提供<code>subscribe()</code>方法注册回调函数监听state的修改。总结起来，<code>store.dispatch(action)</code>触发事件，action的type和payload说明事件情况；action触发指定root reducer，根据type和payload返回一个新的state；所有通过subsribe注册的监听函数会被调用，它们可以通过<code>getState</code>拿到新的state。</p>
		<h3 id="react_more">更多</h3>
		<p>React仍然没有一个系统且用户友好的学习教程（循序渐进且有demo）。个人认为效率较高的学习方式是先由<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank">阮一峰的博客</a>获得感性认识，再通过<a href="https://facebook.github.io/react/docs/getting-started.html" target="_blank">官方文档</a>和<a href="http://reactjs.cn/react/docs/getting-started.html" target="_blank">中文文档</a>的讲解获得全面认识。文档中也有demo展示。另外，<a href="http://react-china.org/" target="_blank">React中文社区</a>里会有一些不错的资源和讨论，<a href="https://www.gitbook.com/book/hulufei/react-tutorial/details">React入门教程</a>也有些补充，如Flux和Redux的介绍。</p>
		<p>另外，React一直处在发展中，直到现在也未推出1.0版，且框架特点和使用方法和typical MVC框架差别较大，学习成本较高。在学习文档的同时根据"Tutorial"的介绍训练，效果会更好。</p>
		<hr>
		<h1 id="angular">Angular JS</h1>
		<h3 id="angular_brief">简介与安装</h3>
		<p>Angular是比较新的技术，1.0版本发布于2012年。它采用MVVM架构，和MVC架构的React不同，View和ViewModel有着数据的双向绑定。Angular现由Google正式支持。</p>
		<p>Angular和React类似着眼点在前端的内容展示，不同于React尝试将UI界面组件化，Angular试图拓展HTML的功能来弥补与实际Web应用间的鸿沟。如：</p>
		<ul>
			<li>通过<code>{{}}</code>绑定数据</li>
			<li>使用DOM控制结构迭代或隐藏DOM片段</li>
			<li>将逻辑代码关联到DOM元素上</li>
			<li>将HTML做成可重用组件</li>
		</ul>
		<p>Angular具有很好的抽象性简化了应用的开发，且在CRUD应用中灵活性也很好，在DOM操作频繁且复杂的应用里，Angular并不适合。如游戏或是图形编辑器。这时使用React或者jQuery会好些。</p>
		<p>Angularjs可以使用npm或者bower进行安装，<code>bower/npm install angular</code>。之后便可以在<span class="i">node_modules</span>或<span class="i">bower_components</span>中找到。在<code>script</code>标签中引入即可。</p>
		<h3 id="angular_usage">使用</h3>
		<h4 id="angular_app">应用/控制器</h4>
		<p>Angular在后台通过定义AngularJS module确定应用；在前端通过<code>ng-app</code>指定Angular应用所绑定的位置（通常是html标签）。应用的所有controller也由模块包含。后台应用通过<code>angular.module(name, [])</code>构造，前者确定应用名，后者确定依赖模块。</p>
		<p>Angular支持创建自己的指令，使用<code>app.directive(name, function(){})</code>即可。自定义的指令可以通过元素名、属性、类名甚至注释来调用。在function部分的return中设置<code>restrict</code>为E A C M分别限制指令只能通过元素名、属性、类名、注释使用，可以叠用，默认为EA。</p>
		<p>应用可以有多个控制器处理不同功能，后台通过<code>app.controller(name, function(){})</code>定义，前端通过指定<code>ng-controller</code>绑定。Angular控制器是对象类型，有属性和方法，都可以通过<code>$scope</code>访问，其他方法可以通过<code>ng-click</code>等命令绑定在前端标签。应用和控制器的后台js文件可以外部通过<code>script</code>标签导入，建议放在body后。</p>
		<h4 id="angular_expression">Angular表达式</h3>
		<p>Angular的表达式写在双大括号内，把数据绑定在HTML内，和<code><strong>ng-bind</strong></code>有一样的效果，Angular表达式和js表达式很像，可以包含数组，对象，字符串、数字、运算等等，但是不支持条件判断和过程控制，且支持过滤器。</p>
		<h4 id="angular_model">数据模型</h4>
		<p>在controller中，可以为<code>$scope</code>变量赋值，从而定义应用的数据模型。在前端可以用<code>ng-bind</code>或<code>{{}}</code>使用已定义好的数据模型，或通过<code>ng-model</code>在前端输入域绑定数据。由于Angular采用数据双向板顶，修改输入域的值时，AngularJS的属性值也将<strong>同步</strong>更改。</p>
		<p>指定标签<code>ng-show</code>属性，可以在后台结果返回为<code>true</code>时显示标签。<code>ng-model</code>还可以为应用数据提供状态值，通过<code>$invalid, $dirty, $touched, $error</code>访问。</p>
		<p>同时在CSS类中，指定<code>ng-invald, ng-empty, ng-not-empty, ng-touched, ng-un-touched, ng-valid, ng-dirty, ng-pending, ng-pristine</code>类，可以让样式跟着模型状态改变。</p>
		<h4 id="angular_filter">过滤器</h4>
		<p>过滤器可以被添加在Angular语句中，用来格式化数据。有如下的一些可以选择：</p>
		<ul>
			<li><code>currency</code>格式化为指定货币；<code>date</code>格式化为指定日期；<code>number</code>格式化数字为字符串</li>
			<li><code>json</code>格式化为json字符串</li>
			<li><code>filter</code>筛选数组的子集</li>
			<li><code>limitTo</code>限制数组或字符串指定数目的长度</li>
			<li><code>lowercase/uppercase</code>格式化为大写或小写</li>
			<li><code>orderBy</code>使数组按序排列</li>
		</ul>
		<p>在使用时，通过一个管道字符<code> | </code>和一个过滤器添加到表达式中，如<code>{{price | currency}}</code>或<code>{{x in names | filter: ’Bill’ | orderBy:’name’}}</code>。filte支持自定义，在后台通过<code>app.filter(name, function(){return function(){}})</code>定义即可。</p>
		<h4 id="angular_service">服务</h4>
		<p>AngularJS中，服务是一个函数或对象，以<code>$</code>开头，可以在应用中使用（<strong>注意服务需要作为一个参数传递到controller中，需要先传入后使用</strong>），用来构造一些常用或是复杂的操作。AngularJS内建有30多个服务。</p>
		<p><code>$location</code>服务返回当前页面的地址信息等，有<code>absURL()</code>等方法使用。<code>$index</code>记录着<code>ng-repeat</code>的序号。<code>$timeout</code>有类似于<code>setTimeout</code>的作用；同理<code>$interval</code>对应着<code>setInterval</code>函数。</p>
		<p><code>$http</code>是Angular应用最常用的服务，用于向特定位置发送请求，并通过<code>then(function(){})</code>获取返回。发送的方法有get/delete/head/jsonp/patch/post/put等。也可以直接通过类似如下的方式发起请求：</p>
		<pre><code>var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $http) {
    $http({
        method : "GET",
        url : "welcome.htm"
    }).then(function mySucces(response) {
        $scope.myWelcome = response.data;
    }, function myError(response) {
        $scope.myWelcome = response.statusText;
    });
});		</code></pre>
		<p>返回值<code>response</code>有<code>config, data, header, status, statusText</code>等属性可以使用，可以在<code>then</code>方法的第二个参数指定错误处理函数。</p>
		<p>另外，可以通过<code>app.service(name,function(){})</code>自定义服务对象，然后在控制器中使用。常用服务一节还列举了一些其他服务。</p>
		<h4 id="angular_sql">Sql</h4>
		<p>由于Angular是一个前端的框架，需要后台如PHP，ASP等的辅助才可完成和数据库的交互，解决跨域问题的方法从略。</p>
		<h4 id="angular_dom">DOM事件</h4>
		<p><code>ng-disabled</code>和<code>ng-show</code>、<code>ng-hide</code>结合<code>ng-model</code>可以实现disabled和show/hide的效果。Angular还提供了许多DOM事件监听器。有<code>ng-blur, change, click, copy, cut, dbclick, focus, keydown, keypress, keyup, mousedown, mouseenter, mouseleave, mouseover, mouseup, paste</code>等。指定标签的这些属性即可为DOM事件绑定处理函数。Angular事件并不会重写HTML事件。</p>
		<h4 id="angular_form">表单验证</h4>
		<p>Angular的数据双向绑定使得表单验证更加简洁，结合HTML5的新特性。<code>required</code>属性要求不能为空，type限制输入的数据类型。在输入域改变的同时，<code>$untouched</code>, <code>$touched</code>, $<code>pristine</code>（未被修改过）<code>$dirty</code>（已被修改过）<code>$invalid</code> <code>$valid</code>等状态也随之改变。表格则有<code>$pristine $dirty $invalid $valid $submitted</code>等状态。使用样例如下</p>
		<pre><code>&lt;input name="myName" ng-model="myName" required>
&lt;span ng-show="myForm.myName.$touched && myForm.myName.$invalid">The name is required.&lt;/span>
</code></pre>
		<p>另外，在数据模型中一节已提到，Angular会新增CSS类在标签上，便于设置CSS样式。结合HTML5新属性，会有很不错的效果。在特殊情况，可以通过<code>app.directive</code>定义新的验证方法，添加在控制器的$parsers中，当输入域的值改变时做检验。具体添加方式可参见文档。</p>
		<h4 id="angular_router">路由</h4>
		<p>AngularJS通常用来构造单页网络应用。因此，URL采用<code>/#/name</code>的形式。在后台指定应用的依赖模块<code>ngRoute</code>，并通过<code>app.confi</code>配置<code>routeProvider</code>服务，使用依赖注入引入<code>routeProvider</code>服务，通过<code>when(path, object).otherwise(object)</code>按顺序定义所有路由。其中<code>when</code>的第二个输入参数是路由配置对象，有如下的参数可以配置：</p>
		<ul>
			<li><code>template</code>: 直接在<code>ng-view</code>中插入简单的HTML内容</li>
			<li><code>templateUrl</code>: 在<code>ng-view</code>中插入HTML模板文件</li>
			<li><code>controller</code>: 在当前模板执行的controller函数，生成新的<code>scope</code></li>
			<li><code>controllerAs</code>: 为controller指定别名</li>
			<li><code>redireTo</code>: 重定向地址</li>
			<li><code>resolve</code>: 指定当前controller所依赖的其他模块</li>
		</ul>
		<h4 id="angular_api">通用API函数</h4>
		<p><code>angular.copy</code>复制变量；<code>angular.element</code>；方法可以将元素包装为jquery对象；<code>equals</code>判断两个变量是否相等；<code>fromJson</code>反序列化一个JSON字符串；<code>isArray, Date, Defined, Element,  Function, Number, Object, String, Undefined</code>分别判断数据类型。<code>merge</code>方法合并两个变量；<code>noop</code>执行一个空函数。</p>
		<h3 id="dependency_injection">依赖注入</h3>
		<p>依赖注入是一种软件设计模式，用来为代码的依赖关系解耦。如杂项里介绍的，在需要其他依赖通过依赖的对象创建并传入。在Angular JS中引入服务，实际上就是依赖注入的一种语法糖。以输入参数的形式注入了控制器的依赖关系。这一点可以通过控制器的<code>$inject</code>来访问到。</p>
		<p>为了更好地理解，我们通过下面的代码创建一个注入器inject，来向函数中注入依赖：</p>
		<pre><code>var inject = {
    dependencies: {},
    register: function(key, value) {
        this.dependencies[key] = value;
    },
    resolve: function(deps, func, scope) {
        var arr = [];
        for (var i = 0 ; i < deps.length ; i++) {
            if (this.dependencies.hasOwnProperty(deps[i])) {
               arr.push(this.dependencies[deps[i]])
            }
        }
        console.log(arr);
        return function(){
            func.apply(scope || {}, arr);
        }

    }
}		</code></pre>
		<p>其中<code>dependencies</code>属性存储所有依赖，<code>register</code>方法注册依赖，<code>resolve</code>方法实现依赖注入，在之后可以模仿Angular用register注册几个模块，Angular的依赖注入服务<code>$inject</code>就是采取类似的思路完成依赖注入，先对函数使用<code>toString()</code>方法，之后通过正则匹配获得函数的输入参数，再加入依赖。</p>
		<h3 id="angular_extend_command">基础拓展指令</h3>
		<p>Angularjs通过<code>ng-directives</code>拓展了HTML。下面介绍了一些常用的directives。</p>
		<p><code><strong>ng-app</strong></code><strong>：定义一个AngularJS</strong>应用程序，一般绑定在html标签下。当然也可以在个别标签下绑定。范例：<code>&lt;html ng-app> &lt;div ng-app></code>。</p>
		<p><code><strong>ng-controller</strong></code>：指定特定<strong>控制器控制一个AngularJS应用程序</strong>，位于ng-app下，一般为应用下的自功能。范例：<code>&lt;body ng-controller=”MainCtrl”></code>。控制器端，<code>app.controller ('MainCtrl', function($scope){…})</code>。</p>
		<p><code><strong>ng-init</strong></code>： 在视图中<strong>初始化变量</strong>，范例：<code>&lt;div ng-init="book=[…]"></code>；可以同时初始化多个变量，引号内用分号隔开即可。通常使用时，在控制器内完成，不推荐使用<code>ng-init</code>初始化。</p>
		<p><code><strong>ng-bind</strong></code>：把<strong>变量绑定到视图</strong>中。范例：<code>&lt;span ng-bind="book">&lt;/span></code>。</p>
		<p><code><strong>ng-model</strong></code>：<strong>定义模型数据</strong>，绑定输入域值到模型数据，Angular支持数据双向绑定，可以轻松实现数据实时更新。范例：<code>&lt;input type="search" ng-model="criterial"></code></p>
		<p><code><strong>ng-repeat</strong></code>：<strong>遍历集合中的元素</strong>，用来<strong>迭代DOM元素</strong>。范例：<code>&lt;li ng-repeat="book in books"> {{book.name}}&lt;/li></code>. 使用过滤器可以实现过滤文本，改变格式，甚至实现搜索功能，<code>filter:criteria | orderBy</code>。利用<code>ng-repeat</code>结合<code>tr</code>和<code>td</code>可以方便地绘制表格。</p>
		<p><code><strong>ng-include</strong></code>：<strong>引入本地或跨域html文件</strong>，实现组件化的效果。</p>
		<p>还有一些<code>ng-directives</code>会根据条件真假决定是否是否展示，如<code>ng-show, ng-if, ng-invalid</code>等。其中<code>ng-show</code>和<code>ng-if</code>后有<code>$odd</code>和<code>$even</code>辅助条件判断(<code>ng-repeat</code>中)。</p>
		<p>还有<code>ng-click ng-href ng-show ng-hide</code>等。更多请参考文档。</p>
		<h3 id="angular_services">常用服务</h3>
		<p><code><strong>$scope</strong></code>：是带有属性和方法的对象，是控制器后台和前端模型数据的粘合剂。可以通过它定义数据，绑定元素等。在定义控制器时，可以作为输入参数传入，使得视图可以获取控制器属性。在大型项目中，<code>$scope</code>(作用域)往往不止一个，在使用时要注意区别开。所有应用都有一个<code>$rootScope</code>，可以在同一<code>ng-app</code>下的所有控制器中使用，是各个scope间的桥梁。</p>
		<p><code><strong>$watch</strong></code>：每次绑定一些东西(如<code>ng-model</code>)到UI时，就会向<code>$watch</code>队列插入一条<code>$watch</code>，它可以检测model里有变化的东西。需要注意的是，通过<code>$scope</code>定义的模型在绑定前不会加入<code>$watch</code>，且对象内的属性和数组内的元素也会作为一个个体添加如<code>$watch</code>队列中。<code>$watch</code>可以手动绑定。<code>$scope.$watch(”xxx”, function(oldvalue,newvalue){},true/false)</code></p>
		<p><code><strong>$digest</strong></code>：Angular拓展了浏览器等待用户交互的时间循环，生成一个称为Angular context的执行环境。在浏览器接收到可以进入Angular context的事件时，<code>$digest</code>将会遍历<code>$watch</code>，检查值的变化，至少一个<code>$watch</code>更新后，循环就会再次触发。$digest循环后，DOM相应发生变化。<strong>1</strong>个事件会触发<strong>1</strong>个<code>$digest</code>循环。</p>
		<p><code><strong>$apply</strong></code>：决定事件是否能进入Angular context。Angular会自动封装事件到一个<code>$apply</code>调用。因此jQuery没有调用<code>$apply</code>时，<code>$digest</code>循环不会执行。可以通过<code>scope.$apply()</code>强制一次<code>$digest</code>循环。</p>
		<p><code><strong>$q</strong></code>：提供了广义的异步回调机制，<code>$http</code>即在此基础上构建。<code>$q</code>有四种方法，<code>all([p1, p2])</code>方法合并多个<code>promise</code>为1个，<code>defer()</code>方法返回一个defer</code>对象，<code>reject(data)</code>触发后链的链式回调，用在<code>p.then().then()</code>的链式环境下。<code>when()</code>方法用来将数据包装成<code>promise</code>对象。<code>defer()</code>方法返回一个<code>defer</code>对象，<code>promise</code>属性是一个<code>promise</code>对象，<code>resolve</code>和<code>reject</code>方法分别触发成功和失败回调。</p>
		<p><code><strong>$log</strong></code>：向终端打印一些信息，<code>error(), info(), warn(), log()</code>方法分别打印不同级别的信息。</p>
		<p><code><strong>$cacheFactory</strong></code>：简单封装了一个缓存机制，调用时需要id和配置项如capacity。缓存实例有<code>info(), put(k, v), get(k), remove(k), removeAll(), destroy()</code>等方法。</p>
		<p><code><strong>$resource</strong></code>：Angular封装了一个更面向RESTful的模块代替<code>$http</code>使用，通过<code>$resource</code>的配置对象可以轻松实现CRUD操作。</p>
		<h3 id="angular2">Angular 2</h3>
		<p>Angular的开发团队在2015年7月推出Angular 2.0版本。对比1.x版本，Angular的2.0版本改动很大。2.0版本<strong>完全由Atscript书写</strong>，完全<strong>支持最新的ES6特性</strong>。AtScript改进自Typescript，后者由微软提出于2012年，简单来看是ES5+ES6+Type，在完全兼容Javascript的同时，提出了弱类型等更像传统编程语言的特性（又是一个新坑，日后再学）。目前（<span class="i">2016/7</span>）官网中并无Javascript版的2.0介绍。同时，一些诸如scope和controller的传统概念也被完全删除。<strong>组件化</strong>和<strong>面向对象</strong>成了2.0版本的最大特点。</p>
		<h4 id="componency">组件化</h4>
		<p>如上文所说，<code>controller</code>和<code>$scope</code>等概念被替代成组件和命令。控制器都由模板的方式定义为类的样式，如在下文的代码中，将组件（component）绑定到<code>&lt;angularComponent></code>标签上，所有使用组件都需经<code>bootstrap</code>挂载，且被页面导入（imported）：</p>
		<pre><code>//&lt;reference path="typeings.tsd.d.ts" />
import {Component, View, bootstrap} from 'angular2/angular2';
//Annotation section
@Component({
selector: 'angularComponent',
templateUrl: '/list.html’,
directives:  'importedComponent’
})
@View({
    templateUrl: 'component.html'
})
class angularComponent{
    constructor(){
        //code
    }
}
bootstrap(angularComponent);
</code></pre>
		<p><i>注意：上文应保存为.ts文件。</i></p>
		<p>Angular 2.0采用ES6自带的模块特性进行模块管理，并保证全局域安全。定义组件时（Angular 1.x中称为module）中通过<code>import from</code>的形式引入依赖，并通过Component注解完成控制器注册。而控制器本身是通过<code>export class xxxComponent{}</code>的形式定义的。在组件的构造函数中用输入参数的形式完成依赖注入。</p>
		<h4 id="angular2_extend_commonds">拓展命令</h4>
		<p>拓展命令的用法也做了较大改动。<code>ng-app</code>和<code>ng-controller</code>已经结合在模块的定义中。<code>ng-click</code>等事件删除前缀<code>ng-</code>，用<code> () </code>包裹，交由<code>component</code>方法处理。<code>ng-href</code>, ng-hide</code>等有HTML5标签对应的命令删去前缀<code>ng-</code>，用<code> [] </code>包裹。特别地，在路由中，a标签的路径已经不需要<code> # </code>。<code>ng-if</code>和<code>ng-for</code>等控制命令删去短划线采用驼峰命名，前方加星号<code> * </code>。<code>ng-model</code>双向绑定数据使用<code>[(ngModel)]</code>。</p>
		<p><code>{{}}</code>仍起着单向绑定的作用，过滤器使用管道<code>pipe</code>方法替代，<code>ngFor</code>中的变量用<code>let</code>声明。另外，过滤器中的<code>filter</code>和<code>orderBy</code>被删除，需要自行实现，<code>limitTo</code>改为<code>slice</code>。</p>
		<p>总体来说，Angular 2.0的出现也是顺应了时代的步伐，减少了繁冗的API，和对前端页面元素的过多装饰，改为更适合开发的模块化封装，通过修饰器约束组件的特性。同时保留了数据双向绑定等特点。无论如何，对于1.x的使用者来说，都要花上不少时间去适应全新的一切。更多的改变可以参考<a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html" target="_blank">官网的对比</a>。</p>
		<h3 id="angular_more">更多</h3>
		<p>Q 使用Angular JS和jQuery可以兼容吗？如何做到？</p>
		<p>A. Angular JS采用的MVVM的架构和jQuery的思路并不十分兼容，<a href="http://stackoverflow.com/questions/14994391/thinking-in-angularjs-if-i-have-a-jquery-background" target="_blank">建议使用前者，养成不用后者的习惯</a>。</p>
		<p>Angular JS 1.x版本有着较丰富的参考资料，官网有<a href="https://docs.angularjs.org/api/" target="_blank">API reference</a>和demo分析，<a href="http://www.w3schools.com/angular/" target="_blank">w3school的教程</a>也是不错的学习资料。另外还有<a href="http://www.cnblogs.com/whitewolf/category/404298.html" target="_blank">一些博客</a>和<a href="https://checkcheckzz.gitbooks.io/angularjs-learning-notes/content/chapter4/chapter4.html" target="_blank">gitbook</a>可供参考。Angular 2.0版本较新，Angular 2.0版本的内容主要参考自<a href="https://dzone.com/articles/typed-front-end-with-angular-2" target="_blank">DZone的一篇文章</a>，同时2.0版本有了<a href="https://angular.io/" target="_blank">新的官网</a>。</p>
		<hr>
		<h1 id="vuejs">Vue.js</h1>
		<p>Vue是与React.js和Angular JS类似的一套构建用户界面（以单页面应用为主）的渐进式框架，比较轻量级，<strong>易于入门和动手开发</strong>。同时，也可以很容易和其他库和项目进行整合（如vue-loader）。Vue的设计目标是<strong>通过尽可能简单且易于使用的API来实现响应式数据绑定和视图组件组合</strong>。</p>
		<p>Vue有自己的<a href="https://vuejs.org/" target="_blank">官方网站</a>和一个很不错的<a href="https://cn.vuejs.org/v2/guide/" target="_blank">中文译版</a>。除了本身的库（star数已有41k）以外，面向复杂路由功能和复杂组件状态管理，开发组还额外提供了vue-router（star数4k）和vuex（star数5k）方便开发者管理。</p>
		<h3 id="vuejs_start">第一印象</h3>
		<p>Vue在起步上不需要复杂操作，只需要引入vue.js的源文件（下载到本地或是从CDN处获取）即可。Vue在API风格上和React，Angular甚至backbone都有相似之处。这里有官方所做的<a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank">对比</a>。下面是一个最简单的使用Vue.js渲染DOM的例子。</p>
		<pre><code>&lt;div id="app">
  {{ message }}
&lt;/div>
</code></pre>
		<pre><code>var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
</code></pre>
		<p>其中涉及到的vue的使用方式，若是接触过React，Angular，backbone的会很容易理解。再复杂点如下，可以结合命令实现条件、循环、数据绑定等</p>
		<pre><code>&lt;div id="app">
  &lt;p v-if="seen">Now you see me&lt;/p>
  &lt;ol>
    &lt;li v-for="todo in todos">
      {{ todo.text }}
    &lt;/li>
  &lt;/ol>
&lt;/div>
</code></pre>
		<pre><code>var app3 = new Vue({
  el: '#app',
  data: {
    seen: true，
    todos: [
      { text: 'Learn JavaScript' },
      { text: 'Learn Vue' },
      { text: 'Build something awesome' }
  }
})
</code></pre>
		<p>在上面的例子中，数据流向都是从上至下的，通过<code>v-on</code>指令可以让用户和应用进行互动，将用户输入的数据由下至上传递。</p>
		<p>同时，组件系统也是Vue.js一个重要概念。它将前端界面抽象成独立可复用的各个小组件来构建大型应用。并通过<code>props</code>以及<code>emit/on</code>来实现组件间的信息沟通。组件内通过<code>template</code>定义渲染内容，组件间支持嵌套和组合。</p>
		<h3 id="vuejs_base">基础</h3>
		<ul>
			<li>Vue.js的应用都是通过<code>new Vue({})</code>的形式创建Vue根实例的方式启动的。也可以通过<code>var MyComponent = Vue.extend({})</code>的形式创建自定义组件全局使用。</li>
			<li>每个Vue实例会代理其<code>data</code>域内所有属性，实例创建后添加的新属性将不会触发视图更新，除<code>data</code>域外，还有些特殊属性和方法有前缀<code>$</code>作为区分，见附录</li>
			<li>Vue实例在被创建后有自己的生命周期，并在周期变化时调用一些生命周期钩子。例如<code>created，mounted，updated，destroyed</code>。<a href="#vuejs_lifecycle">该图</a>做了细致的说明。</li>
		</ul>
		<h3 id="vuejs_usage">使用</h3>
		<h4 id="vuejs_template">模板</h4>
		<p>Vue.js使用了基于HTML的模版语法，允许开发者声明式地将DOM绑定至底层Vue实例的数据。在底层实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应系统，在应用状态改变时，Vue会计算出重新渲染组件的最小代价并应用到DOM操作上。</p>
		<p>如果你熟悉虚拟DOM和<span class="i">JSX</span>语法，也可以通过直接写<code>render</code>函数替代模板的效果。</p>
		<h5 id="vuejs_text">文本</h5>
		<p>数据绑定最常见的形式就是使用双大括号的语法进行文本插值。绑定的数据对象改变时，插值的内容也会实时更新。通过使用<code>v-once</code>指令，你还能执行一次性地插值。</p>
		<p>如果需要纯HTML内容，可以使用<code>v-html</code>指令。但是不建议这么做，因为会导致难易防御<span class="i">XSS</span>攻击。绑定HTML属性时需要使用<code>v-bind</code>指令，该指令可以简写如下：</p>
		<pre><code>&lt;div :id="dynamicId">&lt;/div></code></pre>
		<p>在模板插值中，Vue.js还提供了完全的JavaScript表达式支持。</p>
		<h5 id="vuejs_dire">指令</h5>
		<p>指令（Directives）是带有<code>v-</code>前缀的特殊属性。除了<code>v-for</code>，指令属性的值预期是单一JavaScript表达式。一些指令能接受一个“参数”，在指令后以冒号指明。修饰符是以半角句号指明的特殊后缀，用于指出一个指定应该以特殊方式绑定，常用在绑定事件上。</p>
		<h5 id="vuejs_abbr">缩写</h5>
		<p><code>v-bind</code>可以缩写为半角冒号<code>:</code>，<code>v-on</code>可以缩写为<code>@</code>.</p>
		<h4 id="vuejs_fields">复杂属性</h4>
		<p>模板中放入太多的逻辑会让模板过重且难以维护。在这种情况下，模板不再简单和清晰，应该选用<strong>计算属性</strong>实现。</p>
		<h5 id="vuejs_computed">计算属性</h5>
		<p>可以像绑定普通属性一样在模板中绑定计算属性。<strong>在依赖属性改变时，计算属性也会跟着改变</strong>，声明式地创建这种依赖关系是易于测试和理解的。</p>
		<pre><code>var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // a computed getter
    reversedMessage: function () {
      // `this` points to the vm instance
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
		<p>需要注意的是，计算属性会缓存数据，只有在它的相关依赖发生改变时才会重新取值。因此，当依赖属性并非响应式时，计算属性将不会更新，如<code>Date.now()</code>。</p>
		<p>在必要时你还可以提供一个 setter，提供修改计算属性时，依赖属性的更新。</p>
		<h5 id="vuejs_watch">Watcher</h5>
		<p><span class="i">Watcher</span>完成的功能和计算属性类似。但是它可以作为一种更通用的方法，来相应数据的变化。这在想要相应数据变化，执行异步操作或开销较大的操作时，是很有用的。<code>watch</code>属性接受<code>oldVal</code>和<code>newVal</code>两个参数。</p>
		<h4 id="vuejs_style">样式</h4>
		<p>数据绑定一个常见需求是操作元素的class列表和它的内联样式。我们可以用<code>v-bind</code>处理它们，为了减少字符串拼接，Vue.js提供了一些特供的特性。</p>
		<h5 id="vuejs_class">Class</h5>
		<p>class属性接受一个<strong>对象或数组</strong>，表示绑定到之上的类名列表。甚至可以直接绑定data域内的一个对象。最佳实践是绑定到对象的计算属性。</p>
		<h5 id="vuejs_inlinestyle">内联样式</h5>
		<p><code>v-bind:style</code>的使用方法类似上面，接受一个Javascript对象或数组。最佳实践是使用计算属性表示。</p>
		<h5 id="vuejs_transition">Transition</h5>
		<p>在插入、更新或者移除DOM时，Vue.js提供特色的过渡效果。使用<code>&lt;transition></code>标签包裹，结合<code>v-if</code>和<code>v-show</code>以及特殊css类名，可以实现元素的展现和消失。再结合效果库，如<span class="i">Animate.css</span>或<span class="i">Velocity.js</span>，可以实现酷炫的效果。不建议同时使用<span class="i">transition</span>和<span class="i">animation</span>。</p>
		<p>多元素渐变时，可以在<code>&lt;transition></code>标签中指定<code>mode</code>属性优化渐变效果。Vue.js的<code>&lt;transition-group></code>可以专门用来处理列表的过渡效果，需要注意的是，使用transition-group时，元素需要不能是<span class="i">inline</span>，更多内容见<a href="#vuejs_reference">附录</a>。</p>
		<p>Vue.js在元素出现和消失时，会触发<code>enter，leave</code>等钩子函数。搭配<span class="i">tween.js</span>和<span class="i">color.js</span>等可以实现<a href="https://cn.vuejs.org/v2/guide/transitioning-state.html" target="_blank">数值的渐变效果</a>。</p>
		<p>更详细的讲解见<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank">过渡一节</a>。</p>
		<h4 id="vuejs_control">流程控制</h4>
		<h5 id="vuejs_if">v-if/f-else</h5>
		<p>如字面意思，后跟表达式执行if功能。也可以用<code>v-else</code>添加一个“else”块。在和<code>&lt;template></code>标签合用时，可以包装一组标签。</p>
		<p>V2.1.0后，新增了<code>v-else-if</code>。用做else-if块。</p>
		<h5 id="vuejs_show">v-show</h4>
		<p>等同于<code>v-if</code>，不同的是，<code>v-show</code>的元素会始终渲染并保持在DOM中。<code>v-show</code>是简单的切换元素的CSS属性<code>display</code>。而<code>v-if</code>是真实的条件渲染，在条件变化时进行局部编译并缓存起来。</p>
		<p>一般来说，<code>v-if</code>有更高的切换消耗，而<code>v-show</code>有更高的初始渲染消耗</p>
		<p><strong>注意，<code>v-show</code>不支持使用在<code>&lt;template></code>中。</strong></p>
		<h5 id="vuejs_for">v-for</h5>
		<p><code>v-for</code>指令根据一组数组的选项列表进行渲染，需要<code>item in items</code>形式的特殊语法，<code>items</code>是源数据数组并且<code>item</code>是数组元素迭代的别名。也可以使用<code>of</code>代替<code>in</code>。<code>v-for</code>除了循环数组也可以循环对象，如下：</p>
		<pre><code>&lt;div v-for="(value, key, index) in object">
  {{ index }}. {{ key }} : {{ value }}
&lt;/div>
</code></pre>
		<p>为了便于简单的循环，可以使用类似于<code>n in 10</code>这样的用法，重复多次模板。<code>v-for</code>也有<code>&lt;template></code>的用法。为了确保在特定索引下显示已被渲染过的每个元素，可以为元素指定<code>key</code>属性。</p>
		<p>另外，需要特别声明的是，<strong>由于Javascript的限制，Vue不能检测对数组以下两种情况的改动：</strong></p>
		<ul>
			<li>当你利用索引直接设置一个项时，例如： <code>vm.items[indexOfItem] = newValue</code></li>
			<li>当你修改数组的长度时，例如： <code>vm.items.length = newLength</code></li>
		</ul>
		<h4 id="vuejs_response">响应</h4>
		<p>数据驱动的重要一环是用户输入和响应。</p>
		<h5 id="vuejs_event">监听事件</h5>
		<p>使用<code>v-on</code>监听DOM事件来触发一些JavaScript代码。通常情况下，把事件处理逻辑下载方法中，让<code>v-on</code>接收一个方法名或内联JavaScript语句。</p>
		<pre><code>&lt;div id="example-2">
  &lt;!-- `greet` 是在下面定义的方法名 -->
  &lt;button v-on:click="greet">Greet&lt;/button>
&lt;/div>
</code></pre>
		<p>在使用内联语句时，可以将原生DOM事件——特殊变量<code>$event</code>作为输入参数传给方法。</p>
		<p>事件处理器支持修饰符，如<code>.stop, .prevent, .capture, .self, .once</code>作为语法糖。按键事件keyup还支持按键修饰符，如<code>.enter, .delete, .esc, .space, .up</code>, .13等。可以全局通过<code>Vue.config.keyCodes.f1 = 112</code>的形式设置自定义按键修饰符。<code>.ctrl, .alt, .shift, .meta</code>四个修饰符用来配合其他鼠标和键盘事件开启监听。</p>
		<p>除了原生事件，在自定义组件后，父组件可以监听子组件上的<a href="#vuejs_custom">自定义事件</a>。</p>
		<h5 id="vuejs_form">表单控件</h5>
		<p><code>v-model</code>常用在在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。但它实际上只是语法糖。它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。在有特殊需要时，可以自己用<code>v-on</code>和<code>v-bind</code>实现<code>v-model</code>。</p>
		<p>单选框，多选框。单选列表，多选列表等可以简单使用<code>v-model</code>即可，而不必自己写处理函数。复选框和多选列表的各元素共用一个<code>v-model</code>数组。</p>
		<p><code>v-model</code>支持修饰符<code>.lazy, .number, .trim</code>等。</p>
		<h4 id="vuejs_component">组件</h4>
		<p>组件是Vue最关键的一个特性，同时也是最灵活最有内容的特性。组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义元素。不过，有些情况下，组件也可以是原生HTML元素的形式，<strong>以<code>is</code>特性扩展</strong>。</p>
		<h5 id="vuejs_comp_usage">使用</h5>
		<p>通过<code>Vue.component('my-component', {})</code>的形式注册。对于自定义标签名，Vue建议遵循小写且包含短杠的规则。</p>
		<p>有时不必在全局注册每个组件。通过使用<code>components</code>选项注册，可以使组件仅在另一个实例或组件的作用域中可用。</p>
		<pre><code>var Child = {
  template: '<div>A custom component!</div>'
}
new Vue({
  // ...
  components: {
    // &lt;my-component> 将只在父模板可用
    'my-component': Child
  }
})
</code></pre>
		<p>当使用DOM作为模版时, 会受到HTML的一些限制，因为Vue只有在浏览器解析和标准化HTML后才能获取模版内容。变通的方案是使用特殊的 <code>is</code> 属性。同时，data域必须为函数，因为Vue组件可能被利用多次，使用对象定义data域会导致污染。</p>
		<p>组件间协同工作必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。在Vue.js中，父子组件的关系可以总结为 <strong>props down, events up</strong>。父组件通过props向下传递数据给子组件，子组件通过events给父组件发送消息。</p>
		<h5 id="vuejs_prop">Prop</h5>
		<p>组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 <code>props</code> 把数据传给子组件。此时，子组件需要显式地用 <code>props</code> 选项声明prop。</p>
		<p>初学者常犯的一个错误是使用字面量语法传递数值，如：</p>
		<pre><code>&lt;comp some-prop="1">&lt;/comp></code></pre>
		<p>如果<strong>想传递一个实际的JavaScript数字，需要使用<code>v-bind</code></strong>，从而让它的值被当作JavaScript表达式计算。</p>
		<pre><code>&lt;comp v-bind:some-prop="1">&lt;/comp></code></pre>
		<p>同时还要注意，prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着<storng>不应该在子组件内部改变prop</storng>。从而，有两种实践方法：</p>
		<ul>
			<li>prop作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用</li>
			<li>确保prop不会被更改（用在计算属性中）</li>
		</ul>
		<p>当<code>prop</code>属性为对象时，可以包含对prop的验证要求。</p>
		<h5 id="vuejs_custom">自定义事件</h5>
		<p>每个Vue实例都实现了事件接口(Events interface)，从而都能使用<code>$on</code>监听事件和使用<code>$emit</code>触发事件。监听自定义事件的方法和原生事件一致。</p>
		<p>在非父子通信时，通常可以使用一个空的Vue实例作为中央时间总线。如下：</p>
		<pre><code>var bus = new Vue()
// 触发组件 A 中的事件
bus.$emit('id-selected', 1)
// 在组件 B 创建的钩子中监听事件
bus.$on('id-selected', function (id) {
  // ...
})
</code></pre>
		<p>在更复杂的场景下，建议使用<span class="i">vuex</span>管理状态。</p>
		<h5 id="vuejs_dispatch">内容分发</h5>
		<p>使用组件时，通过slot分发内容，使用特殊的<code>&lt;slot></code>元素作为原始内容的插槽。</p>
		<p>除非子组件模板包含至少一个<code>&lt;slot></code>插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的slot时，父组件整个内容片段将插入到slot所在的DOM位置，并替换掉slot标签本身。</p>
		<p><code>&lt;slot></code>元素可以用一个特殊的属性<strong><code>name</code></strong>来配置如何分发内容。多个slot可以有不同的名字。具名slot将匹配内容片段中有对应slot特性的元素。在父组件中，通过为标签指定<strong><code>slot</code></strong>属性进行一一匹配。</p>
		<p></p>
		<p>作用域插槽通过在子组件的slot中指定<code>text</code>属性，将子组件prop传递给父级，在父组件具有<code>scope</code>属性的<code>&lt;template></code>中使用。详见<a href="https://cn.vuejs.org/v2/guide/components.html#作用域插槽" target="_blank">作用域插槽</a>。</p>
		<h5 id="vuejs_dynamic">动态组件</h5>
		<p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。<strong>最佳实践是，使用保留的<code>&lt;component></code>元素，动态地绑定到它的<code>is</code>特性</strong>。如下：</p>
		<pre><code>var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
</code></pre>
<pre><code>&lt;component v-bind:is="currentView">
  <!-- 组件在 vm.currentview 变化时改变！ -->
&lt;/component></code></pre>
		<p>当组件全局定义时，甚至可以指定在<code>currentView</code>后。</p>
		<p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个<code>&lt;keep-alive></code>标签在<code>&lt;component></code>外。</p>
		<h5 id="vuejs_hint">注意事项</h5>
		<ul>
			<li>编写组件时，需要设计好<code>Props，Events，Slots</code>，三项都不可少。</li>
			<li>组件命名时，可以使用各种风格，但在HTML模板中，请使用kebab-case形式</li>
			<li>如果子组件有<code>inline-template</code>特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。但是这也让作用域变得难以理解，最佳实践是使用<code>.vue</code>文件中的<code>template</code>元素。</li>
			<li>另一种定义模板的方法是，使用<code>text/x-template</code>类型，并指定一个<code>id</code>。</li>
			<li><code>v-once</code>在大量静态内容的网页中能加快Vue渲染HTML的速度。</li>
		</ul>
		<h3 id="vuejs_more">更多</h3>
		<p>在<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank">自定义指令</a>和<a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank">Mixin</a>上，因为未做实践，这里不做介绍，可以参考教程上的说明。<a href="https://github.com/vuejs/vuex" target="_blank">vuex</a>和<a href="http://router.vuejs.org/zh-cn/" target="_blank">vue-router</a>也是如此。</p>
		<p>生产环境部署中，<a href="https://vue-loader.vuejs.org/en/?q=" target="_blank">vue-loader</a>是很方便的利用webpack自动打包.vue文件，同时支持使用<span class="i">pug</span>模板引擎，ES2015语法，<span class="i">Sass</span>等CSS预处理器。岂不美哉。</p>
		<h3 id="vuejs_reference">附录</h3>
		<h4 id="vuejs_reserve">内置组件</h4>
		<p><span class="b">component</span></p>
		<p>提供一个通过<code>is</code>属性指定具体渲染组件的组件占位符。通过<code>is</code>属性指定组件名或组件属性或组件构造器，<code>inline-template</code>属性指定component内的内容是否为模板（这么做会混淆作用域，并非最佳实践）。component组件通常用来构建动态组件（因为<code>is</code>属性完全可以作为props由父组件传入）。</p>
		<p><span class="b">transition</span></p>
		<p><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank">过渡</a>是Vue提供的很有特色的功能（虽然强大的渐变效果要借助第三方库）。与之相呼应的是<code>enter，leave，enter-active，leave-active，appear，appear-active</code>这些css预置类名。类名前缀由<strong><code>name</code></strong>属性指定，或者通过<strong>类名后+"class"</strong>作为<code>&lt;transition></code>属性名手动指定。另外，<strong><code>mode</code></strong>属性定义多个过渡同时出现的先后关系，有<code>out-in</code>和<code>in-out</code>两种。<strong><code>css（boolean）</code></strong>属性决定是否关联css过渡类，<strong><code>type</code></strong>属性指定过渡为<code>transition</code>或是<code>animation</code>。</p>
		<p>Vue维护transition的一些内部事件，包括<code>before-enter，enter，after-enter</code>等，可用于js钩子函数监听。<code>&lt;transition></code><strong>本身不对应DOM元素</strong>，只是将需要过渡效果的内容包裹在里面。</p>
		<p><span class="b">transition-group</span></p>
		<p>与<code>&lt;transition></code>不同，<code>&lt;transition-group></code>元素渲染多个元素或组件的过渡效果，且对应一个真实的DOM元素（默认为span，可以通过<code>tag</code>属性修改）。它内部支持<span class="i">CSS transform</span>过渡移动。过渡效果通过<code>name</code>属性或<code>move-class</code>属性对应CSS自定义类。</p>
		<p>需要注意的几点，1）<code>&lt;transition-group></code>的子节点必须有独立的key；2）子节点必须为<span class="i">inline-block</span>或是<span class="i">flex</span>，FLIP动画效果才有效果。</p>
		<p><span class="b">slot</span></p>
		<p>用于父组件进行内容分发。内容分发后自身会被替换掉。<code>name</code>属性用于对应父组件的<code>slot</code>属性元素里的内容。</p>
		<h4 id="vuejs_options">实例配置选项</h4>
		<p>在通过<code>new Vue()</code>或<code>Vue.extend</code>创建Vue实例时，可以指定一系列初始化配置选项。</p>
		<p><span class="b">el</span> <code> string | HTMLElement</code></p>
		<p>Vue实例挂载的DOM元素。可以是CSS选择器或是<span class="i">HTMLElement</span>实例。当该选项未指定时需要通过<code>vm.$mount()</code>手动开启。</p>
		<p><span class="b">template</span> <code>string</code></p>
		<p>使用一个字符串作为实例的渲染模板。除非模板有slot分发，<strong>模板内容将会替换挂载元素内容的所有内容</strong>。如果值以<code>#</code>开始，将使用匹配元素的<code>innerHTML</code>作为模板。</p>
		<p><span class="b">render</span> <code> Function</code></p>
		<p><code>template</code>属性的替代方案，<code>render</code>函数接受一个<code>createElement</code>函数作为第一个参数创建VNode。<code>createElement</code>函数接受三个参数，第一个参数表示绑定DOM元素，可以为<code>String</code>或<code>Object</code>或<code>Function</code>，第二个参数为修饰HTML标签的<a href="https://cn.vuejs.org/v2/guide/render-function.html#完整数据对象" target="_blank">数据对象</a>，第三个对象表示子节点，可以是<code>String</code>或<code>Array</code>类型。<code>createElement</code>内容较多，可以参见<a href="https://cn.vuejs.org/v2/guide/render-function.html#基础" target="_blank">Render函数</a>一节。</p>
		<p>如果组件为<a href="https://cn.vuejs.org/v2/guide/render-function.html#函数化组件" target="_blank">函数组件</a>，则还可以接受<code>context</code>参数创建上下文。</p>
		<p><span class="b">data</span> <code>Object | Function(组件定义中)</code></p>
		<p>Vue实例的数据对象。Vue将会递归将data的属性转换为getter/setter，从而让data的属性能够响应数据变化，不推荐观察拥有状态行为的对象。实例创建之后，可以通过<code>vm.$data</code>访问原始数据对象。<strong>注意，为避免冲突，以<code>_</code>或<code>$</code>开头的属性不会被Vue实例代理。</strong></p>
		<p><span class="b">props</span> <code>Array<string> | Object</code></p>
		<p>props用来接收来自于父组件的数据。props可以是简单的数组，或者使用对象作为替代，使用对象时允许配置高级选项，如类型检测（type）、自定义校验（validator）和设置默认值（default）等。</p>
		<p><span class="b">propsData</span> <code> { [string] : any }</code></p>
		<p>用于创建实例时传递初始化的props，一般用于测试。</p>
		<p><span class="b">methods</span> <code>{ [string]: Function }</code></p>
		<p>methods属性和data属性类似，会混入到Vue实例当中，可以直接通过实例来访问这些方法。方法中的<code>this</code>绑定该Vue实例。因此<strong>不能使用箭头函数定义method函数</strong>。</p>
		<p><span class="b">computed</span> <code>{ [string]: Function | { get: Function, set: Function } }</code></p>
		<p>用于定义计算属性，计算属性将混入在Vue实例的属性中，同时绑定getter和setter函数。为了保证效率，<strong>计算属性结果会被缓存</strong>，当依赖属性更新时重新计算。最佳实践时用于表示<code>data</code>属性的简单计算得到时。在计算过程复杂或耗时时，选择<strong><code>watch</code>选项</strong>。</p>
		<p><span class="b">watch</span> <code>{ [string]: Function | { get: Function, set: Function } }</code></p>
		<p>键为观察的表达式，值为对应的回调函数。回调函数可以是方法名或是匿名函数，它接受原值和新值作为两个输入参数。同样，不应使用箭头函数定义watcher函数。</p>
		<h4 id="vuejs_obj_fields">实例常用属性</h4>
		<p>Vue实例创建后，默认的实例属性来自创建实例时的data属性。需要访问实例本身特性时统一在特性前加上<code>$</code>符号。根据官网教程的介绍，惯例使用<code>vm</code>作为创建Vue实例的变量名，下面也是如此。</p>
		<p><a href="https://cn.vuejs.org/v2/api/#vm-data" target="_blank"><span class="b">vm.$data</span></a> <code>Object</code></p>
		<p>Vue实例储存的数据对象，Vue通过<code>setter</code>和<code>getter</code>的形式代理对data属性的访问。通过类似<code>vm.foo</code>的形式访问。</p>
		<p><a href="https://cn.vuejs.org/v2/api/#vm-el" target="_blank"><span class="b">vm.$el</span></a> <code>HTMLElement</code></p>
		<p>返回Vue实例使用的根DOM元素。类型为<code>HTMLElement</code>。</p>
		<p><span class="b">vm.$root</span> <code>Vue instance</code></p>
		<p>当前组件树的根Vue实例或自己。</p>
		<p><a href="https://cn.vuejs.org/v2/api/#vm-slots" target="_blank"><span class="b">vm.$slots</span></a> <code>{ [name: string]: ?Array<VNode> }</code></p>
		<p>用来访问当前组件中被slot分发的内容，具名slot的内容可以通过<code>vm.$slots.foo</code>的方式来访问，<code>default</code>属性包括了所有未具名slot中的节点内容。2.1.0版本后新增了<code>$scopedSlots</code>访问作用域slot。</p>
		<p><a href="https://cn.vuejs.org/v2/api/#ref" target="_blank"><span class="b">vm.$refs</span></a> <code>Object</code></p>
		<p>类似于<span class="i">React</span>中的用法，访问所有在HTML中声明<code>ref</code>属性的DOM节点。当<code>ref</code>属性声明在组件上时，返回该组件实例。</p>
		<p><span class="b">vm.$on(event, callback)</span></p>
		<p>监听当前实例上的自定义事件。事件可以由<code>vm.$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数。此外，<code>vm.$once</code>完成同样的效果，但是只监听一次。</p>
		<p><span class="b">vm.$emit(event. [...args])</span></p>
		<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>
		<p>此外，<span class="b">vm.$options</span>返回创建实例时输入的初始化选项；<span class="b">vm.$parent</span>返回当前实例的父实例，<span class="b">vm.$children</span>返回当前实例的直接子组件。<span class="b">vm.$off</span>移除事件监听。</p>
		<h4 id="vuejs_hooks">生命周期钩子</h4>
		<p>在Vue实例的生命周期里，会触发一些钩子函数。函数中的<code>this</code>自动绑定到该实例。</p>
		<p><span class="b">beforeCreate</span></p>
		<p>在实例初始化，数据观测前调用</p>
		<p><span class="b">created</span></p>
		<p>实例创建完成后调用，测试数据观测，属性方法运算，watch/event回调都已经完成。但是元素尚未渲染和挂载，<code>$el</code>属性不可见。此时对所做的DOM操作无效。</p>
		<p><span class="b">beforeMounte</span></p>
		<p>在挂载前调用，<code>render</code>函数首次被调用。</p>
		<p><span class="b">mounted</span></p>
		<p>el被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用该钩子函数。</p>
		<p><span class="b">beforeUpdate</span></p>
		<p>数据更新发生时，虚拟DOM重新渲染和patch之前。</p>
		<p><span class="b">updated</span></p>
		<p>虚拟DOM重新渲染和patch之后。</p>
		<p>此外，还有<span class="b">activated</span>，<span class="b">deactivated</span>用在<code>keep-alive</code>组件切换内部组件时；<span class="b">beforeDestroy</span>，<span class="b">destroyed</span>用在实例销毁时。</p>
		<span id="vuejs_lifecycle"><img src="https://cn.vuejs.org/images/lifecycle.png"></span>
		<hr>
		<h1 id="mangodb">MangoDB</h1>
		<p>MangoDB是node开发中经常用的数据库。这里做简单介绍。</p>
		<h3 id="mango_brief">简介</h3>
		<p>MangoDB是一个基于分布式文件存储的NoSQL数据库，介于关系数据库和非关系数据库间。NoSQL相比关系数据库而言，更适合与海量的网络应用数据，而SQL则更适合商业事务的存储与处理。基于NoSQL的MangoDB由C++编写，它将数据存储成文档，数据结构由键值对组成，类似于JSON对象。</p>
		<p>MangoDB的安装部署十分简单。去官网下载预编译包安装后，在根目录下创建数据目录即可。</p>
		<h3 id="mango_unit">基本单位</h3>
		<p>MangoDB中保留了database和索引的概念，将表视作集合，将数据记录行视作文档，将数据字段视作域，联表替换成文档嵌入，会自动将<code>_id</code>字段设置为主键。</p>
		<p>在MangoDB自身提供的shell下，<code>show dbs</code>可以查看所有已有的数据库。<code>db</code>可以查看当前的数据库对象，使用<code>use xxx</code>可以切换数据库。数据库通过名字来标识，<span class="i">admin, local, config</span>是保留的特殊数据库。</p>
		<p>文档是一个键值对，文档不需要设置相同的字段，且相同字段不要求相同数据类型。同时文档中的值甚至可以是其他的富数据类型。</p>
		<p>集合等同于RDBMS中的表，存在于数据库中，没有固定结构。当第一个文档插入时，集合就会被创建。Capped collection是固定大小的集合，是高性能的自动维护对象插入顺序的集合。需要显示的创建。</p>
		<p>数据库的信息储存在<span class="i">{dbname}.system</span>这个系统空间中，它的各字段包含着多种系统信息。其中个别字段支持修改或删除。</p>
		<h3 id="mango_database">连接/创建/删除数据库</h3>
		<p>在shell（支持JavaScript语法）下，通过命令<code>mongodb://localhost</code>连接数据库，若有用户名和密码，须写成<code>mongodb://username:password@hostname/dbname</code>的形式。</p>
		<p>使用<code>use</code>命令可以创建或切换到指定数据库。使用<code>db.dropDatabase()</code>删除当前数据库，使用<code>db.createCollection()</code>创建集合。<code>db.collection.drop()</code>删除集合。</p>
		<h3 id="mango_crud">CRUD操作</h3>
		<p><code>db.COLLECTION_NAME.insert(document)</code>插入文档，文档格式和JSON基本一样，也可以先将文档存储在变量中。若指定的集合不在数据库中，MongoDB会自动创建该集合并插入。<code>insert()</code>方法可以认为是不指定<code>_id</code>字段的<code>save()</code>方法。</p>
		<p><code>db.COLLECTION_NAME.update(QUERY, UPDATE,{upsert: BOOL, multi: BOOL, writeConcern: …})</code>. <code>query</code>是查询条件, <code>update</code>是update内容和更新操作符。常用操作符有<code>$set $unset $inc $rename $setOnUpdate $(query)</code>等. <code>upsert</code>意义是如果不存在update的记录是否插入新纪录，<code>multi</code>意为若找到多条是否更新多条。<code>save</code>方法则通过传入一个带有<code>_id</code>的文档，替换原id的文档。</p>
		<p><code>db.COLLECTION_NAME.remove(QUERY, JUST_ONE)</code>，第一个参数指定查询条件，第二个参数选择是否只删除一条。</p>
		<p><code>db.COLLECTION_NAME.find()</code>以非结构化方式显示所有文档。<code>pretty()</code>方法以格式化方式显示所有文档。<code>find()</code>方法可以接受条件作为where子句。同样用<code>{}</code>方式表示大小关系，有<code>$lt $lte $gt $gte $ne</code>操作符，这些操作符可以并列书写，如<code>{likes: {$lt: 200, $gt: 100}}</code>。用逗号隔开的键值表示并列的<code>AND</code>条件，用<code>$or</code>表示<code>OR</code>条件，以<code>$or:[{}{}]</code>的方式使用。同时<code>$type</code>操作符可以用于筛选特定类型的字段。</p>
		<p><code>limit()</code>方法同样可以跟在<code>find()</code>后面，类似于SQL语句中的<code>LIMIT</code>。<code>skip()</code>方法用于跳过<code>find(n)</code>方法得到的前n条文档。<code>sort()</code>类似于<code>ORDER BY</code>，通过<code>{KEY: 1/-1}</code>来控制特定字段的升降序。</p>
		<h3 id="mango_index">索引与聚合</h3>
		<p><code>db.COLLECTION_NAME.ensureIndex({KEY: 1/-1}. {background: true/false})</code>用来创建索引，提高搜索效率。<code>KEY</code>的位置可以指定多个字段，创建复合索引。第二个参数指定是否后台执行。</p>
		<p>集合还有<code>aggergate(middleware)</code>方法用于聚合，类似SQL的聚合函数。接受若干个中间件作为输入参数。中间件可以有<code>project，match，limit，skip，unwind，group，sort，geoNear</code>。分别修改输入文档的结构，过滤数据，跳过指定数目文档，拆分数组类型字段，文档分组，排序输出，按地理位置排序。<code>$group</code>类似SQL中的<code>group by</code>，需要指定<code>_id</code>和输出字段名。聚合表达式有<code>$sum, $avg, $min, $max, $first, $last, $push, $addToSet</code>.</p>
		<h3 id="mango_others">其他</h3>
		<p>可以通过应用ObjectId的方式嵌入文档实现关系。当引用在不同的数据库、集合、文档时，通过DBRefs引用外部内容，有操作符<code>$ref</code> <code>$id</code> <code>$db</code> 可以使用。</p>
		<p>查询的<code>explain()</code>和<code>hint()</code>方法分别用来提供查询信息和强迫MongoDB使用特定索引查询。</p>
		<p>复制：在使用mongod启动时指定<code>--replSet</code>参数设置副本集。在客户端通过<code>rs.add</code>加入。</p>
		<p>分片：通过<span class="i">Shard, Config Server, Query Router</span>完成分割数据的功能，具体略</p>
		<p>备份：使用mongodump工具指定要备份的数据库，使用mongorestore数据恢复</p>
		<hr>
		<h1 id="socketio">Socket.io</h1>
		<h3 id="socketio_brief">简介</h3>
		<p>socket.io是为网络应用提供跨平台实时通信的javascript库。它旨在建立客户端与服务器端的持久性连接，并模糊底层传输机制的实现细节。socket.io主要采用了HTML5中的<code>WebSocket</code>技术（注意是HTML5，并非是HTTP协议的新技术），同时，该库也支持一些降级功能使用在不支持<code>WebSocket</code>的环境下，如AJAX long polling, AJAX multipart streaming, JSONP Polling等实现方式。</p>
		<h3 id="WebSocket">WebSocket</h3>
		<p>在WebSocket出现之前，有着其他和建立socket连接效果类似的做法。如AJAX轮询，浏览器每隔数秒向服务器发起请求，询问是否有新信息出现。Long polling也是类似，不过采取的阻塞模式。服务器端若没有新信息，就没有Response返回到客户端。由于HTTP协议的被动性，前者要求服务器很快的处理速度，后者要求服务器支持高并发的能力。</p>
		<p>WebSocket是HTML5出的新协议，作为<code>HTTP1.1</code>版本的补充。相比非持久的HTTP协议来说，WebSocket是一个持久化的协议。HTTP的生命周期由<code>Request</code>发起，在<code>Response</code>后结束。<code>HTTP1.1</code>中，keep-alive特性可以在一个HTTP连接中，发送多个<code>Request</code>，接受多个<code>Response</code>，但是<code>Response</code>被动返回的特点没有改变。</p>
		<p>WebSocket协议在握手时借用的HTTP协议， <code>Connection</code>和<code>Upgrade</code>字段分别为Upgrade和websocket，意为告诉服务器当前的连接要使用websocket协议。客户端发送<code>Sec-WebSocket-Key</code>，<code>Sec-WebSocket-Protocol</code>，<code>Sec-WebSocket-Version</code>分别为一个验证随机字符串，服务名和WebSocket协议版本，服务器返回正确的<code>Sec-WebSocket-Accept</code>和<code>Sec-WebSocket-Protocol</code>后，握手成功。接下来按照WebSocket的协议进行通信。关于WebSocket协议的细节，这里从略。</p>
		<p>socket.io中主要采取WebSocket完成持久性连接，但是当浏览器不支持WebSocket协议时，也只能采取上面提到的一些替代方法。</p>
		<h3 id="socketio_install">安装与使用</h3>
		<p>使用命令<code>npm install --save socket.io</code>或是写在<span class="i">package.json</span>文件中直接通过<code>npm install</code>安装。<a href="http://socket.io/get-started/chat/" target="_blank">官方例子</a>中，安装前需要预装express。</p>
		<p>安装完成后，在服务器端通过<code>require(socket.io).listen(server)</code>引入，之后<code>io.on(connection, function(socket){…})</code>即可对socket进行操作。<code>on</code>方法可以监听一个<code>emit</code>释放的事件，第一个参数为事件名，第二个参数为一个处理数据的函数。该函数接受两个参数，第一个为接受的数据，第二个为要返回的函数。socket.io默认支持<code>connect</code>，<code>message</code>，<code>disconnect</code>三个事件，用户也可以定义自己的事件。服务器端完整代码如下：</p>
		<pre><code>/* server.js */
var app = require('express')()
  , server = require('http').createServer(app)
  , io = require('socket.io').listen(server);

server.listen(80);

app.get('/', function (req, res) {
  res.sendfile(__dirname + '/index.html');
});

io.sockets.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});	</code></pre>
		<p>在浏览器端，通过引入<script src="/socket.io/socket.io.js"></script> 即可使用浏览器端的socket.io。通过<code>io()</code>启动客户端，默认与<span class="i">localhost</span>建立连接。接下来就可以通过<code>on</code>和<code>emit</code>方法和服务器端进行沟通了。emit方法用来触发一个事件，第一个参数为事件名，第二个参数为发送的数据，第三个参数为回调函数。值得注意的是，服务器端和客户端都有emit和on方法。客户端完整代码如下：</p>
		<pre><code>&lt;script src="/socket.io/socket.io.js">&lt;/script>
&lt;script>
  var socket = io.connect('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
&lt;/script>
</code></pre>
		<p>在官方样例中，还展示了socket.io的广播功能，<code>socket.emit()</code>向该连接的客户端广播，<code>socket.broadcast.emit()</code>向除此客户端外的所有客户端广播，<code>io.sockets.emit()</code>向所有连接到服务器端的客户端广播。</p>
		<h3 id="socketio_api">部分API</h3>
		<p><strong>TODO</strong></p>
		<hr>
		<h1 id="jade">Jade</h1>
		<h3 id="jade_brief">简介</h3>
		<p>Jade实际上属于模板引擎的一种，模板引擎可以便于HTML文档的书写。Jade受Haml简写法的影响，它是用JS实现的，可以供Node.js使用，具有高度可读性。Jade通过行首的标签和缩进控制文档结构。通过过滤器可以书写less、markdown、coffee-script等内容。同时，jade也有其他语言的实现，包括php，scala，ruby，java等，可以实现前后端渲染的统一。</p>
		<p>通过<code>npm install jade</code>下载jade，指定全局选项-g后，可以使用jade命令。</p>
		<h3 id="jade_lang">语法</h3>
		<p>Jade的语法和markdown也有许类似。</p>
		<p>Jade使用<code>doctype html, xml, transitional, mobile, basic, 1.1</code>...代替最外围的标签结构，默认为html5，在<code>doctype</code>下书写html开始文档。</p>
		<p>Jade中，将标签放在行首，它能自动识别自闭标签如<code>&lt;input></code>。标签后加空格，可以添加标签文本，嵌套标签时，换行使用缩进即可。当标签内容很多时，在标签后添加句点. 配合缩进或者在每段前加入<code> | </code>将下面的文本转为plain text类型。</p>
		<p>Jade中使用<code>()</code>分割属性，<code>()</code>内的内容和html标签一致，可以用空格或逗号隔开。注释使用<code>//</code>书写，在<code>//</code>后添加短横线<code>-</code>，可以将注释视作jade注释。同时支持IE版本注释。</p>
		<p>使用类似于css选择器的方法，用<code>#</code>和句点标注id和class，在标签后紧跟不带空格，如果没有标签名，默认为<code>div</code>标签。</p>
		<p>使用<code>#</code> <code>{}</code>使用之前用<code>var</code>声明的变量，变量中的特殊字符会被转义，使用<code>!</code>代替<code>#</code>表示不转义。以短横线<code>-</code>开始非缓冲代码，如<code>for</code>循环结构。用紧跟标签的<code>=</code>表示缓冲代码，会默认转义内容，<code>!=</code>表示不转义。循环结构用<code>each VAL[,KEY] in OB</code>表示。选择结构用<code>case when</code>表示类似于<code>switch</code>，可以多个<code>when</code>执行同一语句块。</p>
		<p>Jade允许使用<code>extends</code>结合<code>block</code>关键字预定义一个模板文件给其他模板调用，实现模板的集成。<code>includes</code>允许我们插入另一个jade文件到当前文件中，从而实现多重继承，除了<code>.jade</code>文件还可以引用<code>.html</code>甚至<code>.css</code> <code>.js</code>以及纯文本文件等。可以通过过滤器引入其他模板格式的模板。</p>
		<p>通过<code>mixin name(args)</code>可以定义代码片段，通过<code>+name(args)</code>的形式引用，类似于函数的用法。Mixin中还支持<code>attribute</code>，可以在<code>+name(args)</code>后跟其他的属性。同时在mixin中指定了<code>block</code>时，可以使用<code>include</code>那样的块。</p>
		<p>使用过滤器如<code>:markdown</code>可以导入其他格式的模板。下面是一个使用jade模板引擎的样例：</p>
		<pre><code>doctype html
html(lang="en")
  head
    - var name = 'Jade'
    title= name
    meta(charset="utf-8")
    link(rel="stylesheet", type="text/css" href="/stylesheets/style.css")

  body
    h1 Jade - node template engine
    #container.col
      if name === 'Jade'
        p #{name} is very cool
      else
        p Get on Jade
    footer
      p.
        Jade is a terse and simplae
        templating language with a
        strong focus on performance
        and powerful features.</code></pre>
		<p>更多参考<a href="http://blog.jayself.com/2014/07/28/Jade/" target="_blank">中文教程</a>，还可以进行<a href="http://naltatis.github.io/jade-syntax-docs/" target="_blank">在线演示</a>。另外，由于jade商标已被其他的商业公司注册，<strong>jade-lang现已更名为pug</strong>，官网已更换为<a href="https://pugjs.org/" target="_blank">pugjs</a>。</p>
		<hr>
		<h1 id="d3">D3.js</h1>
		<h3 id="d3_brief">简介</h3>
		<p>D3全称<span class="i">Data-Driven Document</span>，是使用javascript的实现数据可视化的函数库。它是一个颇受关注的开源项目，官网为<a href="http://d3js.org" target="_blank">http://d3js.org</a>。它不仅可以完成dom元素操作，更可以在画布上完成图表的绘制。</p>
		<p>HTML中提供两种标签<i>SVG</i>和<i>Canvas</i>来完成这个功能。其中SVG使用XML格式定义图形，绘制矢量图；Canvas是H5提出的新标签，用JS绘图，绘制的是位图。D3的许多图形生成器都是只支持SVG的。因此下面先对SVG做简要介绍。</p>
		<h3 id="svg">SVG介绍</h3>
		<p>SVG同XML格式定义二维图形和绘图程序，在改变尺寸时不会损失图像质量，是W3C的标准之一。svg可以通过<code>embed</code>，<code>object</code>或<code>iframe</code>标签嵌入进HTML页面中，并按照后来居上的规则渲染。下面的内容糅合自<a href="http://www.w3school.com.cn/svg/index.asp" target="_blank">w3school</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank">MDN的SVG教程</a>。</p>
		<h4 id="svg_axis">坐标</h4>
		<p>SVG使用的坐标系统以左上角为原点，x轴正方向向右，y轴正方向向下。点或形状的左上角以坐标的形式定位。SVG中的长度不标注单位时表示使用相对大小，默认为用户单位。</p>
		<h4 id="svg_shape_path">形状与路径</h4>
		<p>SVG有许多<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element" target="_blank">预设的形状元素</a>。其中常用的有<code>&lt;rect> &lt;circle> &lt;ellipse> &lt;line> &lt;polyline> &lt;polygon> &lt;path></code>。<code>&lt;rect></code>有<code>x, y, width, height, rx, ry</code>(圆角半径)等属性。<code>&lt;circle></code>有<code>r, rx, ry</code>三个属性，<code>&lt;ellipse></code>有<code>rx, ry, cx , cy</code>(圆心位置)四个属性，<code>&lt;line></code>有<code>x1, x2, y1, y2</code>四个属性。<code>&lt;polyline></code>将转折点系列放在<code>points</code>属性中，<code>&lt;polygon></code>和polyline类似，不同的是polygon路径最后一个点会返回第一个点。<code>&lt;path></code>通过<code>d</code>属性绘制路径。</p>
		<p><code>&lt;path></code>常用于绘制复杂的图形。<code>d</code>属性由命令和位置组成。命令由一个字母表示，大写字母表示绝对定位，小写字母表示相对定位。<code>M [x, y]</code>命令表示将画笔当前位置移动到<code>(x, y)</code>，但并不画线。使用<code>L [x, y] H x V y</code>可以画线，后者表示水平和垂直线。<code>Z</code>命令表示添加一条线段到路径起点闭合路径。<code>C [x1 y1, x2 y2, x y]</code>绘制三次贝塞尔曲线，<code>S [x2 y2, x y]</code>命令延长三次贝塞尔曲线，<code>Q [x1 y1, x y]</code>绘制二次贝塞尔曲线，<code>T x y</code>延长二次贝塞尔曲线。<code>A [rx ry x-asis-rotation large-arc-flag sweep-flag x y]</code>绘制弧形，<code>rx ry</code>分别表示椭圆长短轴长度，<code>x-axis-rotation</code>表示椭圆旋转角度，<code>large-arc-flag</code>表示是否选择较长弧，<code>sweep-flag</code>表示选择画弧旋转方向，<code>x y</code>表示终点坐标。</p>
		<h4 id="svg_fill_stroke">填充与边框</h4>
		<p>SVG使用属性<code>fill</code>和<code>stroke</code>属性完成填充和描边上色，颜色命名可以已使用css颜色命名方案。<code>fill-opacity</code>和<code>stroke-opacity</code>分别控制两者的透明度。描边里，<code>stroke-width</code>确定描边宽度，<code>stroke-linecap</code>指定线段两端格式，有<code>butt, square, round</code>可以选择，<code>stroke-linejoin</code>指定线段连接处格式，有<code>miter, round, bevel</code>可以选择。<code>stroke-dasharray</code>指定虚线的空白和实线长。另外，还有<code>fill-rule</code>定义重叠位置上色，<code>stroke-miterlimit</code>定义绘制miter效果的情况，<code>stroke-dashoffset</code>定义虚线开始位置。另外，可以通过css修饰svg标签，同样有内联、内部定义和引入外部css文件三种方式。需要注意的是，内部定义许放在svg标签的<code>&lt;def></code>中，使用<code>fill</code>和<code>stroke</code>表示填充和描边。</p>
		<p><code>&lt;pattern></code>元素中，可以包含任何之前包含的基本形状。它定义了单元系统和大小位置。<code>x</code>和<code>y</code>属性定义了pattern的起始点，<code>width</code>和<code>height</code>定义了下一个box要跨过多远。<code>patternUnits</code>用于描述模式本身的单位系统。<code>patternContentUnits</code>描述了基于基本形状的单元系统。对象改变大小时，pattern对象会自适应，但是对象里面的内容不会。pattern的单位系统混合使用了<code>userSpaceOnUse和objectBoundingBox</code>，易混淆。详细讨论略。</p>
		<p>文字写在<code>&lt;text></code>元素内，通过<code>x</code>和<code>y</code>属性确定位置。<code>&lt;tspan></code>用来强调文本，有<code>x, dx, y, dy, rotate, textLength</code>等属性，须放在<code>&lt;text></code>或<code>&lt;tspan></code>下使用。<code>tref</code>元素允许通过<code>xlink:href</code>引用已定义的文本。<code>textPath</code>利用<code>xlink:href</code>获得一个任意路径，让字体环绕路径。<code>text-anchor</code>属性可以改变文字的对齐方式，可以选择<code>start, middle</code>和<code>end</code>。<code>&lt;text</code>中的内容可以用字体相关的属性修饰，如<code>font-size</code>。</p>
		<h4 id="svg_transform_distord">渐变与变形</h4>
		<p><code>&lt;linearGradient></code>通过绑定id为标签添加渐变效果，通过<code>&lt;stop></code>子标签设置关键位置，在其中指定<code>offset, stop-color, stop-opacity</code>属性。同时渐变的走向由<code>linearGradient</code>标签的<code>x1, x2, y1, y2</code>决定。径向渐变由标签<code>&lt;radialGradient></code>完成，在属性里用<code>cx, cy, r</code>决定渐变的范围，由<code>fx, fy</code>决定渐变的中心。渐变的格式可以用CSS格式定义。整个渐变定义写在<code>defs</code>标签内，通过<code>fill=url(#gradient2)</code>的形式引用。</p>
		<p>两种渐变都有<code>spreadMethod</code>属性控制渐变到达终点的行为，可以为<code>pad, reflect, repeat</code>几种选择。同时<code>gradientunits</code>属性描述渐变大小和方向的单位系统。</p>
		<p><code>&lt;g></code>元素通过为之赋属性将属性赋给整个元素集合。元素的<code>transform</code>属性有许多变换方式，<code>translate(x,y)</code>将元素移动到<code>x,y</code>的位置，<code>rotate(x)</code>旋转x°，<code>skewX</code>和<code>skewY(x)</code>可以将矩形斜切为菱形，<code>scale()</code>可以以一定比例缩放元素。<code>Matrix(a,b,c,d,e,f)</code>可以指定通用的变形。</p>
		<h4 id="svg_cut">剪切与遮罩</h4>
		<p>clipping用来移除编出定义元素的部分内容，即剪切。masking允许使用透明度和灰度遮罩计算的的软边缘。<code>&lt;clipPath></code>通常定义在<code>defs</code>标签里，通过元素的<code>clip-path</code>属性引入，在<code>clipPath</code>标签中的形状最终不会绘制，它的像素只用来确定哪些像素需要呈现出来。剪切外的形状将彻底消失。利用遮罩可以将一个元素淡入淡出，同样<code>mask</code>标签内的形状确定了它的影响范围，但渐变性质将会反映到引入它的形状上。Mask中标签属性可以用<code>fill-opacity</code>和<code>stroke-opacity</code>指定透明度。</p>
		<h4 id="svg_filter">滤镜</h4>
		<p>SVG中有着相当丰富的滤镜。滤镜需要写在<code>&lt;filter></code>标签内，有<code>feBlend</code>,<code> feColorMatrix</code>, <code>feComponentTransfer</code>, <code>feComposite</code>, <code>feConvolveMatrix</code>, <code>feDiffuseLighting</code>, <code>feFlood</code>, <code>feGaussianBlur</code>等许多，它们有着不同的配置方式，且有的原理并不好理解。这里不做过多介绍。具体可参见<a href="https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#filters" target="_blank">W3C的filters部分</a>介绍</p>
		<h4 id="svg_others">其他</h4>
		<p>SVG中可以通过<code>&lt;font></code>定义一个字体，该标签中有<code>font-face, missing-glyph, glyph</code>等标签可以使用。在<code>font</code>定义完成后，在<code>text</code>的<code>font-family</code>属性中即可引入自定义字体。实际上，css3中已有了引用远程字体的<code>@font-face</code>。SVG中也有<code>image</code>元素，支持PNG, JPG和SVG图像，引入后可以对之进行SVG的一些操作。<code>foreighObject</code>元素用来引入任意XML。</p>
		<h3 id="d3_dom">DOM操作API</h3>
		<p>D3提供了许多可用的API，从基本的<code>array</code>到DOM操作再到SVG绘图十分丰富。<a href="https://github.com/d3/d3/wiki/API-Reference" target="_blank">官方API reference</a>做了详尽的解释。</p>
		<p>D3对DOM的操作和jquery类似，有一个全局对象d3，先选取元素再对元素做操作。由于d3的方法通常返回也是包含<code>htmlElement</code>的d3对象，因此支持链式调用。D3采用CSS3的<strong>选择器</strong>语法选择元素，包含标签、类名、伪类、id名、<code>attribute([type=text])</code>或容器(<code>parent, child</code>)。同时D3的选择器支持逻辑运算即<code>AND, OR</code>。在选取元素后，D3通过对之<strong>操作</strong>完成功能。<strong>操作</strong>包括获取、设置属性, <code>style, properties, HTML, text</code>等等，或是添加移除元素。D3中可以直接对<strong>选择集(<code>selection</code>)</strong>做操作，或是<code>each</code>遍历操作。</p>
		<p>在选择元素时，d3提供了<code>d3.select</code>和<code>d3.selectAll</code>两种方法。它们都支持选择器和节点两种输入参数。后者可能会在时间监听中以<code>d3.select(this)</code>的形式出现。</p>
		<p>选择集通常是元素的数组。可以通过D3的操作函数统一对选择集做操作。<code>Selection.attr(name[ ,value])</code>获取或修改选择集的特定属性。<code>value</code>为常量时，所有属性一致，<code>value</code>为<code>function</code>时，接受数据<code>datum</code>，索引<code>i</code>和<code>this</code>只想当前的DOM元素，函数返回值将替代源值。当<code>value</code>为<code>null</code>时，视作<code>removeAttr</code>。<code>name</code>可以为<code>object</code>类型。</p>
		<p><code>Selection.classed(name[, value])</code>是用来修改<code>class</code>属性的attr的特殊版本。<code>name</code>中用空格隔开或输入object可以同时设定多个classes。与上面类似，<code>value</code>可以为function。<code>value</code>为<code>false</code>时，等同于<code>removeClass</code>。只有<code>name</code>时，返回选择集中第一个非空元素是否有该类。</p>
		<p><code>Selection.style(name[, value[, priority]])</code>和以上类似，用来设置和获取CSS格式。<code>name</code>可以输入对象, <code>value</code>可以输入函数。没有<code>value</code>时，返回计算后的CSS格式。</p>
		<p><code>Selection.property(name[, value])</code>用来修改/获取<code>attr</code>获取不到的属性值，如<code>text</code>区域的<code>value</code>，<code>checkbox</code>的<code>checked</code>属性或<code>__data__</code>等。使用方式同上。</p>
		<p><code>Selection.text([value])</code>用来获取修改选择集的文本值, 使用方式同上<code>。Selection.html([value])</code>用来获取<code>innerHTML</code>。区别在于前者基于<code>textContent</code>，后者基于<code>innerHTML</code>。</p>
		<p><code>Selection.append(name)</code>在当前元素后添加一个子元素作为选择集的最后一个结果。数据将继承当前元素。同样<code>name</code>接受返回DOM元素的函数，此时函数可以接受<code>datum</code>、<code>i</code>和<code>this</code>。<code>name</code>为<span class="i">string</span>时，将继承所在父空间的namespace。</p>
		<p><code>Selection.insert(name[, before])</code>在选择集中<code>before</code>选择的元素前插入元素。如果<code>before</code>未找到匹配，将在最后插入。<code>before</code>可以是选择器或返回DOM元素的函数。</p>
		<p><code>Selection.remove()</code>删除当前选择集。返回选择集本身，因此<strong>也可以链式调用</strong>。</p>
		<p>关于数据绑定，有<code>selection.data([values[, key])</code>, values可以是数组或是返回数组的函数。在<code>key</code>未指定时，<code>values</code>和<code>selection</code>中的元素一一对应。在绑定后写入在元素的<code>__data__</code> property中。函数返回<code>update</code>选择集。提供了<code>enter</code>和<code>exit</code>方法获取<code>enter</code>和<code>exit</code>选择集。<code>key</code>参数规定了<code>values</code>和<code>selection</code>元素的绑定方式，具体参见<a href="https://github.com/d3/d3/wiki/Selections" target="_blank">wiki</a>。<code>data</code>方法不能用来清除已有的绑定数据。通过<code>Selection.merge(name)</code>和已知<code>selection</code>合并。</p>
		<p><code>Selection.datum([value])</code>设置或获取绑定数据，简化版的<code>data</code>方法。可以理解成上文中<code>property</code>方法的子集。由于没有绑定过程，因此也没有<code>enter</code>和<code>exit</code>选择集。<code>value</code>可以接受常量或是函数，用法类似其他使用<code>value</code>的方法。它还能和W3C的<code>dataset</code>属性互动。和<code>data</code>不同的是，<code>datum</code>绑定为元素们绑定相同的数据，且新插入的元素也会具有相同的<code>datum</code>。而<code>data</code>则是将数组中的各元素一一绑定在一个个元素上。</p>
		<p><code>Selection.enter()</code>返回<code>enter</code>选择集：未和<code>data</code>匹配的占位符。只定义在<code>update</code>选择集后，其后只能跟<code>append, insert, select</code>和<code>call</code>方法，用在数据较多时，通常添加元素并赋予属性值。<code>Selection.exit()</code>返回<code>exit</code>选择集：未和<code>data</code>匹配的节点，其后可以跟普通的操作方法，但通常使用<code>remove()</code>删除多余元素。两者相互对应。</p>
		<p><strong><i>注：<code>update, enter</code>和<code>exit</code>和选择集是较难理解的一部分。这些概念出现在绑定数据时，<code>update</code>记录更新的选择集，<code>enter</code>和<code>exit</code>分别用于两者并不等量的情况。Ourd3js中的图会起到帮助理解的作用。应用模板的介绍参见<a href="http://www.ourd3js.com/wordpress/?p=841" target="_blank">教程</a></i></strong></p></h4>
		<p><code>Selection.filter(selector)</code>用来过滤选择集，同上面的函数，<code>selector</code>除了选择符外还可以是返回DOM节点的函数，函数接受<code>d</code>和<code>i</code>两个参数，<code>this</code>表示当前DOM节点。</p>
		<p><code>Selection.sort([comparator])</code>，根据<code>comparator</code>函数排序选择集，再重新插入到文档的元素中，并返回新的选择集。排序非稳定。<code>Selection.order()</code>可以迅速按照<code>order</code>重排元素。</p>
		<p><code>Selection.on(type[, listener[, capture]])</code>用法和jquery类似，<code>listener</code>为函数，可以接受<code>datum</code>及<code>index</code>两个参数并使用<code>this</code>。其余的还有<code>d3.event</code> <code>d3.mouse(container)</code> <code>d3.touch(container[, touches], id)</code> <code>d3.touches</code>事件可以利用。通过这个方法，可以为d3创建的图表添加交互式操作。</p>
		<p><code>Selection.transition([name])</code>开启一个渐变过程，使得上面的这些操作能够有渐变效果。关于<code>transition</code>更多选项见<a href="https://github.com/d3/d3/wiki/Transitions" target="_blank">API的transition</a>部分。<code>Selection.interrupt([name])</code>可以立即停止一个渐变，没有<code>name</code>时会停止当前渐变。</p>
		<p>最后<code>selection.each(fucntion)</code>和<code>selection.call(function[, args])</code>分别对选择集每个元素操作和调用特定函数对选择集处理。<code>Selection.empty(), Selection.node(), Selection.size()</code>返回选择集的一些性质。</p>
		<h3 id="d3_scale">比例尺API</h3>
		<p>比例尺常用在d3制图当中，在d3的v3.x版本中，位于scale子模块内，在v4.0版本中抽离了出来作为单独模块使用。D3中的比例尺有连续比例尺、序列比例尺、临界比例尺、分位数比例尺、量化比例尺与序数比例尺。这些比例尺都有定义域和值域分别称为<code>domain</code>和<code>range</code>。使用时指定两者的范围便可得到映射关系。而以上的比例尺则是根据定义域和值域类型区分的。</p>
		<p>线性比例尺将连续区间映射到另一连续区间。通过<code>d3.scale.linear()</code>初始化，在4.0中通过<code>scaleLinear()</code>初始化，链式定义<code>domain([numbers])</code>，<code>range([numbers])</code>即可。<code>linear(x)</code>得到y，<code>linear.invert(y)</code>可以得到x。<code>tick([count])</code>设置刻度数，默认为<code>10</code>，<code>tickFormat(count, [format])</code>设置刻度格式。注意，定义域和值域都可以定义成多段，类似于分段函数。<code>d3.max</code>和对<code>d3.min</code>方法分别可以计算数组内的最大/小元素。</p>
		<p>其他的比例尺还有<code>identity()</code>恒等比例尺，<code>domain</code>和<code>range</code>永远一致，且默认值为<code>[0, 1]</code>，类似于恒等变换。<code>pow()</code>和<code>log()</code>也是两种特殊的连续比例尺，即指数和对数变换，用法与<code>linear</code>一致。time比例尺是v4.0中新的比例尺，是以时间为定义域的连续比例尺。</p>
		<p>序数比例尺的定义域是离散的。类似<code>linear()</code>，有<code>domain</code>和<code>range</code>方法。同时还有<code>rangePoints</code>, <code>rangeRoundPoints</code>, <code>rangeBands</code>, <code>rangeRoundBands</code>这些<code>range</code>的替代方法修饰输出的比例尺。这些在v4.0中分别作为了独立的比例尺类型。</p>
		<p>其余的比例尺还有<code>quantize()</code>，定义域是连续的，值域是离散的。根据值域等比例划分定义域，有<code>domain</code>, <code>range</code>, <code>invert</code>等方法。其他的比例尺还有和<code>quantize</code>很像的<code>quantile</code>以及<code>threshold</code>比例尺。具体见文档。V4.0中还有序列比例尺，它的range是根据插值器写死的且不可配置，利用已有的颜色插值器可以生成超酷的颜色比例尺。具体见<code>d3-scale-chromatic</code>。</p>
		<p>这些比例尺都有<code>copy</code>方法，方便地复制给其他比例尺变量。</p>
		<h3 id="d3_axis">坐标轴API</h3>
		<p>V3.x中作为svg的一个组件，V4.0中提出为单独组件。<code>d3.svg.axis()</code>创建一个默认的轴，在V4.0中可以直接使用<code>d3.axis()</code>。定义后通过<code>axis(selection)</code>绑定在<code>svg</code>或是<code>g</code>元素上，通常采用<code>.append(g).attr(transform ,translate(x,y)).call(axis)</code>的形式使用。</p>
		<p><code>axis.scale([scale])</code>方法设置比例尺，从而将刻度与实际长度对应。<code>axis.orient([orientation])</code>选择坐标轴方向和刻度方向，默认为<code>bottom</code>。<code>axis.tick([args])</code>方法指定刻度属性，参数将传递给<code>scale.tick()</code>方法生成刻度值。<code>axis.tickValues([values])</code>设置/获取刻度值。<code>axis.tickSize([inner, outer])</code>设置内外部刻度尺寸。另外外有<code>tickPadding</code>, <code>tickFormat</code>等方法。V4.0中直接通过<code>d3.axisTop, d3.axisRight, d3.Bottom, d3.Left</code>设置方向</p>
		<h3 id="d3_transition">渐变API</h3>
		<pD3通过<code>transition()和<code>ease()</code>完成渐变和动画效果。在V3.x版本中主要由<code>transition()</code>完成渐变，<code>ease</code>模块添加于4.0版本。渐变通过<code>d3.transiton([selection], [name])</code>或者<code>selection.transition()</code>初始化，以后者为主。方法返回<code>transition</code>对象，并启动过渡。<code>transition.duration([duration])</code>指定过渡时间，<code>ease([value[, args]])</code>方法指定过渡方式，<code>delay([dalay])</code>方法指定延迟时间。<code>ease</code>方法常用的有<code>linear, circle, elastic, bounce, cubic, exp, poly(k), sin</code>等缓动函数。V4.0版本中，ease单独拿出来作为了一个模块，有更丰富的用法，可参加V4.0 API文档。></p>
		<p><code>transition</code>后还可以跟<code>attr</code>, <code>style</code>, <code>text</code>方法做缓动变化。<code>tween</code>方法介绍见API文档，这里从略。<code>transition</code>中同样可以通过子选择集创建子过渡，也有类似于<code>selection</code> 的<code>each, empty, node, size, call</code>等方法。</p>
		<p><strong>注：<code>transition</code>在使用时和<code>selection</code>有很大相似之处。但实际上，两者类型不同，<code>selection</code>对应d3的选择集对象，<code>transition</code>对应d3中的渐变对象。如<code>on</code>方法可以跟在<code>selection</code>后却不能更在<code>transition</code>后。另外，<code>transition</code>可以通过<code>selection.transtion()</code>方法获取。</strong></p>
		<h3 id="d3_layout">布局API & 形状API</h3>
		<p>布局API起到将数据转换为用于绘图的关键作用。它更适合那些希望有更开放设计空间而不仅是利用Highcharts或是Echarts的用户。D3的V3.x版本的layout模块里提供了12个基本布局：饼图，力导向图，弦图，树状图，集群图，捆图，打包图，直方图，分区图，堆栈图，矩阵树图，层级图。其中层级图不能直接用来使用。它们的作用是将数据转成更适合这些图展示的新的数据。V4.0中这些子类型图都独立出来作为单独模块。这些图的样子可以参见官网<a href="http://d3js.org" target="_blank">d3js.org</a>。</p>
		<p>布局API输出的是格式化后的用户数据，还需要svg的部件形状AP来画出图形。部件的各部分同样在V4.0中抽出独立。有<code>arc, area, chord, diagonal, line, symbol</code>等几种帮助用户轻松画出svg中复杂的<code>&lt;path></code>。</p>
		<h4 id="d3_pie">饼状图</h4>
		<p>饼图布局可以将数据转成有着起始和终结角度的弧，然后轻松地通过arc shape做出饼图。实际上可以直接通过<code>arc</code> shape完成这一功能。通过<code>d3.layout.pie()</code>完成布局初始化，之后由<code>pie(values[, index])</code>为饼图布局赋值。返回的每一个对象都有着<code>value, startAngle, endAngle, padAngle, data</code>5个属性。返回元素的排序和原数组一致。此外，<code>pie</5个属性。返回元素的排序和原数组一致。此外，<code>对象还有<code>value([accessor])</code>方法预处理数组数据，<code>sort([comparator])</code>方法为数据排序，保留原index，排序函数可以接受键值对，同时可以使用<code>d3.descending</code>和<code>d3.ascending</code>。另外<code>startAngle, endAngle</code>和<code>padAngle</code>方法可以获取/设置起始，终结，填充角度值。</p>
		<p>通过上面API得到的piedata通过弧生成器即可得到饼图各部分。<code>d3.svg.arc()</code>可以构造一个新的弧生成器，<code>arc.innerRadius([radius])</code>和<code>arc.outerRadius([radius])</code>及<code>cornerRadius([radius])</code> padRadius([radius])</code>分别设置内环，外环，边角半径，同样可以输入函数。<code>startAngle()</code>，<code>endAngle()</code>和<code>padAngle()</code>也是类似的道理。通过<code>centroid(args)</code>还可以得到产生弧的中心，便于插入文本描述。</p>
		<h4 id="d3_force">力导向图</h4>
		<p>力导向图是一种互动性很强的可视化图。这种图中，节点间用连线连接，连线长度几乎相等，且不相交。节点和连线间都有里的作用，这个力是根据节点和连线运动轨迹计算的。根据里的作用来不断计算节点和连线的轨迹，最终达到能量最低的稳定态。可以看到，很适合拓扑图，实际生活关系图等多对多关系的绘制。</p>
		<p>从上面描述可以知道，力导向图的数据由节点间的连接情况组成。同上节，需要用到layout中的force部件。force创建的布局是有状态的，所以对于给定的力导向布局，只能与单一数据集绑定。通过<code>d3.layout.force()</code>初始化力导向实例。有<code>links, nodes, size, friction, strength, distance, charge, gravity, theta, alpha</code>等参数可以定制。</p>
		<p>links()和nodes()分别用来导入节点和链路数据，导入后的节点多了<code>index</code>索引，<code>px py</code>记录上个位置，<code>x y</code>记录当前位置，<code>weight</code>记录节点权重。导入后的链路有<code>source</code>和<code>target</code>属性标注链接关系。<code>size([width, height])</code>用来确定力作用域的范围，力的中心为<code>[x/2, y/2]</code>。若节点无x和y属性，则会被初始化为<code>[0,x]</code>和<code>[0,y]</code>的上的随机值。<code>linkDistance([distance])</code>设置连线长度，可以传入函数，函数接受<code>link, i</code>两个参数。链路约束采用的力学模型不是弹簧式的，而更像弱位置约束。可以在<code>tick</code>方法中修改默认力学模型。<code>linkStrength([strength])</code>设置链路的坚硬程度，需在<code>[0,1]</code>之间，可以输入函数。<code>friction([f])</code>方法描述节点减速的快慢，需在<code>[0,1]</code>之间，越靠近1，节点越快停止运动。<code>charge([charge])</code>描述相互作用力的大小，可以输入函数，负值表示斥力，正值表示引力，可以根据场景选择。<code>chargeDistance()</code>设置力的作用距离，默认为无穷。<code>theta()</code>方法设置算法的准确度。<code>gravity()</code>方法设置作用域中心对节点的吸引力，越靠近中心越小。<code>alpha()</code>获取/设置当前能量，从而影响收敛程度。</p>
		<p><code>force.start()</code>方法启动力导向布局的仿真，并根据<code>alpha</code>的值逐步收敛并最终停止。<code>resume()</code>方法和<code>drag</code>动作会重新启动force仿真。<code>force.resume()</code>等同于<code>force.alpha(.1)</code>可以重新启动一个force仿真。<code>force.stop()</code>终止一个仿真。<code>force.tick()</code>进行一步force仿真。</p>
		<p><code>force.on(type, listener)</code>注册一个监听器。<code>force.drag()</code>可以通过<code>node.call()</code>的形式调用，并允许拖拽效果，在<code>dragstart</code>事件中设置<code>fixed</code>为<code>true</code>还可以拖拽后固定节点。范例如下：</p>
		<pre><code>var drag = force.drag()
    .on("dragstart",function(d,i){
        d.fixed = true; // true or false
    })	</code></pre>
		<h4 id="d3_chord">弦图</h3>
		<p>弦图可以用来描述两个节点间的联系和权重程度，且两点间的联系是有向的，非对称的。弦布局同弦形和弧形协同工作。通过<code>d3.layout.chord()</code>或<code>d3.chord()</code>初始化。</p>
		<p><code>chord.matrix([matrix])</code>指定用到的数据矩阵，V4.0中使用<code>chord([matrix])</code>实例化生成。<code>chord.padding([paddings])</code>指定不同组间的填充角度，可以为函数。<code>sortGroups()</code>方法使用指定函数为布局设定分组排列顺序。<code>sortSubgroups([comparator])</code>方法设定组内各列的排列顺序，<code>sortChords([comparator])</code>指定弦在Z轴上的堆叠顺序。<code>chords()</code>方法返回通过给定参数计算过的弦对象。<code>groups()</code>返回计算过的分组对象。<code>groups</code>为对象的数组，对象有<code>endAngle, index, startAngle, values</code>4个属性。Chord的元素有<code>source</code>和<code>target</code>两个属性，这两个属性也是对象类型，内部都有<code>endAngle, index, startAngle, subindex, value</code>这几个属性。在使用<code>layout.chord()</code>生成弦和边缘时，分别由arc生成器和chord生成器生成形状。同样，<strong>生成的<code>path</code>最好包裹在<code>&lt;g></code>标签内</strong>。</p>
		<p>在V4.0版本中，计算出的chords会交给<code>d3.ribbon</code>完成展示，且可以直接通过指定<code>startAngle, endAngle, radius</code>来绘制弦。</p>
		<h4 id="d3_cluster">集群图/树状图/矩阵树图</h4>
		<p>集群图用来表示包含和被包含的关系。如学科的细分，类的成员方法等。它会生成树状的结构，且树上每个叶子节点的深度相等。在层级结构上是较特殊的一种。通过<code>d3.layout.cluster()</code>初始化，V4.0中包含在<code>hierarchy</code>模块中，通过<code>d3.cluster()</code>初始化。相对上面的3种图，构造较为简单。可以通过简单地读取JSON格式数据构造。</p>
		<p><code>cluster(root)</code>构造cluster树状结构。<code>cluster.nodes</code>方法运行簇布局，返回节点数组。<code>links(nodes)</code>通过指定节点数组，返回节点间的关系。每个节点都是具有两个属性<code>source, target</code>的对象。<code>sort</code>方法可以指定节点的排序方法。<code>separation([separation])</code>使用指定函数节点间距，通常可以根据深度大小响应调整间距，如<code>return (a.parent == b.parent ? 1 : 2) / a.depth</code>。此外还有<code>size, nodesize, value</code>等方法。</p>
		<p>层级图中树枝的曲线绘制通常使用贝塞尔曲线，通过<code>d3.svg.diagonal()</code>构造。最经常用在node-link类型的图中。<code>diagonal(datum[, index])</code>根据<code>datum</code>返回<code>path</code>数据字符串。<code>diagonal.source/target([source/target])</code>分别用来设置曲线的起点和终点，且接受函数作为输入参数。<code>projection[projection]()</code>方法修改diagonal的映射方向，以返回<code>[x,y]</code>的函数作为输入参数。在V4.0版本中作为hierarchy的一部分，被移除。</p>
		<p>d3的请求API中提供了对JSON格式数据的请求。在集群图数据较复杂时（实际上其他类型的图也会遇到数据需要从外部导入的情况），通过<code>d3.json</code>引入外部文件也可以轻松生成图表。</p>
		<p>树状图和集群图一样从属于层级图(hierarchy)的范畴，区别在树状图的叶子结点深度不都相同。同样的有树布局<code>d3.layout.tree</code>。用法和<code>cluster</code>几乎完全一致。这里从略。</p>
		<p>矩阵树图是用大小矩形表示树的节点，并面积大小表示节点从属关系和重要性。<code>d3.layout.treemap()</code>提供矩阵树图布局构造。<code>links, children, value</code>方法设置布局如何读取链路/子节点/值信息。<code>sort</code>方法用作节点排序，<code>size</code>方法设置布局展示范围，<code>padding</code>设置矩形间隔，默认为<code>0</code>。<code>round</code>方法设置约成的像素数，减少锯齿出现。<code>sticky</code>方法可以使得矩阵树在变形时保持比例，<code>mode</code>方法用来设置矩阵树的布局模式。<code>ratio</code>设置矩形长宽比，默认为黄金比例。V4.0版本中，去掉了<code>round，sticky和mode</code>。通过<code>tile</code>方法设置矩阵树布局模式，且有更多模式可以选择。</p>
		<h4 id="d3_bundle">捆图</h4>
		<p>捆图几乎都是和其余布局一起使用的。用来计算节点见的路径。在V4.0版本中已经取消。V3.x中，捆图布局只有两个函数<code>d3.layout.bundle()</code>和<code>bundle(links)</code>。前者创建捆图布局，后者根据<code>links</code>数组的<code>source</code>和<code>target</code>计算路径。通常在使用时，通过集群图、打包图、分区图、树状图等等计算出节点位置，再用捆图计算连线路径。捆图需要的<code>links</code>数组可以通过其他布局的<code>links</code>方法轻松得到。</p>
		<h4 id="d3_pack">打包图</h4>
		<p>打包图用来表示包含和被包含的关系，同时通过大小表示相互的权重大小。通常用圆套圆的样子呈现。相较层级图更强调包含的关系。与它类似的还有treemap矩形树。将层级展开后，还可以用来创建气泡图。</p>
		<p>通过<code>d3.layout.pack()</code>构造，<code>pack(root)</code>实例化，<code>nodes</code>方法返回节点，<code>links</code>方法返回链路信息，<code>sort</code>方法用来为同级节点排序。这些方法和<code>cluster</code>及<code>tree</code>是很相似的。区别是<code>nodes</code>中多了<code>r</code>计算半径，<code>links</code>很少使用。<code>size</code>方法和<code>radius</code>分别设置展示范围和最小圆半径，<code>padding</code>指定相邻圈间的大概填充，默认为<code>0</code>。在V4.0中，改进了画图算法。</p>
		<h4 id="d3_partition">分区图</h4>
		<p>分区图用图形的面积和依附关系表示层级和层级间的从属关系。图形可以是矩形，圆环等等。通过<code>d3.layout.partition, d3.partition()</code>初始化分区布局，<code>partition(root)</code>加入数据，通过<code>partition.nodes(root), partition.link(root)</code>获取分区节点和分区链路。<code>partition.children()</code>设置孩子访问器。同其他布局，<code>partition</code>有<code>sort, value, size</code>等方法，分别用于设置是否排序，如何获取value和布局范围<code>[width, height]</code>。V4.0中将层级的通用方法放在<code>hierarchy</code>中，增添了<code>round([round]), padding([padding])</code>方法。</p>
		<p>在使用原型分区图的时候，可以通过<code>size()</code>方法和<code>arc</code>的<code>innerRaidus, outerRadius</code>方法巧妙实现。<code>size([Math.PI*2, radius*radius])</code>可以保证相同比重的区域面积相等。</p>
		<h4 id="d3_geo">地理图</h4>
		<p>地理图相较此前的图表要复杂许多。展示地图边界需要用到<code>GeoJSON</code>格式的数据，数据获取参见<a href="http://www.ourd3js.com/wordpress/?p=668" target="_blank">中文教程</a>。绘制地图需要投影函数，类似于我们之前介绍的布局，将3维的经纬度转成2维平面内的横纵坐标。<code>d3.geo.projection(raw)</code>可以自定义一个投影函数，不过通常都是使用现有的投影函数。通过<code>projection(location)</code>来映射位置，输入经纬度返回横纵坐标。Projection本身还提供了<code>invert, rotate, center([longtitude, latitude]), translate, scale([scale])</code>等方法，类似于比例尺。<code>clipAngle</code>和<code>clipExtent</code>方法会裁剪投影范围。</p>
		<p><code>geo</code>还提供了一些常见投影。<code>albers()</code>是<code>conicEqualArea()</code>投影的别名，默认以美国为中心，<code>albersUsa()</code>用来绘制美国地图，<code>azimuthalEqualArea()</code>方位角等面积投影(经纬线绘成的区域等面积)，<code>azimuthalEquildstant()</code>方位角等距投影(投影点到投影中心和到大弧距离等比例)。<code>ConicConformal()</code>兰伯特等角二次曲线投影地球为一个锥形，<code>parallels</code>方法可以设定投影的标准平行线为特定的二元纬度数组。<code>conicEqualArea()</code>是一个等区域的投影，保留了地理特征，它也有<code>parallels</code>方法。<code>conicEquidistant()</code>等距离的投影，同上。<code>equirectangle()</code>方法是正方形投影，经纬度类似光栅效果。<code>geoGnomonic()</code>方法是个方位角投影，它投射大圆（赤道）为直线，将半球投射在切平面上。<code>mercator()</code>是最常用的墨卡托投影，将经纬度投射在和地球相切或相割的圆柱体表面，有面积大小的失真。<code>orthographic()</code>投射点位于无穷远，用于投射半球，多用于卫星摄影。<code>。tereographic()</code>方法，立体投影。<code>transverseMercator()</code>方法是横向墨卡托投影。另外通过<code>d3.geoProjection</code>和<code>d3.geoProject-ionMutator</code>方法可以设置和修改自定义的projection。</p>
		<p>显示地理数据需要用到<code>d3.geo.path</code>。它通过读入GeoJSON数据，生成SVG字符串或直接渲染在<span class="i">Canvas</span>上（V4.0）。<code>d3.geo.path()</code>可以创建一个地理路径生成器。<code>path</code>的<code>projection</code>方法指定投影类型，除了上述的投影函数，还可以自定义接受经纬度返回横纵坐标的函数。<code>path(object[, args])</code>可以生成标点，多标点，边缘，多边形，地理对象，特写等许多地理对象。椭圆类型也支持，以用来绘制球形轮廓。<code>path</code>对象有许多方法，<code>area(object)</code>计算区域面积，<code>bounds(object)</code>返回区域盒模型区域，<code>centroid(object)</code>返回区域中心，多用来插入文本。<code>path.context([context])</code>指定<code>path</code>渲染内容，<code>context</code>必须实现一些<code>CanvasRenderingContext2D</code>的方法。<code>path.pointRadius([radius])</code>设置标点的半径。</p>
		<p>还有一些常用的<code>geo</code>绘图对象，如<code>circle</code>，V4.0中通过<code>geoCircle()</code>构造，有<code>center, raidus, precision</code>几种方法，分别制定圆心位置，半径和精确度。<code>graticule</code>对象用来绘制经纬线的网格图，表现出投影的转换。通过<code>geoGraticule()</code>（同样是V4.0中），<code>extent, extentMajor</code>和<code>extentMinor</code>方法设置网格范围。<code>step</code>设置步长，同样有<code>stepMajor</code>和<code>stepMinor</code>两种方法，<code>precision</code>方法设置精度。<code>graticule</code>的<code>lines()</code>方法给出线型<span class="i">GeoJSON</span>数组，数组各项对应每一条经纬线，<code>outline()</code>方法给出整个网格图的<span class="i">GeoJSON</span>多边形对象。</p>
		<p><span class="i">GeoJSON</span>是一项国际标准，用来编码大量地理数据。<span class="i">GeoJSON</span>支持点、线、多边形、多点、多多边形几种地理形状。整个内容用<code>FeatureCollection</code>包裹起来。<code>type</code>中指定<code>featureColelction</code>，在<code>features</code>字段中加入地理对象，每个地理对象由<code>type, geometry, properties</code>几部分组成，分别表示类型，地理信息和额外信息。<code>geometry</code>里<code>type</code>和<code>coordinates</code>分别表明类型和系列点。<span class="i">TopoJSON</span>对<span class="i">GeoJSON</span>规范做了简化，如使用整数等，在D3中使用<span class="i">TopoJSON</span>较多。</p>
		<p><strong>注：<a href="http://mapshaper.org/" target="_blank">mapshaper</a>可以帮助简化<span class="i">GeoTopo</span>文件，做<span class="i">GeoJSON</span>和<span class="i">TopoJSON</span>间的转换</strong></p>
		<h4 id="d3_histogram">直方图</h4>
		<p>直方图多用来可视化离散的序列数据，或用来描述分布。通过<code>d3.layout.histogram()</code>构造，<code>histogram(data)</code>初始化，它将数据装在一个个组中(bin)，容器有<code>x0</code>和<code>x1</code>两个属性确定容器的上限和下限。<code>value([value])</code>方法用于设置<code>value</code>域的预处理器，类似之前提到的各图的布局。<code>domain([domain])</code>方法用来限制输入数据的范围，<code>thresholds([count])</code>用来设置分组的界限。此外，还有一些预设方法将值组织在各组中。V3.x中，通过<code>range</code>方法限制输入范围，通过<code>bins</code>方法设置分组数/界限，且有<code>frequency</code>方法指定统计个数或是概率。</p>
		<h4 id="d3_stack">堆栈图</h4>
		<p>堆栈图用于描述多组数据的堆叠变化（连续和离散），如产品间随时间变化的销量组成展示。通过<code>d3.layout.stack()</code>构造布局，<code>stack(layers[, index])</code>读入堆叠数据，生成的布局有<code>x, y, y0</code>三个属性。<code>values([accessor])</code>方法设定获取值的方法，<code>offset([offset])</code>方法设置生成布局的方式，<code>order([order])</code>指定堆栈排序方法。<code>x([accessor])和y([accessor])</code>方法设置x和y轴的数据来源。V4.0中将<code>x</code>和<code>y</code>方法替换成了<code>keys</code>方法。</p>
		<h3 id="d3_xhr">请求API</h3>
		<p>对于小数据集，可以将它硬编码到脚本内，或通过数据属性嵌入到DOM中。对于大数据集，最常用的方法是通过<code>XMLHttpRequest(XHR)</code>加载数据到浏览器，这允许异步加载数据，比<span class="i">JSONP</span>更方便。d3的请求API就建立在<span class="i">XHR</span>的基础上。</p>
		<p><code>d3.xhr(url[, mimetype][, callback])</code>是通用的构造方法，还可以通过<code>header</code>方法，<code>mimeType</code>方法，<code>responseType</code>方法等设置请求属性。<code>send(method[ ,data][, callback])</code>方法使用指定方法分发请求，在get和post时有专门的<code>get</code>和<code>post</code>方法。此外<code>abort</code>方法中止请求，<code>on</code>方法监听<code>beforesend, progress, load</code>和<code>error</code>事件。V4.0中，xhr部分更名为request。</p>
		<p>特殊情况下，d3有许多简便方法。<code>d3.text(url[, mimetype][, callback])</code>用来创建文本文件请求，请求以<code>GET</code>方法立即分发。<code>callback</code>中可以使用<code>error</code>和<code>response</code>文本，下同。<code>d3.json(url[, callback])</code>通过制定url创建JSON请求。<code>d3.xml, d3.html, d3.csv, d3.tsv</code>也是一样的情况。tsv的<code>mimeType</code>为<code>text/tab-separated-values</code>。</p>
		<h3 id="d3_random">随机数API</h3>
		<p>d3提供了产生特定分布随机数的若干API。包括<code>d3.random.uniform</code>等。<code>uniform</code>方法产生均匀分布随机数，<code>normal</code>方法产生正态分布规律的随机数，<code>bates, irwinHall, logNormal</code>方法分别产生贝兹分布、<span class="i">Irwin-Hall</span>分布和对数正态分布规律的随机数。使用时，先通过这些方法构造生成函数，再使用函数产生随机数。</p>
		<h3 id="d3_behavior">行为API</h3>
		<p>V3.x和V4.0的行为(Behavior)包括两种，<code>drag</code>和<code>zoom</code>。在V4.0中分别拆分成<code>dragging</code>和<code>zooming</code>两部分。drag行为通过<code>d3.behavior.drag()</code>注册，可以通过<code>selection.call(drag)</code>来为选择集绑定拖拽行为。通过<code>drag.on(type[, listener])</code>监听<code>dragstart, drag, dragend</code>三种事件，drag事件可以提供行为的<code>x</code>和<code>y</code>坐标及<code>dx, dy</code>改变量。<code>d3.origin([origin])</code>方法设置drag行为的原位置accessor。绑定drag行为的元素的一些native事件会被阻止，如<code>click, mousemove</code>等等。</p>
		<p>V4.0中的<code>container()</code>方法可以指定拖拽的容器，从而影响<code>event.x</code>等。<code>filter([filter])</code>方法指定阻止和不阻止的事件。同时，<code>origin()</code>方法改为<code>subject()</code>方法设置被拖动元素的种种属性。drag事件有<code>target, type, subject, x, y, dx, dy, identifier, active, sourceEvent</code>属性可以使用。</p>
		<p>zoom行为由<code>d3.behavior.zoom()</code>来构造，通过<code>translate()</code>设置位置，<code>scale()</code>方法指定当前缩放比例，<code>scaleExtent()</code>方法指定缩放比例范围，<code>center([center])</code>手动指定缩放中心，<code>size([size])</code>设定观察尺寸，<code>x([x])</code>和<code>y([y])</code>方法分别设置x和y方向上的缩放比例。类似于drag，zoom可以监听的事件有<code>zoomstart, zoom</code>和<code>zoomend</code>，还可以通过<code>zoom.event(selection)</code>在选择集上触发zoom事件。V4.0中添加了<code>scaleBy, translateBy, extent</code>等方法，<code>zoom event</code>提供<code>translate</code>和<code>scale</code>两个属性供用户使用(V3.x)，V4.0中提供<code>target，type，transform，sourceEvent</code>四个属性。</p>
		<h3 id="d3_color">颜色API</h3>
		<p>颜色是可视化中必不可少的一部分。也是d3模块中的重要组成部分之一。D3提供多种颜色空间的表示，包括<strong><span class="i">RGB</span>，<span class="i">HSL</span>，<span class="i">LAB</span>和<span class="i">HCL</span></strong>，并可以实现格式的转换和颜色的操作。<code>d3.color(specifier)</code>可以根据css样式构造d3颜色类型。<code>color.rgb()</code>返回rgb格式颜色对象，<code>color.toString()</code>返回颜色对象的css格式。另外V3.x中，<code>color</code>对象的<code>brighter, darker</code>方法应用在rgb，hsl，hcl，lab中。V4.0版本中，<code>color</code>对象还有<code>opacity()</code>和<code>displayable()</code>方法返回颜色透明度和硬件是否支持。同时，<span class="i"><strong>cubehelix</strong></span>格式的颜色也在4.0版本中支持。</p>
		<p>实际使用时，颜色插值器<code>interpolate</code>也回应常用到来获取两个颜色中间的某个值。<code>d3.interpolateRgb()</code>和<code>d3.interpolateHsl()</code>分别处理rgb和hsl的插值计算。<code>interpolate()</code>可以处理树枝和字符串间的插值。使用时，先通过<code>interpolate(a, b)</code>构造一个插值器函数，函数的定义域为<code>[0,1]</code>，从而通过不同的输入参数获得不同中间值。</p>
		<h3 id="d3_more">更多</h3>
		<p>除了上面提到的官方wiki和<a href="https://github.com/d3/d3/wiki/API--中文手册" target="_blank">中文手册</a>，还有作者本人写的种种<a href="http://bl.ocks.org/mbostock" target="_blank">演示实例</a>，在关于D3.js在国内还没有很权威的入门教程，<a href="http://www.ourd3js.com/wordpress/?cat=2" target="_blank">ourd3js</a>算是写的比较好的d3入门和进阶教程了，在里面还有许多有助于d3学习的其他网站。</p>
		<hr>
		<h1 id="sass">Sass</h1>
		<p>Sass是一种适合程序员使用的CSS预处理器。它预先约定了许多CSS的书写手法，为之赋予了可编程的能力。Sass使用<span class="i">Ruby</span>语言实现，安装使用时需要预装<span class="i">ruby</span>和g<span class="i">em</span>，再通过<code>gem install sass</code>安装Sass。Sass可以将<code>.scss</code>文件编译成普通的CSS文件。</p>
		<p>编译时，<code>--style</code>选项可以指定<code>nested，expanded，compact，compressed</code>几种风格，默认为<code>nested</code>，在生产环境下一般使用<code>compressed</code>。<code>--watch</code>选项可以监听<code>.scss</code>文件，在源文件改动时。自动编译成css文件。</p>
		<p><strong>注意：Sass可以编译后缀名为<code>.scss</code>和<code>.sass</code>两种css文件，两者的格式是不同的。前者更像传统的CSS，使用大括号区分层级；后者使用缩进，且不使用分号。具体可以见<a href="http://sass-lang.com/documentation/file.INDENTED_SYNTAX.html" target="_blank">参考</a>。</strong></p>
		<h3 id="sass_rule">约定</h3>
		<p>Sass自带交互shell，通过在命令行输入<code>sass –i</code>进入，便于开发者进行测试。</p>
		<p>Sass中使用<code>/**/</code> <code>//</code>来注释，其中单行注释会在编译时移除。Sass允许使用变量，变量以$符号开头，使用时也需带上<code>$</code>。变量有number (<code>1, 2px</code>)，string (<code>"foo", 'bar', baz</code>)，color (<code>blue, #123456, rgba(0,0,0,255)</code>)，bool (<code>true, false</code>)，null (<code>null</code>)，list (<code>1em 0em 1.5em, Arial sans-serif serif</code>)，map ( <code>(key1: value1, key2: value2)</code> )几种类型。为变量赋值时，支持使用<code>!default</code>表示默认值。在变量名中甚至可以通过<code>#{…}</code>的形式嵌入变量名（这点像<span class="i">PHP</span>）。Sass允许在代码中使用算式和嵌套。在嵌套时，还可以使用<code>&</code>算符表示父元素。</p>
		<pre><code>$var = 2;
$hover = #0f0;
$fonts = Arial sans-serif;
div {
    font-family: $fonts;
    h1 {
        color: red;
        right: $var * 10%;
    }
    &:hover {
        color: $hover;
    }
}
</code></pre>
		<p>Sass一大精髓就在于代码重用上。使用<code>@extend</code>可以继承某个选择器的样式，使用<code>@mixin</code>定义css中的mixin（类似于函数），通过<code>@include</code>使用定义好的mixin，更加灵活的是mixin支持输入参数。类似的<code>@</code>规则还有<code>@import</code>引入sass或是css文件，<code>@media</code>表示当前媒体，它们都支持嵌套。<code>@at-root，@debug，@warn，@error</code>等参见<a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#directives" target="_blank">文档介绍</a>。</p>
		<pre><code>@mixin rounded($vert, $horz, $radius: 10px) {
border-#{$vert}-#{$horz}-radius: $radius;
-moz-border-radius-#{$vert}#{$horz}: $radius;
-webkit-border-#{$vert}-#{$horz}-radius: $radius;
}

.class1 {
    border: 1px solid #ddd;
}

.class2 {
    @extend .class1;
    font-size: 12px;
}

#navbar li {
    @include rounded(top, left);
}
#footer {
    @include rounded(top, left, 5px);
}
</code></pre>
		<p>另外，Sass还自带语法控制结构（<a href="https://css-tricks.com/sass-vs-less/" target="_blank">有人认为</a>这是它强于less的一点）。<code>@if，@else</code>用于判断，<code>@for，@while，@each</code>用于循环。用法如下：</p>
		<pre><code class="scss">$type: monster;
$i: 6;
p {
    @if $type == ocean {
        color: blue;
    } @else if $type == monster {
        color: green;
    } @else {
        color: red;
    }
}
//使用to也可以
@for $i from 1 through 3 {
    .item-#{$i} { width: 2em * $i; }
}
@each $animal in puma, sea-slug, egret, salamander {
    .#{$animal}-icon {
        background-image: url('/images/#{$animal}.png');
    }
}
@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
    #{$header} {
        font-size: $size;
    }
}
@while $i > 0 {
    .item-#{$i} { width: 2em * $i; }
    $i: $i - 2;
}
</code></pre>
		<p>最后，Sass还支持数量繁多的<a href="http://sass-lang.com/documentation/Sass/Script/Functions.html" target="_blank">预定义函数</a>和用户<a href="http://sass-lang.com/documentation/Sass/Script/Functions.html#declare-class_method" target="_blank">自定义函数</a>。如颜色函数<code>lighten(), darken(), grayscale(), complement(), opacity()</code>, 字符串函数，数字函数，<code>list</code>函数等等</p>
		<pre><code class="scss">lighten(#cc3, 10%) // #d6d65c
darken(#cc3, 10%) // #a3a329
grayscale(#cc3) // #808080
complement(#cc3) // #33c

@function double($n) {
    @return $n * 2;
}
#sidebar {
    width: double(5px);
}
</code></pre>
		<h3 id="compass">Compass</h3>
		<p><span class="i">Compass</span>是建立在Sass之上的一个工具包。它和Sass的关系相当于<span class="i">jQuery</span>和<span class="i">Javascript</span>，<span class="i">Rails</span>和<span class="i">Ruby</span>，<span class="i">Django</span>和<span class="i">Python</span>，<span class="i">express</span>和<span class="i">nodejs</span>，是Sass的一个重量级的应用。<span class="i">Compass</span>封装了常用的各种模板，使得在Sass的基础上开发CSS效率大大提高。</p>
		<p>Compass也是通过<code>gem install</code>来安装，安装完成后通过<code>compass create project</code>创建工程，文件夹下包括配置文件<span class="i">config.rb</span>，和<span class="i">scss，stylesheet</span>两个子文件夹。Scss文件编辑完成后，使用<code>compass compile</code>编译，还可以通过<code>output_style，force</code>等参数修饰，<span class="i">Compass</span>也有<code>watch</code>命令。</p>
		<p>Compass将css设计中最常用以及最繁琐的部分通过预设的模块尽量封装了起来。包括reset，css3，layout，typography，utilities以及一些额外的helper函数。</p>
		<p>不过，由于Compass的功能和<span class="i">bootstrap</span>这种css库功能有重叠（不过是更加开放灵活，且和Ruby绑定而已），让人犹豫它的定位。Compass自2014年起不再维护。</p>
		<hr>
		<h1 id="es2015">ES6新特性</h1>
		<p><span class="i">ECMAscript</span>2015年5月份发布了第六版新标准。引入了一些更加方便的操作方式和一些突破性的新概念。以下是ES6的一些新特性。</p>
		<p><code>let</code>用于在代码块中声明临时变量。尤其在for循环中最为常用。<code>const</code>用来声明常量，具有块级作用域。不能重复声明，复制无效。</p>
		<br>
		<p><code>includes()</code>返回是否查到子串，<code>startsWith()</code>返回子串是否在开头，<code>endsWith()</code>返回是否在结尾。string对象新添加<code>repeat</code>函数，返回原字符串重复n次的结果。</p>
		<p>支持在字符串中使用模板，以<code>${}</code>的形式添加。类似C++中的格式化字符串。模板字符串可以支持多行。<code>tag</code>函数处理标签模板，将模板字符串分解成数组的形式。<code>string.raw</code>作为模板开头，可以使模板字符串“无视”特殊字符。</p>
		<br>
		<p><code>isNaN</code>和<code>isFinite</code>函数判断是否为数字和是否无穷。<code>isInteger()</code>判断一个值是否为整数。</p>
		<p><code>Math</code>新增静态方法。<code>trunc()</code>除去小数部分，<code>sign()</code>判断是正数、负数或0，<code>cbrt()</code>计算立方根，<code>hypot()</code>返回参数平方和的平均数等等。<code>Expm1</code>返回e<sup>x</sup>-1，<code>log1p</code>返回x+1的自然对数，<code>log10</code>，<code>log2</code>类似。还有<code>sinh, cosh, tanh, asinh, acsh, atanh</code>等三角函数方法。</p>
		<br>
		<p><code>Array</code>新增<code>from</code>方法，支持从类数组对象和可遍历对象中创建数组，可接受第二个参数，作用类似于数组<code>map</code>方法。可用于计算含有长编码字符的字符串。实际上，有<code>length</code>属性的对象都可以通过该方法转为数组。新增<code>of</code>方法，弥补<code>Array()</code>构造函数的不足。为输入的值创建数组</p>
		<p>新增<code>find</code>和<code>findIndex</code>方法，输入参数为回调函数，分别返回第一个true的成员与其<code>index</code>。<code>fill</code>方法用于使用给定值填充数组，接受第二和第三个参数，指定填充范围。</p>
		<p><code>entries(), keys(), values()</code>分别返回键值对，键名，键值的迭代器。类似于C++的<code>iterator</code>。</p>
		<br>
		<p>在写入变量或函数到对象的属性或方法时，允许省去键名。属性名允许使用中括号加表达式的方式定义，可以用在大括号的方式定义对象中。如<code>var obj = {[1 + 2]: 3};</code></p>
		<p><code>Object</code>新增<code>is</code>方法，作用类似<code>===</code>。不同的是<code>+0</code>和<code>-0</code>是不等的，<code>NaN</code>和<code>NaN</code>是相等的。新增<code>assign</code>方法，可以将<code>source</code>所有可枚举属性赋值到<code>target</code>中，<code>source</code>和<code>target</code>必须都为对象。第一个参数为目标对象，后面的参数都是源对象，同名属性会被覆盖。</p>
		<br>
		<p><code>Symbol</code>类型是一种原始数据类型，表示独一无二的ID。不可以与其他类型值运算，可以转为字符串，通过<code>Symbol()</code>初始化。可以加输入参数对Symbol进行描述。</p>
		<br>
		<p><code>proxy</code>对象用来为一些基础操作定义用户自定义行为。<code>target</code>作为被代理的对象，不可拓展性和不可修改属性的不变量会被代理<code>handler</code>拦截。使用<code>proxy</code>可以做无操作转发，默认值设置、验证处理等。<code>handler</code>对象有许多方法可以使用。</p>
		<br>
		<p>函数新增默认值，使用类似C++，Java。函数的输入参数可以用<code>...values</code>表示剩下的所有不定参数。这些不定参数将组成数组储存在<code>values</code>中。类似的，拓展运算符…支持向函数输入参数组成的数组</p>
		<p>箭头函数是使用<code>=></code>语法的函数简写体。和C#, Java 8, CoffeScript类似。同时支持表达式体和语句体。用法：<code>v=>v+1, (v, i) =>{v += I;};</code><strong>箭头函数的<code>this</code>对象与其上下文代码共享</strong>。这一点与函数体不同。同时，箭头函数不可以当作构造对象，也不能使用<code>arguments</code>对象。</p>
		<p>函数绑定运算符，<code>::</code>作用和<code>bind</code>类似，将左边的对象作为上下文环境绑定到右边的函数上去。<code>let log = ::console.log</code>等同于<code>var log = console.log.bind(console)</code>.</p>
		<p>尾调用优化。当函数最后一步操作为调用另一函数时，称为尾调用。尾调用优化即只保留内层函数的调用帧，删除外层函数调用帧节省内存。</p>
		<br>
		<p>数据结构<code>Set</code>是成员唯一的数组。可以使用<code>array</code>来初始化，如<code>new Set(array). size</code>方法可以返回当前<code>set</code>集合元素总数。有<code>add, delete, has, clear</code>完成增删改查的工作。<code>Set</code>可以通过<code>array</code>的<code>from</code>方法转为数组。<code>keys, values, entries, forEach</code>方法用于遍历成员。</p>
		<p><code>WeakSet</code>是弱化版的<code>Set</code>。成员只能是对象。只有<code>add, delete, has</code>方法。没有<code>size</code>属性，也不能使用<code>forEach</code>遍历成员。</p>
		<p>数据结构<code>Map</code>是无序数对组成的集合。方法与<code>Set</code>类似。有<code>size, set, get, has, delete, clear</code>等用法。其中<code>set</code>用法返回自身因此可以链式调用。<code>Map</code>同样有<code>WeakMap</code>子对象。它只接受对象作为键名，键名所指向的对象不计入垃圾回收机制。只有<code>get, set, has, delete</code>方法可以使用，</p>
		<br>
		<p>迭代器对象。和C++中的迭代器类似。它为各种可迭代的数据结构提供一个简便的同意的接口。同时可以在<code>for of</code>循环中使用。<code>next</code>方法返回<code>value</code>和<code>done</code>两种信息。可迭代数据结构都必须事先名为<code>Symbol.iterator</code>的方法，位于<code>Symbol.iterator</code>属性上面。调用该属性就可得到遍历器。有些操作会隐式调用<code>iterator</code>接口。如拓展运算符<code>...</code>, Array.from()</code>等。可以通过修改<code>Symbol.iterator</code>属性改变原生具备该接口的数据结构的迭代表现。对了<code>next</code>方法外，迭代器对象还可以部署<code>return</code>方法，用于在循环退出前，进行注入释放资源等操作。<code>for of</code>循环等价于<code>for in</code>循环的迭代器版。</p>
		<p>函数生成器<code>Generator</code>，用于遍历函数的内部状态。形式上<code>Generator</code>函数是个普通函数，不过function命令与函数名间有<code>*</code>符号。函数体内使用<code>yield</code>语句定义不同内部状态。其余同<code>iterator</code>，有<code>next</code>方法，返回具有<code>value</code>和<code>done</code>字段的数组。<code>yield</code>后面不仅可以跟数据，还可以跟代码片段。yield语句本身并没有返回值，可以通过<code>next</code>函数输入作为其返回值。<code>for of</code>循环同样可以用来遍历<code>Generator</code>函数。<code>throw</code>方法用来捕获函数体外错误。</p>
		<br>
		<p><code>Promise</code>对象用来传递异步操作信息。状态不受外界影响，有<code>pending, resolved, rejected</code>三种状态。只有操作结果会影响这个状态，这个对象便于控制异步操作。用法为先通过构造函数创建异步操作块。通过<code>resolve</code>和<code>reject</code>将操作结果传递给<code>promise</code>使用<code>then</code>绑定的处理函数。<code>then</code>方法返回的是一个新的<code>Promise</code>实例，因此支持链式调用。<code>catch</code>方法是<code>then</code>方法的特例，用于捕获异常。</p>
		<p><code>Promise</code>的<code>all</code>方法将多个<code>Promise</code>实例封装成1个，实例都通过才算通过。<code>race</code>方法根据第一个改变状态的<code>Promise</code>实例做判断。<code>resolve</code>方法可以将现有对象转为<code>Promise</code>对象，不具有<code>then</code>方法的对象，则返回一个状态为<code>resolved</code>的<code>Promise</code>对象。<code>reject</code>方法类似，不过实例状态为<code>rejected</code>。</p>
		<p><code>async</code>函数是对<code>Generator</code>函数的改进，内置执行器，使用<code>await</code>代替<code>yield</code>，语义清晰，且之后可以跟Promise和原始类型的值。</p>
		<br>
		<p><code>Class</code>是ES6提供的更靠近传统语言的写法。<code>Class</code>之间可以通过<code>extends</code>实现继承，但在构造函数必须调用<code>super</code>方法。内部可以使用<code>get</code>和<code>set</code>关键字对属性设置读写函数。同时<code>Class</code>接受<code>Generator</code>函数，写法<code> * [Symbol.iterator](){}</code>; <code>for of</code>循环会调用这个遍历器。<code>static</code>关键字用来定义静态方法，通过类来调用，且可被子类继承。</p>
		<p>类有修饰器decorator，通过<code>@decorator</code>使用在类上方。可以在编译时改变类的行为。为类添加属性或是方法。<code>decorator</code>接受目标函数，属性名，描述对象三个参数。</p>
		<br>
		<p><code>Module</code>也是ES6引入的新特性。主要有<code>export, import</code>命令组成，和CommonJS设计的规范十分类似。分别用<code>export{a,b,c} from xxx</code>和import {a,b,c} from xxx</code>。若想为输入的变量重新取名，可以用<code>as</code>关键字。可以用<code>*</code>代替模块名做整体引入。<code>module</code>命令也可以代替<code>import</code>完成整体引入。用法和<code>import</code>类似。<code>export default</code>命令指定默认输出，<code>import</code>时可以不带大括号，为导出的内容取任意名字。模块间允许继承。</p>
		<hr>
		<h1 id="groccery">杂项</h1>
		<h3 id="markdown">Markdown</h3>
		<p>Markdown的目标是易读易写，它让人专注于文章的内容而不是格式与排版。一篇使用markdown写作的文档，可以在任何文本编辑器内打开。从而带来的优点是，它可以通过git来进行版本控制和多人协同。Markdown更厉害的一点是，在插件的帮助下，可以书写数学公式。Markdown兼容HTML语法，且会自动转义HTML特殊字符。</p>
		<p>Markdown段落由一个或多个文本行组成，前后要有一个以上的空行。从而Markdown允许段落内的强迫换行。</p>
		<p>段首的<code>#</code>数目表示标题阶数。<code>#</code>空格后的内容为标题名称。区块引用在内容前加上>和空格，且支持嵌套引用。用<code>*, +</code>或<code>-</code>表示无序列表内容，数字接英文句点表示有序列表，后面亦要加空格。列表下的段落必须缩进4个空格或1个制表符。列表下的代码区快需要缩进两次。</p>
		<p>代码区块的写作需要缩进4个空格。区块内的特殊字符会自动转成HTML实体。使用3个以上的<code>*, -</code>或<code>_</code>可以创建分割线。<code>[name](link)</code>可以创建行内链接。<code>[name][id]</code>可以创建参考链接，在文段的任意位置，通过<code>[id]: url (some text)</code>和链接创建联系。链接辨别标签不缺分大小写。在<code>id</code>缺省时，会自动用<code>name</code>当作链接标签</p>
		<p>使用<code>*</code>或<code>-</code>包裹字符可以实现强调的效果，此时<code>*</code>和<code>-</code>需紧贴字符。使用反引号<code>`</code>包裹内容实现行内代码。若代码中也有反引号，可以用多个反引号开头。</p>
		<p><code>![alt text](href "img title")</code>可以插入图片，和链接类似，也有行内和参考两种形式。同时，markdown还会自动将<code>&lt;></code>内的网页和邮箱地址封装成链接的格式。关于表格的写法，参加<a href="http://www.jianshu.com/p/q81RER" target="_blank">链接</a>。Markdown还支持反斜杠转义特殊字符。</p>
		<p><i>### github里的readme.md就是用markdown写的。</i></p>
		<h3 id="jsonp">JSONP & CORS</h3>
		<p>同源策略由<span class="i">NetScape</span>网景公司提出。现在所有支持JS的浏览器都会使用这个策略。这个策略的意思是，只有相同域名、协议、端口下的脚本才会被执行，避免其他网页对本网页的非法篡改。因此，JS脚本不能跨域发起请求。除了使用Proxy server外，可以通过<strong>JSONP</strong>在服务器端支持的情况下，实现跨域访问。</p>
		<p><span class="i">JSONP(JSON with padding)</span>并不是一种协议，而是解决办法。它允许服务器端集成Script标签，返回客户端，并以js callback的形式实现跨域。它的原理主要利用了<code>&lt;script></code>标签对JS脚本的动态解析实现。callback在客户端注册，并放在url中传给服务器；服务器先生成JSON数据，再以JS的形式调用与callback同名的函数，并将JSON数据以入参的形式返回给客户端。从而实现跨域请求。</p>
		<p>下面是向一个支持JSONP请求的服务器发送跨域资源请求的代码，值得学习：</p>
		<pre><code>function getJSONP(url, success) {

    var ud = '_' + +new Date,
        script = document.createElement('script'),
        head = document.getElementsByTagName('head')[0] 
               || document.documentElement;

    window[ud] = function(data) {
        head.removeChild(script);
		//`success` can be undefined
        success && success(data);
    };

    script.src = url.replace('callback=?', 'callback=' + ud);
    head.appendChild(script);

}
</code></pre>
		<p><i>注1：JSONP跨域请求需要服务器端支持，且只支持<code>GET</code>请求。</i></p>
		<p><i>注2：jQuery支持JSONP，通过<code>$.getJSON</code>或其他基于<code>$.ajax()</code>的方法来加载JSON数据。</i></p>
		<p><span class="i">CORS（Cross-origin resource sharing）</span>跨域资源共享标准允许浏览器向跨域服务器发送XMLHttpRequest请求，克服了同源限制。CORS是新标准，需要浏览器和服务器同时支持，目前所有浏览器都支持此功能。整个CORS通信过程，由浏览器自动完成，用户在发起跨域AJAX请求时与同源时没有区别。浏览器发现跨域后会添加额外头信息，实现了CORS接口的服务器可以完成跨域请求的响应。CORS实现的重点在服务器端，具体内容可以学习<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank">阮一峰的博客</a>。</p>
		<h3 id="dependency_infection_intro">依赖注入</h3>
		<p>这个概念在学习NodeJS和AngularJS等时，都有出现，简单来讲，<strong>依赖</strong>是指在类或函数A里需要用到类或函数B. <strong>依赖注入</strong>即非自己主动初始化依赖，通过外部传入依赖。这样可以实现解耦和方便mock测试。更多的分析参见<a href="http://www.cnblogs.com/xingyukun/archive/2007/10/20/931331.html" target="_blank">链接</a>。</p>
		<h3 id="candy">语法糖</h3>
		<p><strong>语法糖</strong>（<span class="i">Syntactic sugar</span>），也译为<strong>糖衣语法</strong>，由英国计算机科学家Peter J. Landin发明的术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更便于程序员使用。语法糖并没有为计算机语言添加新功能，而是给程序员提供了更使用的编码方式。如C语言中用<code>a[i]表示*(a+i)</code>。</p>
		<h3 id="function_language">函数式编程</h3>
		<p>将函数（动词）视作和变量（名词）一样的地位，就可以称为函数式编程语言。极端如Java，纯粹的面向对象编程，不允许函数单独出现，必须包含在名词当中；或是某个虚幻的函数式语言圣地，不存在名词，均使用函数返回值来表现。<a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" target="_blank">名词王国的死刑</a>与它很好的<a href="http://lcwangchao.github.io/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/2012/07/02/excution_in_the_kingdom_of_nouns/" target="_blank">译文</a>出色的介绍了这些的利与弊。</p>
		<h3 id="iife">IIFE（立即执行函数）</h3>
		<p>方法中定义的属性和方法都置于内部作用域。IIFE利用此实现私有化，同时，在function定义后的<code>()</code>会被视为分组操作符，和之前的函数没有逻辑联系。但是，将<span class="i">function expression</span>部分用<code>()</code>包裹后，解析器不会将之作为<span class="i">func。ion declaration</span>解析，消除了歧义。而后的<code>()</code>就会被视为调用之前的function expression。</p>
		<p>类似的，使用表达式组合同样可以避免此歧义。如<code>0, function(){}()</code> <code>!function(){}()</code>甚至<code>new function(){}</code>。同时，推荐将整个表达式用<code>()</code>包裹，增加可读性。<a href="http://bbs.9ria.com/thread-113177-1-1.html" target="_blank">原文</a>给出了一个特别好的例子来说明变量私有化。</p>
		<p>	同时，因为没有名字，IIFE还可以避免污染当前作用域，实现类似模块的效果。原文也有例子展示。</p>
		<p>注：链接里的是译文，<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank">原文在此</a>。</p>
		<h3 id="stream">Nodejs中的Stream</h3>
		<p>使用流编程的概念在Unix时代就已经出现。Node中的stream模块完成的功能也与unix类似。两者的基本管道操作符分别是<code>.pipe()</code>和<code>|</code>。Node借助流可以将接口部分分割成多个可重用的部分。</p>
		<p><code>pipe</code>是stream中输入输出的实现方法，按照<code>src.pipe(dst)</code>的形式使用。Node中的流可以分为<code>readable, writeable, transform, duplex, classic</code>几种。<code>readable</code>流可以产出数据，调用<code>pipe</code>方法传送到<code>writable, duplex, transform</code>流中，也可以通过<code>read</code>方法直接消耗。<code>writable</code>流只能流进不能流出，通过定义一个<code>_write(chunk, enc, next)</code>将readable数据写入，通过调用<code>write()</code>方法可以直接向流中写东西。</p>
		<p>transform流和duplex流都可读可写。区别是transform流并不保存数据，只处理流经它的数据。classic流是一个古老的接口，有<code>readable</code>和<code>writable</code>两种。</p>
		<h3 id="crypto">Crypto</h3>
		<p>Crypto是NodeJS的一个加密算法库，提供了加密解密验证等功能。它基于<a href="https://www.openssl.org/" target="_blank">OpenSSL</a>的基础上开发，提供了一系列的哈希算法和签名验证等方法的封装。</p>
		<hr>
		<h3 id="tail">尾注</h3>
		<p>本文列举了十余项前端技术，涵盖了框架，包管理，包构建，模块规范，任务管理，可视化等方面。在测试框架，socket编程等方面还有欠缺。</p>
		<p>另外，网页的结构灵感来自于<span class="i">backbone.js</span>, <span class="i">underscore</span>和<span class="i">zepto</span>的文档网页设计，个人认为这种设计清晰简洁，没有一些“没必要的废话”。</p>
		<p>最后祝你，身体健康。</p>
		<p><i>2017/2/2</i></p>
	</div>
</body>
</html>